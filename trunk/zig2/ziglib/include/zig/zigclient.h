/*
		ZIG game-oriented networking engine
		Project Home: http://zige.sourceforge.net

		Copyright (c) 2002-2005, Fábio Reis Cecin.
		All rights reserved.
    
		This free software is licensed under a BSD-style license. Read the 
		LICENSE.TXT file for the full license.
*/
/*

	zigclient

	ZIG Game Engine Skeleton 
	client class

*/

#ifndef _ZIG_HEADER_ZIGCLIENT_H_
#define _ZIG_HEADER_ZIGCLIENT_H_

#include "client.h"
#include "console.h"
#include "address.h"
#include "serverinfo.h"

//some internal #define switches to control the implementation
#include "zigdefs.h"

using namespace std;

/*! \file zigclient.h
    \brief The <zig/zigclient.h> header file exposes some useful enums that are sent as arguments to or received 
		as return values from zigclient_c methods.
*/

/*! \brief Possible values for the \c zig_reason argument of a zigclient_c::disconnected() callback. */
enum zigclient_disconnection_reasons_t {

	/*! \brief The disconnection was generated by application code or there is not enough information. <B>This value 
			is and will always be 0 (zero).</B> */
	ZIGCLIENT_DISCONNECTED          = 0,

	/*! \brief Client-side disconnection generated by zigclient_c because the server has timed-out. This happens when 
			the client doesn't receive any packets from the server for a specified amount of time which is configured by 
			zigclient_c::set_server_timeout(). */
	ZIGCLIENT_DISCONNECTED_TIMEOUT,

	/*! \brief Immediate client-side disconnection generated by zigclient_c due to receipt of packet which does not 
			conform to the ZIG protocol. */
	ZIGCLIENT_DISCONNECTED_PROTOCOL_VIOLATION,

	/*! \brief An internal socket-related error has occurred (example: socket closed due to loss of network 
			connectivity). */
	ZIGCLIENT_DISCONNECTED_SOCKET_ERROR

};

/*! \brief Possible values for the \c zig_reason argument of a zigclient_c::connection_refused() callback. */
enum zigclient_connection_failure_reasons_t {

	/*! \brief The ZIG server implementation accepted the connection but the server-side application code refused the 
			connection. <B>This value is and will always be 0 (zero).</B> 

			This means that you should look on the \c reason (data buffer) parameter of the zigclient_c::connection_refused() 
			callback to know the actual reason of the disconnection. Of course, this buffer needs to be filled filled by your 
			application's server-side code (at zigserver_c::accept_client()) with data that describes the reason for the 
			connection being refused.
	*/
	ZIGCLIENT_CONNECTFAILED       = 0,  
		                                  
	/*! \brief The ZIG server implementation refused the connection because client and server are linked with 
			versions of the ZIG library which are incompatible.
	*/
	ZIGCLIENT_CONNECTFAILED_ZIGNET_VERSION_MISMATCH,

	/*! \brief The ZIG server implementation refused the connection. No further information available. */
	ZIGCLIENT_CONNECTFAILED_UNKNOWN
};

/*! \brief The client class. Extend this class and override its virtual methods to implement the client 
		part of your client-server game/application.

		HOW TO USE:
		The zigclient_c and zigserver_c classes work together as an unit. You develop your client-server game with 
		the ZIG library by extending the zigclient_c class to write the client-side code of your game, and you 
		extend the zigserver_c class to write the server-side code of your game. You also have to write the 
		communication protocol that will flow between the two.
		
    The zigclient_c class provides the basic functionality needed for implementing the client process of 
		a client-server real-time multiplayer game on the Internet. Those are:
		- Connecting to a remote game server (implemented by class zigserver_c);
		- Sending and receiving data to/from the server it is currently connected to;
		- Disconnecting from the game server;

		Usually, you would call the zigclient_c methods in the following order:
		- Call one or more of the "set_xxx()" methods to configure the ZIG client engine;
		- Call start() to open the client socket and initialize the client;
		- Call connect() and disconnect() several times to connect and disconnect from servers;
		- While connected, call process_nonblocking() frequently so packets incoming from the network can be processed;
		- While connected, call send_message(), receive_message() and the other methods that allows sending and 
		receiving stuff to/from the server. Also, deal with the callbacks such as connected(), disconnected(), 
		incoming_data(), etc.
		- Call stop() to finish the client and close the client socket.
    
		MESSAGES VS. PACKETS: 
		The communication happens in two different levels. First, there is the sending and receiving of <b>messages</b>. 
		Messages are blocks of bytes which are to be sent from one side of the connection to the other. However, when 
		a message is "sent", it is not actually sent through the network. It is placed on a queue with other messages. 
		When enough time has elapsed (or other condition) there is the sending and receiving of <b>UDP packets</b>. When 
		a packet is to be sent, it is first filled with some or all of the outgoing messages that are on the connection's 
		queues. If the packet is not dropped by the network, it is received by the other side and the received messages 
		are again placed in queues of incoming messages, from where they can be parsed by the other side.

		UDP PACKET SEND RATE:
		The zigclient_c class dispatches UDP packets in the same global rate that is configured by the zigserver_c it 
		is connected to. Please look at the documentation of class zigserver_c for instructions on how to change the 
		packet rate.

		SUB-APIs:
		You'll notice that the zigclient_c class has quite a lot of methods. Some of those methods can be grouped, 
		in the sense that some are related to others and the group of methods provides a service. The sections below 
		discuss in detail two important services provided by the zigclient_c API: Streams and Outgoing Input Packets.

		<hr>
		<b>Streams</b>
		<hr>

		RATIONALE: In ZIG 1.x, each connection supported only two ways to send messages. A message could be sent by 
		either "reliable mode" or "unreliable mode". All "reliable" messages that were sent from one side to the 
		other of the connection were totally ordered and had guaranteed delivery. In other words, if A was sent, and 
		then B, both messages would be guaranteed to arrive at the destination, but B would only arrive after A. 
		In contrast, all "unreliable" messages had no guarantee of neither order nor delivery, so if a reliable 
		message A was sent and then an unreliable message UB was sent, it would be possible to receive A and UB 
		on the other side in any order.

		This had three main drawbacks:
		- No support for ordering between messages with guaranteed and non-guaranteed delivery;
		- No support for partial ordering between messages with guaranteed delivery, that is, the ability to send 
		two messages A and B with guaranteed delivery but that can be received in any order on the other side;
		- The reliable messaging was optimized for latency (game packets) but not for bandwidth (file transfers);
		
    Since ZIG 2.0 there is a new, very important abstraction on ZIG's client-server connections, called "streams", 
		which solves those three problems.

		Each ZIG connection is now a collection of several streams. A stream supports sending and receiving 
		messages through it (a message is still a buffer_c filled with any data, like in previous ZIG versions). 
		Once a connection is estabilished, you can create as many streams as you like. Each stream has its own 
		integer ID number, starting from Stream ID 0 (zero) which is the only hard-coded stream that all ZIG 
		connections have by default.

		STREAM TYPES: The current types of streams that can exist in a connection are the following:
		- Stream zero (ID == 0): Sends messages without guarantees of neither delivery nor ordering. You cannot 
		create any other streams of this type because it just wouldn't make sense, currently. Messages sent through 
		this stream are queued and dispatched on the next outgoing UDP packet (IF there is room on it);
		- Streams of type STREAM_CUMULATIVE_ACK: Guarantees ordered receipt of all messages (if they arrive at all), 
		and supports mixed sending of "realiable" and "unreliable" messages (in regards to guarantee of delivery). 
		However, independently of the type of each message, the receiving end of the stream will receive all 
		messages in the same order that they were sent, with the exception of unreliable messages that were lost 
		in transit, which won't be received at all. This stream is optimized for low-latency communication, 
		trading off with bandwidth efficiency.
		- Streams of type STREAM_INDIVIDUAL_ACK: Guarantees delivery and order of all messages. This stream is 
		optimized for bandwidth efficiency (should be decent if compared with TCP in favorable network conditions), 
		trading off with increased communication latency.
		- Streams of type STREAM_NO_ACK: No guaranteed delivery and no guaranteed ordering. The same as UDP/IP and
		the same as the "unreliable data block" argument of zigclient_c::send_packet() and zigserver_c::send_packet(), 
		but with the difference that there is a little overhead necessary for separating the messages within the 
		stream payload of a ZIG UDP packet (which applies for all messages inside of any streams of any type).

		STREAM POLICY: Besides the type of the stream, you can also configure some parameters on the stream. On the API, 
		they are called the 'policy' of the stream. Please see the documentation for class policy_c and the documentation 
		of the create_stream() method.

		HOW TO USE ZIG STREAMS:
		- To send "unrealiable" messages through "Stream 0" from the client (to the server), you can use the 
		<b>Outgoing Input Packets</b> feature (see section below) or you can call send_packet() directly 
		(see section below, also);
		- Receiving "unreliable" messages through "Stream 0" at the client (from the server) is trivial: it is 
		given as the first parameter (buffer_c&) of the incoming_data() callback.
		- To create streams of either type STREAM_CUMULATIVE_ACK or STREAM_INDIVIDUAL_ACK, call create_stream().
		- To send a message through one of the created streams, call send_message();
		- To receive a message through one of the created streams, call receive_message(int) or 
		receive_message(buffer_c&,int).

		<hr>
		<b>Outgoing Input Packets</b>
		<hr>

		As discussed above, the client send UDP packets to the server at the same frequency that it receives 
		packets from the server. So you can configure your game to send packets in a preconfigured rate (such as 10, 15 
		or 20 times per second) and let it at that. 

		However, the sending of packets from a game client to a game server has a peculiarity which might require 
		a more flexible packet frequency. On an action game such as a first-person shooter or any kind of run'n'gun game, 
		it can be the case that the client sends a message to the server every time the user presses a key on the keyboard. 
		The message contains the command of the player, such as firing a weapon or changing the acceleration vector of 
		his avatar (to change direction and/or speed). If this is the case, it can (or not) be wise to dispatch an UDP 
		packet right after the message is sent by the game code. If the game is dispatching UDP packets 10 times per 
		second, then player commands can have to wait up to 100ms of latency (50ms on average) until they are actually 
		sent through the network and to the server. This makes the game less responsive. Increasing the rate of packets 
		may not be the best solution for this, since players can be just 'sitting idly' in the game and all those packets 
		are wasted.

		The zigclient_c class can temporarily increase the frequency of packet sending. The basic idea is that the 
		client has a block of bytes that describes the current state of its input devices (keypresses, mouse and joystick 
		activity, etc). When the state of the user input changes (for instance, when the user was not pressing the 
		'fire' button and then presses it, or when the user was pressing the key for 'moving left' and then releases it), 
		you may call the method input_changed(buffer_c &), passing a buffer_c parameter that describes the current state 
		of the player's input devices. The zigclient_c code will then decide if the next UDP packet should be sent sooner. 

		Each call to input_changed(buffer_c &) fully overwrites the previous one. This is key: the input block which is 
		updated through the input_changed(buffer_c &) call is sent as 'unreliable' data (through Stream 0) on each 
		outgoing packet. If the input block is not updated, it will be sent over and over to the server on every outgoing 
		packet, until it is replaced. So, the server receives the client's input block through Stream 0.
		
		KEYBOARD HAMMERING PROTECTION: If too many calls to input_changed(buffer_c &) are made (for instance, if the player 
		is hammering furiously on his keyboard!) then zigclient_c will just overwrite the input block several times. This 
		will increase the frequency of outgoing packets, but the increase in the packet rate is not directly proportional 
		to the increase in calls to input_changed(buffer_c &). Each call to input_changed(buffer_c &) cuts the remaining 
		time for the next packet in half, so if there is still 80ms until the next packet is sent, an update to the input 
		block will cut the wait to 40ms (-40), but the next call will cut it to 20ms (-20) instead of reducing it to zero 
		(-40 again). This is a very simple heuristic that can be improved upon (contributions welcome).

		SENDING PACKETS IMMEDIATELY: However, if you <b>must</b> send the client's input to the server immediately, you 
		can call send_packet_soon() or send_packet_now(). Please see the documentation of those methods for details.

    'CONTINUOUS' INPUT DEVICES: The device above is good for dealing with keyboard-like game input, but what about 
		mouse or joystick movement? Those devices can change their state at a very high rate. For instance, you can poll 
		the mouse device a hundred times per second and get a different (X,Y) position reading almost every time if the 
		user is moving the mouse. In this scenario, it does not make sense to increase or to reduce the packet rate 
		according to device activity. For those devices, the before_packet_send() callback is more appropriate: it is 
		called every time a packet is about to be sent. You can place calls to input_changed_noflush() inside this callback 
		which update the current mouse position, for instance. This is the best approach because it stalls the encoding 
		of the input device's state until the last moment, when the packet is being sent, so the packet is sent with the 
		most up-to-date data regarding the state of the input device.

		HOW TO BYPASS THE 'INPUT PACKET' FEATURE: The zigclient_c will send at least as many packets at it receives from 
		the server and this cannot be changed (it is needed to keep messaging working efficiently). Those "automatic" 
		packets send, on their "Stream 0" block of bytes, the contents of the input block which are updated through 
		input_changed() or input_changed_noflush(), exclusively. This also cannot be changed. 
		
		In light of this, you can send whatever you want on those "automatic" packets by putting whatever you want on 
		the "input block" (which is just a block of bytes, really), and you can update the input block at any time you 
		want and also at the before_packet_send() callback. Additionally, you can send a packet to the server at any 
		time by calling send_packet() directly. However, you must supply the contents of the unreliable block manually 
		on the send_packet() call, since it won't send the input block automatically. Actually, this whole 'input' 
		feature is implemented on top of send_packet() by calling send_packet() with the input block as the "unreliable 
		data" parameter.
*/
class zigclient_c : public client_behavior_i, public serverinfo_listener_i {
public:

	/*! \brief Empty constructor. Log messages will be sent to the default console.

			This constructor does not set a console_c instance. This means that all messages generated by this 
			zigclient_c instance will be sent to the default console, which can be obtained by the static call 
			console_c::get_default_console().
			
			Call set_console() after using this constructor if you wish to log to a specific console.
	*/
	zigclient_c();

	/*! \brief Constructor that provides a console where the instance can log its messages to. 
	*/
	zigclient_c(console_c *conio);

	/*! \brief Destructor.
	*/
	virtual ~zigclient_c();

	/*! \brief Set the console instance where this zigclient_c instance will send its messages to.
	*/
	void set_console(console_c *conio);

	// ----------------------------------------------------------------------------------------
	//    BASIC CONFIGURATION AND START/STOP METHODS:
	// ----------------------------------------------------------------------------------------

	/*! \brief Sets the allowed IP port range for the client's local address.

			Usually you shouldn't need to call this method.

			This method configures the allowed port range for the UDP sockets that this client opens locally. By 
			default, the client port range is not specified and any and all sockets that the client opens will have 
			a port number automatically chosen by the OS. 
			
			If the port range is specified, client sockets will always be opened with a port number which is in the 
			range [minport, maxport] (inclusive). If no local ports are available over the chosen range, then the 
			client is unable to open UDP sockets and any connect() attempts will result in errors (e.g. "connection 
			failure" or the like). 

			If either argument is <= 0 (zero) or > 65535, or if (minport > maxport), then the local port range is 
			unspecified (disabled).

			\param minport Minimum allowed value for the port number for the UDP socket this client opens when it is 
			attempting to connect to a server. Good values are in range [1, 65535], any other value disables the port 
			range.
			\param maxport Maximum allowed value for the port number for the UDP socket this client opens when it is 
			attempting to connect to a server. Good values are in range [1, 65535], any other value disables the port 
			range. And, if (minport > maxport), the port range is also disabled.
	*/
	void set_local_port_range(int minport, int maxport) { 
		if ((minport <= 0) || (minport > 65535) || (maxport <= 0) || (maxport >= 65535) || (minport > maxport)) {
			use_port_range = false;  // client port range configuration: disabled
			this->minport = 0;
			this->maxport = 0;
		} else {
			use_port_range = true; // client port range configuration: enabled
			this->minport = minport; 
			this->maxport = maxport;
		}
	}

////// DEPRECATED
	/*! \brief Sets the timeout, in seconds, for disconnection attempts. Default is 5 seconds.

			When the client tries to disconnect from the server, it keeps sending disconnection requests to the 
			server and waits for the server to acknowledge the receipt of its disconnection request before 
			effectively shutting down the network channel (closing the socket). But, if the server doesn't acknowledge 
			the disconnection request in 'X' seconds, the client gives up and just dies. 'X' is the shutdown timeout.

			\param timeout Amount of time, in seconds, that the client waits for the server to acknowledge its 
			disconnection, before shutting down.
	*/
	//void set_shutdown_timeout(int timeout = 5) { shutdown_timeout = timeout; }
///////////////// DEPRECATED




	/*! \brief Sets the timeout, in seconds, for estabilished connections. Default is 30 seconds.

			A ZIG client-server connection is a bi-directional and constant flow of UDP packets. If either end stops 
			receiving UDP packets for a "long" time, then the other end will assume that the other end died and kill 
			the connection.

      This method configures the server-to-client UDP timeout, that is, the maximum amount of time that this 
			zigclient_c waits for the next UDP packet before assuming that the zigserver_c on the other end died or 
			has become unreachable.

			\param timeout Maximum amount of time, in seconds, that the client will wait for the next UDP packet from 
			the server.
	*/
	void set_server_timeout(int timeout = 30) { cfg_server_timeout = timeout; }

	/*! \brief Sets the timeout, in seconds, for connection attempts. Default is 4 seconds.

			When the client is trying to connect to a server, it sends connection request packets, and will wait at 
			most 'X' seconds before giving up and failing the connection request. 'X' is the connect timeout.

			\param timeout Maximum amount of time, in seconds, that the client will wait for the response from the server 
			it is trying to connect to.
	*/
	void set_connect_timeout(int timeout = 4) { 
		cfg_connect_timeout = timeout; 
		if (client) client->set_connect_timeout(timeout);
	}

	/*! \brief Sets the maximum desired size of outgoing UDP packets.

			This parameter is a 'maximum recommended' value and can be ignored sometimes if the ZIG implementation feels 
			that it will do more good than harm. However, it is a hint value that is followed whenever possible. 

			\param max_packet_size Maximum size, in bytes, of outgoing UDP packets. Default value is 65536 bytes (64 Kb).
	*/
	void set_max_outgoing_packet_sizes(int max_packet_size) {
		cfg_max_packet_size = max_packet_size;
		if (client) client->set_max_outgoing_packet_size(max_packet_size);
	}

	/*! \brief Enables or disables packet compression, and also sets the minimum size that packets must have before 
			being compressed. 
      
			To turn on the sending of compressed packets at any time, call set_compression() with positive or zero 
			parameter value. In this case, the \c minimum_packet_size argument specifies the minimum size, in bytes, of 
			packets that are to be compressed. 

			To turn off packet compression, call set_compression() without arguments or with a negative argument value.

			Examples:
			- If \c minimum_packet_size is 0 (zero), then all outgoing packets are compressed;
			- If \c minimum_packet_size is 250, then a packet with 249 bytes or less is sent un-compressed, but a packet 
			with 250 bytes or more is sent in compressed form;
			- If \c minimum_packet_size is -1, then packet compression is disabled altogether.

			NOTE: this call resets the compression stats.

			\param minimum_packet_size Configuration for the packet compression of this zigclient (see above). 
	*/
	void set_compression(int minimum_packet_size = -1) {
		compression_config = minimum_packet_size;
		if (client) client->set_compression(compression_config);
	}

	double get_loss_estimative() { if (client) return client->get_loss_estimative(); else return -1.0; }

	double get_delay_estimative() { if (client) return client->get_delay_estimative(); else return -1.0; }

	double get_rtt_estimative() const { if (client) return client->get_rtt_estimative(); else return -1.0; }

	/*! \brief Starts the client by opening its UDP socket and initializing the application. <b>IMPORTANT</b>
			
			This method opens the UDP socket that the client will use to connect and communicate with a zigserver_c  
			instance. It also calls zigclient_c::init() so that the application client can initialize itself.

			<b>IMPORTANT</b>: 
			
			- You <b>must</b> call this method before attempting to connect() to a server!
			- You <b>must</b> call process_nonblocking() frequently after calling this method! (see the documentation 
			on process_nonblocking() for more details)
			
			\return 
			- \c true if socket is opened successfully and the client is ready to connect();
			- \c false if socket could not be opened or some other (very bad) error occurred.
	*/
	bool start();

	/*! \brief Stops the client, closing its UDP socket and finishing the application. <b>IMPORTANT</b>

			You should call this method before deleting your zigclient_c instance or killing the process/application. 
			If the client is still connected to a server, it will try to gracefully disconnect for a few seconds 
			before it closes its socket (see set_shutdown_timeout() for details on how to configure this behavior). 
			This is good for the server and the other players that might be playing on the same server.

			In other words, this method ensures that the client shuts down tidily. It also ensures that 
			zigclient_c::finish() is called, so that the application client can clean up after itself.
	*/
	bool stop();

	/*! \brief Processes any pending tasks on the client's network engine. <b>IMPORTANT</b>

			<b>IMPORTANT</b>: This method <b>must</b> be called periodically after a call to start() is made! 
			While this method is not being called, incoming packets will just pile up. This call reads from the 
			local socket and processes the incoming packets, sending the incoming data through callbacks - 
			see incoming_data() -, or placing them on message queues - see receive_message(). This method also 
			checks for some time-related events such as connection timeouts.

			<b>HINT</b>: Just place a call to this method on the 'main loop' of your game-client code, where you 
			should already be dealing with stuff like redrawing the game screen and reading from game input devices. 
			Calling this method between 20 and 100 times per second should be enough for most real-time games.

			\return 
			- \c false if some failure occurs (client is not running/connected);
			- \c true if everything is OK.
	*/
	bool process_nonblocking();

	/*! \brief Asks a specific game server for general information. 

			This method is the zigclient_c equivalent of serverinfo_c::get_server_info(address_c&, int). Please see 
			its documentation for a detailed discussion. The advantage of using this method is that it doesn't require 
			an instance of serverinfo_c to be explicitly created and polled. 
			
			The result of the query comes in one incoming_server_info() callback.

			\param server_addr Full address of the server: IP address (or hostname) and port number;
			\param timeout_ms Query timeout, in milliseconds. Default is 3000 milliseconds.
	*/
	void get_server_info(address_c &server_addr, int timeout_ms = 3000);

	/*! \brief Asks a specific game server for specific information.

			This method is the zigclient_c equivalent of serverinfo_c::get_server_info(address_c&, buffer_c&, int). Please 
			see its documentation for a detailed discussion. The advantage of using this method is that it doesn't require 
			an instance of serverinfo_c to be explicitly created and polled. 

			The result of the query comes in an incoming_server_info() callback.

			\param server_addr Full address of the server: IP address (or hostname) and port number;
			\param custom A block of bytes which is sent as argument to the query;
			\param timeout_ms Query timeout, in milliseconds. Default is 3000 milliseconds.
	*/
	void get_server_info(address_c &server_addr, buffer_c &custom, int timeout_ms = 3000);

	/*! \brief Asks all game servers on the local network (LAN) for general information. 

			This method is the zigclient_c equivalent of serverinfo_c::get_local_server_info(int, int). Please see 
			its documentation for a detailed discussion. The advantage of using this method is that it doesn't require 
			an instance of serverinfo_c to be explicitly created and polled. 

			The result of the query comes in one or more incoming_server_info() calls.

			\param timeout_ms Query timeout, in milliseconds. Default is 1500 milliseconds.
			\param broadcast_port The UDP broadcast port that the server(s) are listening at. The default is 54876 
			(ZIG_DEFAULT_BROADCAST_PORT). You don't have to change this if you haven't changed it at zigserver_c.
	*/
	void get_local_server_info(int timeout_ms = 1500, int broadcast_port = ZIG_DEFAULT_BROADCAST_PORT);

	/*! \brief Asks all game servers on the local network (LAN) for specific information. 

			This method is the zigclient_c equivalent of serverinfo_c::get_local_server_info(buffer_c&, int, int). Please 
			see its documentation for a detailed discussion. The advantage of using this method is that it doesn't require 
			an instance of serverinfo_c to be explicitly created and polled. 

			The result of the query comes in one or more incoming_server_info() calls.

			\param custom A block of bytes which is sent as argument to the query;
			\param timeout_ms Query timeout, in milliseconds. Default is 1500 milliseconds.
			\param broadcast_port The UDP broadcast port that the server(s) are listening at. The default is 54876 
			(ZIG_DEFAULT_BROADCAST_PORT). You don't have to change this if you haven't changed it at zigserver_c.
	*/
	void get_local_server_info(buffer_c &custom, int timeout_ms = 1500, int broadcast_port = ZIG_DEFAULT_BROADCAST_PORT);

	/*! \brief Sets the data block that will be sent along with all connection requests made by this client. 

			When one of the connect() methods is called, the client will start sending UDP packets to a server. 
			Those packets have a request for connection which is handled by the ZIG server code, and they have 
			an (optional) argument set by the game client which is to be delivered to the game server, which is 
			this 'connect data' block.

			The \c data parameter specifies the data block which will be passed to a zigserver_c::accept_client() 
			call as its \c custom argument. This allows the game server to use the connect data passed by the 
			client, for instance, to decide if the client will be accepted or not. The connect data block can 
			also be used give initial information such as the desired player's name, colors, etc. However, it is 
			somewhat important that the connect data block is kept small (around 1 Kbyte or so of information 
			should still be O.K.) so that the connection request packets have an increased chance of being 
			delivered, and quickly.

			\param data A block of bytes which is to be sent from the game client to the game server during the connection 
			handshake initiated by one of the zigclient_c::connect() methods.
	*/
	void set_connect_data(buffer_c &data);

	/*! \brief Starts a connection attempt to the server at the specified remote address.

			This method does the same as connect(address_c&), but accepts a string parameter instead.

			This method makes this ZIG client engine attempt to connecto to a ZIG server which is running at the 
			remote address specified by the \c server_addr parameter.

			If the connection attempt is started successfully then the result will come in one of the following 
			callbacks: connected(), connection_refused() or connection_timed_out(), if the connection was 
			accepted, rejected, or if it has timed out, respectfully.

			\param server_addr Address of the server as a character string which should be in IP:PORT format 
			(e.g. "143.54.12.74:8500") or HOSTNAME:PORT format (e.g. "Blaster.inf.ufrgs.br:8500", where the ":PORT" 
			suffix is always optional;
			\return Returns a status code that informs whether the connection process is started or not:
			- \c false Could not start the connection attempt (e.g.: start() was not called so the client's UDP socket 
			isn't available for sending connection request packets);
			- \c true The connection attempt was started successfully and the result of the connection attempt will 
			come in one of the following callbacks: connected(), connection_refused() or connection_timed_out().

			\see set_connect_data()
			\see set_connect_timeout()
			\see connect(address_c&)
	*/
	bool connect(string server_addr);

	/*! \brief Starts a connection attempt to the server at the specified remote address.

			This method does exactly the same as connect(string), but accepts an address_c parameter instead. 
			Please see the documentation of connect(string) for more details.

			\param server_addr Address of the server as an address_c instance;
			\return Returns a status code that informs whether the connection process is started or not:
			- \c false Could not start the connection attempt (e.g.: start() was not called so the client's UDP socket 
			isn't available for sending connection request packets);
			- \c true The connection attempt was started successfully and the result of the connection attempt will 
			come in one of the following callbacks: connected(), connection_refused() or connection_timed_out().

			\see connect(string)
			\see set_connect_data()
			\see set_connect_timeout()
	*/
	bool connect(address_c &server_addr);

	/*! \brief Disconnects the client from the server it is currently connected to.

			\param code_reason Optional int parameter which is intented as a hint to the game client itself of the 
			reason of the disconnection. This value will appear unmodified on the forecoming disconnected() callback 
			as its \c code_reason parameter, so the range of values to be used is entirely up to the game/application. 
			Default is 0 (zero).

			\see disconnected(bool,buffer_c&,int,int)
	*/
	void disconnect(int code_reason = 0);

	/*! \brief Checks whether this ZIG client is connected to a ZIG server or not.

			\return Is this client connected to a server?
			- \c true Yes.
			- \c false No.
	*/
	bool is_connected() { if (client) return client->is_connected(); return false; }

	/*! \brief Causes the sending of the next <i>input packet</i>, from this client to the server, to occur at the 
			next call to process_nonblocking().

			Please see the general documentation of zigclient_c for a (hopefully) through explanation of what 'input packets' 
			are. The short story is that 'input packets' are the UDP packets sent (automatically) by zigclient_c instances 
			and which carry, as their 'unreliable' data block (also called 'stream 0'), the exact contents set by the last 
			call to input_changed(buffer_c&). These packets are generated by the zigclient_c implementation with a call to 
			send_packet() with the last 'input' buffer passed as send_packet()'s first parameter (the unreliable data block).

			Application code can call this method multiple times before the next call to process_nonblocking() is made. The 
			latter calls will have no effect (that is, it will not cause the sending of multiple UDP packets -- which is 
			what would happen if send_input_packet() was called multiple times in a row).

			<B>NOTE:</B> This method was called send_packet_now() before ZIG version 2.0.

			\see send_input_packet()
			\see send_packet()
			\see zigclient_c for a discussion about the 'input' sub-API and its caveats
	*/ 
	void send_input_packet_soon() { last_packet_send = 0.0; }

	/*! \brief Sends an <i>input packet</i> from this client to the server.

			Please see the general documentation of zigclient_c for a (hopefully) through explanation of what 'input packets' 
			are. The short story is that 'input packets' are the UDP packets sent (automatically) by zigclient_c instances 
			and which carry, as their 'unreliable' data block (also called 'stream 0'), the exact contents set by the last 
			call to input_changed(buffer_c&). These packets are generated by the zigclient_c implementation with a call to 
			send_packet() with the last 'input' buffer passed as send_packet()'s first parameter (the unreliable data block).

			Each call to this method generates one UDP packet. If this is not what you need, please take a look at 
			send_input_packet_soon().

			\see send_input_packet_soon()
			\see send_packet()
			\see zigclient_c for a discussion about the 'input' sub-API and its caveats
	*/
	void send_input_packet();

	/*! \brief Notifies ZIG that the local player's <i>input state</i> has changed, and shortens the time remanining 
			for dispatching the next UDP packet to the server.

			Please see the general documentation of zigclient_c for a (hopefully) through explanation of what 'input state' 
			is. The short story is that the 'input state' is a data block which describes the current state of the local 
			player's game input devices (keyboard keys pressed or not, mouse coordinates and buttons, joystick positions 
			and buttons, etc). Whenever the input devices change their state, ZIG should be notified, so that it can send 
			updated 'input packets'.

			So this method notifies that a game player input changed (the unreliable portion of the outgoing client data 
			packet). The argument \c udata is the new unreliable portion of client packets to the server from now on. 
			
			So, calling this method updates the 'input' unreliable block which ZIG is sending periodically, automatically, 
			to the server, and also speeds up the sending of the next packet, which reduce the lag between a keypress and 
			the actual send of the command packet.

			The format of the \c udata parameter is entirely left for the application. It is recommended that only information 
			that matters to the game/application is encoded. For instance, only the keyboard keys which matter for a particular 
			game should be encoded, not the entire keyboard state. 
			
			The \c udata parameter (the contents of the buffer) are sent on ZIG UDP packets to the server as 'unreliable' 
			data blocks (stream 0), so it is possible that packet loss might prevent some states from ever reaching the 
			server. 

			The \c udata parameter shows up at the zigserver_c::client_incoming_data() callback as its \c in parameter. One 
			should notice that once input_changed() is called with a particular \c udata contents parameter, these contents 
			may and will show up repeatedly on the server at the zigserver_c::client_incoming_data() callback. This means, 
			at the server side, that the client in question has not detected any relevant changes to the local player's 
			input devices. This goes on until the 'input state' is updated again on the client and a subsequent UDP packet is 
			received by the server.

			<B>IMPORTANT:</B> Usually, the ZIG client will sent packets to the ZIG server at the same rate that the server 
			sends packets to it. However, a call to input_changed() will speed up the sending of the next UDP packet to 
			the server. If this side-effect is not desired, then please use input_changed_noflush() instead.

			\param udata The updated block of data which describes the state of the local player's input devices.

			\see input_changed_noflush(buffer_c&)
			\see zigclient_c for a discussion about the 'input' sub-API and its caveats
	*/
	void input_changed(buffer_c &udata) {
		keyout = udata;
		keyout_changed = true;
	}

	/*! \brief Notifies ZIG that the local player's <i>input state</i> has changed.

			Please see the general documentation of zigclient_c for a (hopefully) through explanation of what 'input state' 
			is. The short story is that the 'input state' is a data block which describes the current state of the local 
			player's game input devices (keyboard keys pressed or not, mouse coordinates and buttons, joystick positions 
			and buttons, etc). Whenever the input devices change their state, ZIG should be notified, so that it can send 
			updated 'input packets'.

			The format of the \c udata parameter is entirely left for the application. It is recommended that only information 
			that matters to the game/application is encoded. For instance, only the keyboard keys which matter for a particular 
			game should be encoded, not the entire keyboard state. 
			
			The \c udata parameter (the contents of the buffer) are sent on ZIG UDP packets to the server as 'unreliable' 
			data blocks (stream 0), so it is possible that packet loss might prevent some states from ever reaching the 
			server. 

			The \c udata parameter shows up at the zigserver_c::client_incoming_data() callback as its \c in parameter. One 
			should notice that once input_changed() is called with a particular \c udata contents parameter, these contents 
			may and will show up repeatedly on the server at the zigserver_c::client_incoming_data() callback. This means, 
			at the server side, that the client in question has not detected any relevant changes to the local player's 
			input devices. This goes on until the 'input state' is updated again on the client and a subsequent UDP packet is 
			received by the server.

			<B>IMPORTANT:</B> This method won't send an UDP packet immediately to the server. Neither will it speed up the 
			sending of the next one, which is what input_changed() does. If you want the server to receive the updated 
			'input' data ASAP, please call input_changed() instead.

			\param udata The updated block of data which describes the state of the local player's input devices.

			\see input_changed(buffer_c&)
			\see zigclient_c for a discussion about the 'input' sub-API and its caveats
	*/
	void input_changed_noflush(buffer_c &udata) {
		keyout = udata;
	}

	// ----------------------------------------------------------------------------------------
	//    METHODS THAT SHOULD BE OVERRIDEN: 
	// ----------------------------------------------------------------------------------------

	/*! \brief <B>SHOULD BE OVERRIDEN</B>. Callback that the application client should use to perform initializations.

  		This method is called by start() if the ZIG client networking engine is started successfully so that the 
			client application may initialize itself -- e.g.: load resources, initialize data structures, etc.

			The default implementation of this method does nothing and returns \c true;
			
      \return When overriden in a sub-class (application), it should return a boolean value indicating whether 
			the application has initialized successfully or not:
			- \c true Application init was OK. ZIG client and application are ready for connections;
			- \c false Application init was unsuccessful. ZIG client's engine is halted (the effects of start() are 
			cancelled, local socket is closed, etc).
	*/ 
	virtual bool init() { return true; }

	/*! \brief <B>SHOULD BE OVERRIDEN</B>. Callback that the application client should use to perform clean-ups.

			This method is called by stop(), when the ZIG client is being stopped and/or deleted (destructor of the 
			zigclient_c object calls stop() if it is still started), so that the client application may finish -- 
			e.g.: release memory, save files, etc.

			The default implementation of this method does nothing.
	*/ 
	virtual void finish() { }

	/*! \brief <B>MAY BE OVERRIDEN</B>. Callback called before the ZIG client implementation dispatches an 'input packet' 
			to the server, which the application can use to update its 'input state' through input_changed_noflush().

			Please see the general documentation of zigclient_c for a (hopefully) through explanation of what 'input state' 
			and 'input packet' are.

      This callback offers, for the application code, a chance to change to update the 'input state' just before 
			it is sent to the server. This would be best accomplished by calling input_changed_noflush() from this 
			callback.

			The default implementation of this method does nothing.

			\see zigclient_c for a discussion about the 'input' sub-API and its caveats
			\see input_changed_noflush()
	*/ 
	virtual void before_packet_send() { }

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback that informs the application that its pending request to connect to 
			a remote server has been accepted.

			This call is an opportunity for the game client to perform any initialization or action related to a connection 
			having just been estabilished with a game server.

			This method has no default implementation so it <b>must</b> be implemented on the application's sub-class.
			
      \param hello A message sent by the server when the connection was accepted (filled in by the application 
			server's implementation of the zigserver_c::accept_client() method through the \c answer parameter).
	*/ 
	virtual void connected(buffer_c &hello) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback that informs the application that its pending request to connect to 
			a remote server has not been answered in time.

			A connect() attempt times out if the remote server doesn't answer in the time interval configured by 
			set_connect_timeout().

			This method has no default implementation so it <b>must</b> be implemented on the application's sub-class.
	*/ 
	virtual void connection_timed_out() = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Call that informs the application that its pending request to connect to 
			a remote server has been refused by the server.

			The game server has refused the client connection by returning \c false on its subclass implementation 
			of zigserver_c::accept_client().

			This method has no default implementation so it <b>must</b> be implemented on the application's sub-class.

			\param reason A message that describes why the game server has refused the game client's connection. Its 
			format is entirely left for the application. It is filled by the game server's subclass implementation of 
			zigserver_c::accept_client() through the \c answer parameter.
			\param zig_reason An int error code which tells that the connection was refused by the zigserver_c 
			implementation, not the application's game server code. The possible values are enumerated in 
			zigclient.h::zigclient_connection_failure_reasons_t.
	*/ 
	virtual void connection_refused(buffer_c &reason, int zig_reason) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback that informs the application that this client's active connection 
			has been lost and the client is now disconnected from a server. 

			This method has no default implementation so it <b>must</b> be implemented on the application's sub-class.

			\param server_initiated Whether the disconnection was triggered by the server or by the client itself:
			- \c true if the server disconnected the client (that is, the ZIG client implementation receives a disconnect 
			message from the ZIG server implementation and then generates this disconnection event);
			- \c false if the client disconnected itself (that is, the ZIG client implementation is generating this 
			disconnection without having received any disconnect messages from the ZIG server implementation).
			\param reason A message which explains the reason for the disconnection:
			- \c If server-initiated, this is filled by one of the zigserver_c::disconnect_client() callbacks through 
			their \c reason parameters;
			- \c If client-initiated, this is empty.
			\param code_reason A code which explains the application code's reason for the disconnection:
			- \c If server-initiated, this is 0 (zero).
			- \c If client-initiated, this is filled by the zigclient_c::disconnect() call through its \c code_reason 
			parameter. That is, if any such call was made, otherwise it is 0 (zero).
			\param zig_reason A code which explains the ZIG implementation's reason for the disconnection. The possible 
			values are enumerated in zigclient.h::zigclient_disconnection_reasons_t.
	*/
	virtual void disconnected(bool server_initiated, buffer_c &reason, int code_reason, int zig_reason) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback that informs the application that an UDP packet has been received 
			from the server. 

			The \c in parameter is filled by a zigserver_c::send_packet() call through its \c udata parameter.

			This callback is a good place to call receive_message(int) or receive_message(buffer_c&,int), because upon 
			receiving an UDP packet, ZIG will read the message streams and place new incoming messages on the stream queues, 
			so that the app may fetch and process them.

			This method is called by process_nonblocking(), which does the actual socket polling and reading.

			\param in The 'unreliable data block' of the packet, which is information that ZIG will not retransmit if the 
			packet is lost.
      \param packet_id The internal ZIG packet ID of the received packet.
	*/
	virtual void incoming_data(buffer_c &in, int packet_id) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Called whenever there is either a time-out or an answer to a pending 
			server-info query.

			This method is called in response to any of the get_server_info() or get_local_server_info() calls. 

			The \c timedout parameter should be looked into first. It tells if the callback signals the 'timeout' of a 
			server-info request, or if it is an actual, valid info response from a server:
			- If the \c timedout flag is \c true, then the ZIG client is reporting to the game client that a server-info 
			query was not answered by the server on time (in case it is a get_server_info() response), or that the query 
			has timed out and the LAN scan for servers is complete (in case it is a get_local_server_info() response);
			- If the \c timedout flag is \c false, then \c info will be filled with a server's answer (the server-info 
			which the client wants).

			The \c addr parameter can either contain a valid server address or an invalid server address. Call \c addr.valid() 
			to check if it is a valid address:
			- If it is an invalid address, then \c timedout must be \c true, and this signals that this callback is a 
			response to a get_local_server_info() query. This means that the LAN scan for servers is completed (time is up).
			- If it is a valid address, then it contains the address of the server that answered to a query or, if 
			\c timedout is \c true, then it means that the server in question was queried through get_server_info() but did 
			not answer on time.

			The \c time_ms parameter will contain the time elapsed, in milliseconds, from the request to this response, 
			regardless of what the response actually is (time-out, success, LAN scan or specific server query).

			For each get_server_info() call, there will be exactly one incoming_server_info() callback, with the server's 
			address on \c addr and the \c timedout parameter telling if it is an answer from the server or if the server's 
			response was not received.

			For each get_local_server_info() call, there will be zero or more callbacks with the \c timedout flag set to 
			\c false. These contain responses from servers on the local LAN. After the time-out parameter of the query 
			elapses, a single incoming_server_info() callback with an invalid (empty) \c addr and a \c timedout flag set 
			to \c true will be called to let the application know that the LAN scan is completed. This last time-out 
			callback is ALWAYS called after a get_local_server_info() query completes, whether any servers are found or not.

			\param addr Depends on whether \c timedout is \c true or \c false:
			- \c timedout == \c false : Then \c addr contains the address of the server that responded to a get_server_info() 
			or get_local_server_info() query;
			- \c timedout == \c true : Depends on whether \c addr contains a valid address or not:
			  - valid \c addr: Then \c addr contains the address of the server that did not respond on time to a 
			get_server_info() query;
			  - invalid \c addr: Then the callback is signaling that a get_local_server_info() query (LAN scan) has 
			completed/expired/finished.
			\param info Information replied by the server (if any). This is the actual answer, which is generated by 
			the implementation of zigserver_c::get_server_info().
			\param time_ms Delay (in milliseconds) between sending the request and receiving this response.
			\param timedout For server-specific queries, means that the request either completed or timed-out. For LAN queries 
			it means that it is either a server response or a notification of the end of the LAN scan (see above).
	*/
	virtual void incoming_server_info(address_c &addr, buffer_c &info, int time_ms, bool timedout) = 0;

	// ----------------------------------------------------------------------------------------
	//    MESSAGING METHODS TO CALL WHILE CONNECTED TO A SERVER:
	// ----------------------------------------------------------------------------------------

	/*! \brief Sends a ZIG UDP packet from this client to the server it is connected to.

			THE ZIG PACKET: the UDP packet that is generated by this call follows the ZIG internal protocol. Those 
			ZIG packets may contain each zero or more stream blocks. Each stream block contains zero or more messages 
			which are being sent or re-sent through the stream. The stream block also carries acknowledgements for 
			messages that have been received from the remote end of the stream. Additionally, the ZIG packet contains 
			a block of 'unreliable' data (also called 'Stream 0') whose delivery and ordering with other stream messages 
			or unreliable blocks are not guaranteed by ZIG. The \c udata parameter is the unreliable data block to be 
			included on the outgoing packet.

			OMITTED STREAM BLOCKS: A given stream's block may be ommited from an outgoing packet if there are no messages 
			in this stream's queue to send, or if it is not time to re-send messages yet. This is controlled mostly by 
			a streams' policy (see zigclient_c and policy_c), by set_max_outgoing_packet_sizes() and by the global rate 
			at which ZIG packets are sent from the ZIG server to each ZIG client, which is configured by both 
			zigserver_c::set_server_tick() and zigserver_c::set_net_ratio().
			
			If you call send_packet() frequently enough, then most packets will be generated without any stream blocks. 
			Together with the "mostly fixed" packet generation rates, this is how the ZIG protocol implements its rather 
			crude but somewhat workable flow control. NOTE: this works together with the 'input' API. So, if an 'input' 
			(automatic) packet is sent and then you call send_packet() right after it, the latter call will probably 
			place less ZIG protocol overhead (stream blocks) on the outgoing UDP packet.

			The ZIG UDP packet sent by this method is received by the server at zigserver_c::client_incoming_data(). 
			<B>IMPORTANT!</B>: Please note that, at the server side, the method zigserver_c::client_incoming_data() will 
			also receive the 'input packets' that are generated automatically by the zigclient_c implementation. So, 
			if you are calling send_packet() explicitly from your game code, please be aware that, at your game server code, 
			you must be able to differentiate between incoming 'input packets' and the packets you sent through send_packet() 
			calls (if this is at all important for your particular game protocol). See the documentation for zigclient_c 
			'input packets' for a more through discussion of this.

			\param udata The unreliable data block ('Stream 0' block), with no guarantees of delivery nor ordering;
      \param packet_id An optional pointer to an int variable which receives the ZIG packet ID that is assigned to 
			the packet.

			\return Whether the packet was sent successfully or not.
			- \c true Packet sent OK (no errors detected);
			- \c false Packet not sent (ZIG client is not started or error sending packet -- socket error, ...)

			\see zigclient_c for a discussion about the 'input packets' feature and its caveats
			\see before_packet_send()
	*/
	bool send_packet(buffer_c &udata, int *packet_id = 0);

	/*! \brief Sends a message through one of this connection's streams.
			
			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			The \c stream_id parameter must be a valid Stream ID returned by a call to create_stream(). Using hard-coded 
			values for the Stream ID is not recommended.

			<B>IMPORTANT:</B> There is a limit of 32767 bytes maximum for the size of messages. If the \c message parameter 
			is longer than 32767 bytes, then send_message() returns \c false and the message is not sent.

			\param message The message (block of bytes) to send through the stream;
			\param stream_id The ID of the stream through which the message is to be sent;
			\param reliable Informs whether you want reliable delivery of the message or not:
			- \c true Is the default value and regular behavior, which means that ZIG should re-send the message until it 
			is acknowledged;
			- \c false Means that ZIG should try to deliver the message just once (on the next outgoing packet) and should
			not wait for any acknowledgements of the message. Using this value parameter allows for messages with guaranteed 
			ordering (since it is being sent through a stream) but not guaranteed delivery, resulting in a 'sequencing' kind 
			of channel.

			\return If the message has been successfully queued for delivery through this stream:
			- \c true Message will be sent on the next outgoing packet(s);
			- \c false Message will not be sent on the next outgoing packet(s), because the Stream ID is invalid or the 
			message is larger than 32767 bytes.
	*/ 
	bool send_message(buffer_c &message, int stream_id = -1, bool reliable = true) {
		if (client) return (client->send_message(message, stream_id, reliable) != 0);
		else return false;
	}

	/*! \brief Returns the next message received through a given stream.

			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			The \c stream_id parameter must be a valid Stream ID returned by a call to create_stream(). Using hard-coded 
			values for the Stream ID is not recommended. If the \c stream_id parameter is not specified, then the default 
			stream is assumed, which is set by a call to set_default_stream_id().

			\param stream_id The ID of the stream to be read, or -1 to use the default stream.

			\return Either:
			- A buffer_c containing a nonzero value in its \c code member variable, which means that the next message 
			that was received through the given stream is being returned as the contents of the returned buffer_c;
			- A buffer_c containing the zero (0) value in its \c code member variable, which means that there were no 
			more messages to be read through the given stream, and so the contents of the returned buffer_c are garbage.

			<B>EXAMPLE</B> - Process all messages from the default stream:

      <pre>
			buffer_c mes;
			do {
			   mes = receive_message(); // Receive next message of the default stream
			   if (mes.code) {          // Message received! Parse contents of 'mes' here...
			   }
			} while (mes.code);
			</pre>      

			\see receive_message(buffer_c&,int)
	*/
	buffer_c receive_message(int stream_id = -1) {
		if (client) return client->receive_message(stream_id);
		else {
			buffer_c b;
			b.code = -1;
			return b;
		}
	}

	/*! \brief Returns the next message received through a given stream.

			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			The \c stream_id parameter must be a valid Stream ID returned by a call to create_stream(). Using hard-coded 
			values for the Stream ID is not recommended. If the \c stream_id parameter is not specified, then the default 
			stream is assumed, which is set by a call to set_default_stream_id().

			\param stream_id The ID of the stream to be read, or -1 to use the default stream;
			\param msgbuf Buffer supplied by the caller that should receive the contents of the message being read.

			\return An int code which reports what happened:
			- \c 1 means that the next message that was received through the given stream is being returned through \c msgbuf;
			- \c 0 means that there were no more messages to be read through the given stream, and so the contents of \c msgbuf 
			are garbage;
			- \c -1 means that an error occurred (the ZIG client isn't started/connected, or something equally bad).

			\see receive_message(int)
	*/
	int receive_message(buffer_c &msgbuf, int stream_id = -1) {
		if (client) return client->receive_message(msgbuf, stream_id);
		else return -1;
	}

	/*! \brief Creates a new stream endpoint for the current connection.
			
			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			<B>IMPORTANT:</B> Both zigclient_c::create_stream() (client-side) and zigserver_c::create_stream() 
			(server-side) create a stream END-POINT. Suppose that you create a stream endpoint on the client-side 
			and that you don't create a stream endpoint on the server-side. In that case, the server won't be able to 
			receive messages sent through the client stream endpoint. So, you must call create_stream() twice,
			once on the client, and once on the server, to actually create a working stream.
			
			The create_stream() methods (client and server) return an int value which is the ID of the stream 
			endpoint that was just created. Once a ZIG connection is estabilished, the stream endpoint ID 
			generator of both client and server is set to 1 (one), and every subsequent call to create_stream() 
			on the same side of the connection will return the current ID generator's value and increase the ID 
			generator. 

			<B>This means that create_stream() calls will always return the same sequence of values: 1, 2, 3 ... etc. 
			after a connection is estabilished.</B> Thus, it would be wise to perform stream endpoint creation on the 
			'connected' callbacks of both zigclient_c and zigserver_c. <B>It is imperative that both ends of the 
			connection create the same amount of streams, and that the streams are created with a matching \c type 
			parameter</B>.

			\param type The type of the stream. See zig_stream_types_t for an explanation of each type;
			\param policy The stream's 'policy' for sending/re-sending messages (affects performance). See policy_c for 
			an explanation of each parameter.

			\return The ID of the created stream end-point. The remote host must create a stream endpoint with the same ID 
			and type in order to receive messages sent through this stream endpoint.

			<B>EXAMPLE</B> - Creating streams at client and server:

  	  <pre>
  	  GameClient::connected(buffer_c &buf) { // at the game client class (extends zigclient_c)
  	    &nbsp;// using three streams per client-server connection - create the CLIENT endpoints of those:
  	     game_stream = create_stream(STREAM_CUMULATIVE_ACK); // for game updates (stream 1)
  	     chat_stream = create_stream(STREAM_INDIVIDUAL_ACK); // for chatting (stream 2)
  	     file_stream = create_stream(STREAM_INDIVIDUAL_ACK); // for file transfer (stream 3)
  	     ...
  	  }
	
  	  GameServer::client_connected(int client_id, buffer_c &buf) { // at the game server class (extends zigserver_c)
  	    &nbsp;// using three streams per client-server connection - create the SERVER endpoints of those:
  	     player[client_id].game_stream = create_stream(client_id, STREAM_CUMULATIVE_ACK); // for game updates (stream 1)
  	     player[client_id].chat_stream = create_stream(client_id, STREAM_INDIVIDUAL_ACK); // for chatting (stream 2)
  	     player[client_id].file_stream = create_stream(client_id, STREAM_INDIVIDUAL_ACK); // for file transfer (stream 3)
  	     ...
  	  }
			</pre>
	*/
	int create_stream(int type = STREAM_CUMULATIVE_ACK, policy_c policy = DefaultPolicy);

	/*! \brief Deletes a stream endpoint from the current connection.

			You will probably never need to use this method. If you want to get rid of streams (I can't think why), you should 
			close the current ZIG client-server connection and open a new one.

			\param stream_id The ID of the stream endpoint you want to delete.

			\returns Returns \c true if the stream was found and deleted successfully, \c false otherwise.
	*/
	bool delete_stream(int stream_id);

	/*! \brief Sets the default stream ID.

			This method makes it easier to perform multiple operations over the same stream ID without needing to pass 
			the actual stream ID as arguments to the method calls.

			\param stream_id The new default stream ID.

			<B>EXAMPLE</B> - Using the default stream with send_message():

			<pre>
      int chat_stream = create_stream(); // stream for chatting
      int game_stream = create_stream(); // stream for game object update messages
      <b>set_default_stream_id( game_stream ); // default is the game object stream</b>
      buffer_c msg;
      msg.putString("<startgame>"); // creates some game message
      <b>send_message(msg); // send the message through the current default stream (game_stream)</b>
      msg.clear(); 
      msg.putString("Game has started! Good luck!!\n"); // a chat message
      send_message(msg, chat_stream); // NOT through default stream - must specify
			</pre>
	*/
	void set_default_stream_id(int stream_id);

	/*! \brief Gets the current value of the default stream ID.

			Returns the last value passed as parameter to set_default_stream_id(). See the documentation of 
			set_default_stream_id() for more details.

			\return The current 'default stream ID'.
	*/
	int get_default_stream_id();

	/*! \brief Seeks the first stream so that the next call to get_next_stream() will return the ID of the first stream.

			This call starts a new iteration through the streams of the current connection. To actually iterate over the 
			streams (and to get the first element) you must call get_next_stream().
	*/
	void seek_first_stream();

	/*! \brief Gets the ID of the next stream in the current stream iteration.

			After calling seek_first_stream() to start a new iteration, each subsequent call to this method will return 
			the ID of one of the existing streams. When all valid stream IDs are returned (all positive values), this 
			method returns -1 until a new iteration is started.

			If this method is called without any preceding calls to seek_first_stream(), the behavior is undefined.

			\return A valid int stream ID (positive value) or -1 (negative value) if there are no more streams.
	*/
	int get_next_stream();

protected: // ZIG 2.0: keep console protected:

	/*! \brief Console that the client application can use to log text and to get textual input from the user. */
	console_c *con;

private: // ZIG 2.0: leet_ and serverinfo_ interfaces shouldn't be documented and never need to be reached by the app 

	// ----------------------------------------------------------------------------------------
	//    below from this point are a lot of implementation details you shouldn't care
	//    about. do not call or override any of the following members...:
	// ----------------------------------------------------------------------------------------

	//client has connected sucessfully, custom accept packet data passed 
	virtual void leet_connected(buffer_c &hello);

	//connection attempt timed out
	virtual void leet_connection_timed_out();

	//connection refused, custom reason data passed
	virtual void leet_connection_refused(buffer_c &reason);

	//client has been disconnected -- reason given
	virtual void leet_disconnected(bool server_initiated, buffer_c &reason, int code_reason, int internal_reason);

	//incoming data from server! this refreshes the zigclient's last_server_packet_time var which 
	//is used to detect that the server timed out. 
	virtual void leet_incoming_data(buffer_c &in, int packet_id);

	// serverinfo_c: single-server query result
	virtual void serverinfo_result(address_c &addr, buffer_c &info, int time_ms);

	// serverinfo_c: single-server query timeout (target server did not respond)
	virtual void serverinfo_timeout(address_c &addr, int time_ms);

	// serverinfo_c: LAN query result
	virtual void serverinfo_local_result(address_c &addr, buffer_c &info, int time_ms);

	// serverinfo_c: LAN query timeout (end of search)
	virtual void serverinfo_local_timeout(int time_ms);

private: // ZIG 2.0: moved from protected -- take out of docs and out of sight of the user

	//start the client.
	bool start_impl();

	//shut down the client. this function takes some time, as it involves sending messages and
	//waiting responses.
	bool shutdown();

	//common constructor code (helper)
	void common_inits();

	//code shared with the "sender thread" for blocking run() and "process_nonblocking()" for run_non_blocking()
	void check_send_input_packet();

	// running with run_non_blocking()
	bool running_nonblocking;

	//outgoing player key input (and maybe other stuff) buffer
	buffer_c keyout;
	bool keyout_changed;			//player key input changed?
	
	//fps, drawing frequency control
	//int max_fps;
	//double min_render_interval;
	//double fps;	//fps for display

	//shutdown timeout
	int shutdown_timeout;

	//must quit the loop in run()?
	bool stop_called;

	//packet sender thread - this is independent from the input/render thread
	bool sender_thread_quit;

	//sender thread's (or nonblocking process_nonblocking() sender code's) get_time() of last time a 
	// packet was sent. by zero'ing this, we accelerate the sender thread.
	double last_packet_send;

	//sender thread's (or nonblocking process_nonblocking() sender code's) buffer for writing the 
	// outgoing input data
	buffer_c outgoing;

	//gameserver's custom connection data
	buffer_c gameserver_customdata;

	//zigserver's (and zigclient's) NET tick
	double net_tick;

	//zigserver's UPDATE tick (may be useful)
	double sim_tick;

	//server timeout - time in seconds that the client tolerates without receiving packets
	//from the server.
	int	cfg_server_timeout;
	int	cfg_connect_timeout; // connect-to-server timeout

	//time of last packet received from the server
	double last_server_packet_time;

	//to attend server's ping requests
	double server_ping_arrive_time;		//time the server ping arrived
	NLushort server_ping_id;					//packet id of the server's ping request, if 0, no request pending.
	int implicit_ping_modulus; //to identify incoming implicit ping requests

	//configured set_compression value, -999 = magic tag "leave at default"
	int compression_config;

	//flag to signal shutdown() code that it is being called inside the ~zigclient_c destructor
	//important because signals to shutdown() that it cannot call back the application ("game client")
	//to notifiy about a disconnection, for instance
	bool running_this_destructor;

	//client's local port range configuration
	bool use_port_range;
	int minport;
	int maxport;

	//NEW v1.5.0: saves the last/greatest packet_id reported in an incoming_data() callback 
	// in order to be able to report late packets. a negative value means "no packet received/reported yet"
	int greatest_incoming_packet_id;

	//ZIGLITE 1.1: max outgoing packet size configs
	int cfg_max_packet_size;

private:

	//modify the client's net tick.
	void set_net_tick(double tick);

	//internal leetnet client
	client_c *client;

	//internal serverinfo_c: server-info service provider object
	serverinfo_c serverinfo;
};

#endif

