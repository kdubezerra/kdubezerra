/*
		ZIG game-oriented networking engine
		Project Home: http://zige.sourceforge.net

		Copyright (c) 2002-2005, Fábio Reis Cecin.
		All rights reserved.
    
		This free software is licensed under a BSD-style license. Read the 
		LICENSE.TXT file for the full license.
*/
/*

	zigclient

	ZIG Game Engine Skeleton 
	client class

*/

#include "zig/zigdefs.h"
#include "zig/zigclient.h"
#include "zig/utils.h"
#include <stdio.h> // FILE*
#include <errno.h> // errno

//debugging
//#define ZIGCLIENT_NO_TIMEOUT

//common constructor code (helper)
void zigclient_c::common_inits() {
	running_this_destructor = false;
	running_nonblocking = false;
	client = 0;
	server_ping_id = 0;
	compression_config = -999;		//magic value "LEAVE AT DEFAULT"
//	set_shutdown_timeout();
//	set_max_fps();
	set_server_timeout();		//forgot this, caused a fatal bug, fixed in 4/4/2003
	set_connect_timeout();

	//v1.5.0: not really critical but neat to initialize
	keyout_changed = false;

	//v2.0: client's default port range configuration
	//Port range is enabled by default, and the default interval to
	//scan avaliable ports is set to [1025, 5000]
	use_port_range = true;
	minport = 1025;
	maxport = 5000;
	set_local_port_range(minport, maxport);
	
	//v1.5.0: no packets received yet for "late" detection
	greatest_incoming_packet_id = -1;

	//ZIGLITE v1.1
	cfg_max_packet_size = ZIG_DEFAULT_MAX_OUTGOING_PACKET_SIZE;
}

//ctor
zigclient_c::zigclient_c(console_c *conio) {
	running_this_destructor = false;  //paranoia
	con = conio;
	common_inits();
}

//dtor
zigclient_c::~zigclient_c() {

	// don't call any of our pure virtual methods.. the subclasses are already gone!
	running_this_destructor = true;

	con->xprintf(0, "zigclient_c::~zigclient_c 1\n");
	//stop
	shutdown();
	con->xprintf(0, "zigclient_c::~zigclient_c 2\n");
}

//ctor: no console; if you want to set a console later, call set_console(). messages generated by 
//this zigclient between the object construction and the call to set_console() will be sent to 
//the default global console (console_c::con)
//console_c console_c::defcon;
zigclient_c::zigclient_c() { 
	running_this_destructor = false; // paranoia
	con = &(console_c::get_default_console());
	common_inits();
}

//set the console (works with the no-args ctor)
void zigclient_c::set_console(console_c *conio) { 
	con = conio;
}

//starts the client in non-blocking mode. the caller thread returns immediatelly. the caller 
//thread may call stop() at a later time to terminate the client. returns false if there was an 
//error. 
//WHAT YOU MUST DO AFTER CALLING THIS METHOD: you must periodically call the process_nonblocking()
//method, or the client won't fully work. typically, you will do this inside your own "main loop".
//IMPORTANT: both the render_frame() and poll_input() methods WILL NOT BE CALLED! when running 
//non-blocking, it is YOUR responsibility to deal with the timing of polling input and rendering 
//to the screen (controlling frames-per-second).
//bool zigclient_c::run_nonblocking() {
bool zigclient_c::start() { // ZIG 2.0: new name

	//try to start
	if (!start_impl())
		return false;

	// NEW: non blocking code without sender thread -- must init old sender thread stuff here
	last_packet_send = get_time();			// so the check for next time to send a packet will eventually trigger.....

	// v1.5.0: configure NON-THREADED serverinfo helper object
	serverinfo.init(this, con);

	// from here, will run the client with process_nonblocking()

	// everything OK: running in non-blocking mode
	return (running_nonblocking = true);
}

//stops the client. call this function if you called run_non_blocking(). this method 
//makes sure that the client shuts down.
bool zigclient_c::stop() {

	// check if has a successful run_non_blocking() call pending to be stopped... if not, return false;
	if (!running_nonblocking) {
		con->xprintf(2,"zigclient_c::stop() : returning FALSE because of !running_nonblocking\n");
		return false;
	}

	//if STOP was to be called twice, the thread join below would join to an unexisting thread...
	if (stop_called) 		//stop allready called!
		return true;

	//prevent stop() being called again without a new run_non_blocking
	stop_called = true;

	// RUNNING NONBLOCKING: call shutdown which could, theoretically have already been called by 
	// process_nonblocking() (if process_nonblocking() wasn't a nop)
	// we return FALSE here if shutdown returns FALSE on us also (so the app may know if it's call 
	// to stop() was useful or process_nonblocking() had already shutdown() things.
	bool return_code = shutdown();

	//not running nonblocking anymore
	running_nonblocking = false;

	//ok
	return return_code;  // new: if running nonblocking, might return false here
}

//set connection custom data. this will be passed "as is" to the gameserver. this will show up as the 
//parameter named "custom" in a zigserver_c::accept_client() call on the server.
void zigclient_c::set_connect_data(buffer_c &data) { 

	//con->printf("ZIGCLIENT_C SET CONNECT DATA SETTING TO SIZE = %i\n", data.size() );

	gameserver_customdata = data;

	//con->printf("ZIGCLIENT_C SET CONNECT DATA SETTED TO SIZE = %i\n", gameserver_customdata.size() );
}

///start connection to the server address given by "server_addr" (string parameter)
bool zigclient_c::connect(string server_addr) {

	address_c addr(server_addr);
	return connect(addr);
}

///start connection to the server address given by "server_addr" (address_c& parameter). 
bool zigclient_c::connect(address_c& server_addr) {

	//don't connect twice
	if ( client->is_connected() ) return false;

	//return FALSE if address is invalid
	if (server_addr.valid() == false) return false;

	//-- init stuff when connecting ---

	//avoid timing out in the next few seconds (paranoia)
	last_server_packet_time = get_time() + 3.0;

	//to attend server's ping requests
	server_ping_id = 0;					//packet id of the server's ping request, if 0, no request pending.

	//set customdata
	buffer_c connectdata;
	
	//1st : ZIG connect data
	connectdata.putByte( (NLubyte) ZIG_NET_VERSION );	//ZIGNET version

	//2nd : game connect data = gameserver_customdata
	connectdata.putBlock( gameserver_customdata.data(), gameserver_customdata.size() );
	con->xprintf(2, "ZIGCLIENT CONNECT SETTING CUSTOMDATA SIZE = %i\n", gameserver_customdata.size() );

	//set customdata, server address & start connecting
	client->set_connect_data(connectdata);

	client->set_server_address( (char *)server_addr.get_address().c_str() );   // FIXME: update set_server_address to work with address_c

	client->connect();
	return true;
}

//disconnect if connected
void zigclient_c::disconnect(int code_reason) {

	// if start() (old run_nonblocking()) isn't in effect, then it is not possible that we have a connection 
	// (or a client_c ptr for that matter).
	if (running_nonblocking) {

		// just do it here
		assert(client);
		buffer_c reason;
		reason.putLongs(code_reason);
		client->disconnect(reason);
	}
}

// send a packet to the server with zig unreliable block + app unreliable block + acks + 
// app reliable messages. skips acks and reliables if calling too frequently.
//
// BUG FIXED IN ZIG v1.2.4: this used to just forward the call to the lower layer, which
// caused a bug since the zigserver expected some special "zig protocol" bytes (which were
// only being sent by input_changed() & friends)

bool zigclient_c::send_packet(buffer_c &udata, int *packet_id) {

	con->xprintf(0, "zigclient_c::send_packet\n");

	// if no client, then no lower layer to send call to
	if (client) {

		// FIXED for ZIG v1.2.4:
		//build new outgoing "udata" with the zig unreliable block in it
		buffer_c outgoing;

		// ---- add zig protocol to "outgoing":
		// P1NG BEGIN /*
		// copy to have same view through the code block below
		int my_server_ping_id = server_ping_id;

		// 1st byte is a special byte:
		//    if bit0 == 1, then follows a ping response from zigclient to zigserver
		NLubyte zigbyte = 0;
		if (my_server_ping_id > 0) zigbyte += 1;
		outgoing.putByte(zigbyte);

		//put zigclient stuff:
		//1) "pong" response
		if (my_server_ping_id > 0) {  //if (server_ping_id > 0) 

			//the time that the client took to answer the ping request
			NLushort delta_ms = (NLushort)((get_time() - server_ping_arrive_time) * 1000.0);

			//con->printf("ZIGCLIENT: encoding ping %hi response delta %hi\n", server_ping_id, delta_ms);
								
			outgoing.putShort( my_server_ping_id ); // ping request id (so the server knows when it started)
			outgoing.putShort( delta_ms ); // time the client took to answer

			//debug
			//con->printf("  >>> CLIENT ANSWER PING, ID = %i   (%i)\n", packet_id, my_server_ping_id);

			server_ping_id = 0; //we don't support "queuing" of ping requests
		}
    // P1NG END */
		// ---- concat (zig unrelible + app unreliable) and send it through "leetnet" layer

		// append udata to outgoing
		outgoing.putBlock( udata.data(), udata.size() );
		
		// forward call to lower layer with the added "zig unrelible" protocol overhead
		return (client->send_frame(outgoing, packet_id) != 0);
	}

	return false;
}

// NEW (ziglite 1.2): creates a stream and returns its identifier (calls client_c method)
int  zigclient_c::create_stream(int type, policy_c policy) {
	if (client) return client->create_stream(type, policy);
	else return -1;
}

// NEW (ziglite 1.2): deletes a stream (calls client_c method)
// returns true if success, false otherwise 
bool zigclient_c::delete_stream(int id) {
	if (client) return client->delete_stream(id);
	else return false;
}

// call get/set default stream id methods from station
void zigclient_c::set_default_stream_id(int stream_id) {
	if (client) client->set_default_stream_id( stream_id );
}

int  zigclient_c::get_default_stream_id() {
	if (client) return client->get_default_stream_id();
	else return -1;
}

void zigclient_c::seek_first_stream() {
	if (client) client->seek_first_stream();
}

int zigclient_c::get_next_stream() {
	if (client) return client->get_next_stream();
	else return -1;
}

//PROTECTED start up the client
bool zigclient_c::start_impl() {

	if (client) return false;

	// create the leetnet client
	client = new client_c( this , con );

	//ZIGLITE 1.1:
	client->set_max_outgoing_packet_size(cfg_max_packet_size);

	// v1.5.0: use client's local port range for the UDP socket
	if (use_port_range) {
		client->set_local_port_range(minport, maxport);
	}

	if (compression_config != -999) // magic flag means "LEAVE AT DEFAULT"
		client->set_compression( compression_config );

	// set client's default net tick rate
	set_net_tick( ZIGCLIENT_DEFAULT_TICK );

	//v1.3.4: forward config value for connect-to-server timeout
	client->set_connect_timeout(cfg_connect_timeout);

	bool result = init(); // init app

	if (result == false) {

		//failed to initialize app..
		SAFEDELETE(client);
		con->xprintf(2,"zigclient_c::start_impl(): app failed to init()ialize!\n");
		return false;
	}

	// not called yet!
	stop_called = false;

	return true;
}

//PROTECTED shut down the client. this function takes some time, as it involves sending messages and
//waiting responses.
bool zigclient_c::shutdown() {

	con->xprintf(0, "zigclient_c::shutdown\n");
	if (client == NULL) return false;

	//close the leetnet client
	client->disconnect();

	//app finish
	finish();

	//delete/finish
	SAFEDELETE(client);

	return true;
}

//modify the client's net tick.
void zigclient_c::set_net_tick(double tick) {

	//modify net tick value for client
	net_tick = tick;

	// set min rel interval (optimization)
	client->set_min_send_reliables_interval( net_tick );		//default value

	//recalculate the magic modulus number for implicit ping requests (this must be done on
	//the server also)
	// FIXED BUG (v1.2.4): the client was using the NET TICK of the server to calculate the
	// modulus, but the server was using it's SIMULATION TICK!
	// FIXED v1.3.3: type cast truncates but rounding needed
	//  implicit_ping_modulus = (int)( ZIGNET_IMPLICIT_PING_MS / (net_tick * 1000.0) );	
	implicit_ping_modulus = droundi( ZIGNET_IMPLICIT_PING_MS / (net_tick * 1000.0) );	
	
//	con->printf("client's implicit ping modulus = %i\n", implicit_ping_modulus);

	con->xprintf(2,"ZIGCLIENT timer tick is = %f\n", net_tick);
}

//code shared with the "sender thread" for blocking run() and "process_nonblocking()" for run_non_blocking()
// MAY send input packet if it's time
void zigclient_c::check_send_input_packet() {

	//if keys have changed since the last check, then reduce the wait time
	if (keyout_changed) {
					
		keyout_changed = false;
		last_packet_send -= (net_tick / 2.0);		//cut wait time
	}

	//current time
	double now = get_time();
			
	//send packet if 100ms (server frame time) passed
	if ( (now - last_packet_send) >= net_tick)
    send_input_packet();
}

//do actually send an input packet
void zigclient_c::send_input_packet() {

	//NEW: notify gameclient - a chance to change the keyout data before sending
	before_packet_send();

	//NEW (v1.2.6): since we can send_input_packet() without check_send_input_packet(), 
	// we must set the keyout_changed flag to false when sending, so on the next
	// "sender thread" loop (for ZIG "blocking" mode) it won't cut the wait time in
	// half (thinking that the keys have changed since the last send/check)
	keyout_changed = false;

	// send the outgoing packet:
	if (!send_packet(keyout))
		con->xprintf(2,"ZIGCLIENT ERROR: can't send_packet!\n");

	//REVIEW: there's no point on accelerating the next send if this send was late 
	// (with last_packet_send += net_tick)... or is there? (keeping packet rate exact
	// to "ack" server messages... but exact timing precision for zig's net acks is 
	// useless, no?)
	last_packet_send = get_time();
}

//client has connected sucessfully, custom accept packet data passed
void zigclient_c::leet_connected(buffer_c &hello) {

	//avoid timing out in the next few seconds
	last_server_packet_time = get_time() + 3.0;

	try {

		con->xprintf(0, "hello.size_left = %i\n", hello.size_left());
		//hello.print(con);

		//take zignet version byte
		NLubyte znver = hello.getByte();
		con->xprintf(2,"ZIGSERVER ZIGNET VERSION = %i\n", znver);

		//take server's net tick
		NLushort zntick_net = hello.getShort();
		con->xprintf(2,"ZIGSERVER NET TICK (ms) = %i\n", zntick_net);

		//take server's update tick
		NLushort zntick_update = hello.getShort();
		con->xprintf(2,"ZIGSERVER UPDATE TICK (ms) = %i\n", zntick_update);

		//reconfigure zigclient net-tick to match server's...
		set_net_tick( ((double)zntick_net) / 1000.0 ); //net_tick in seconds

		//save update tick value 
		sim_tick = ( ((double)zntick_update) / 1000.0 );

		//callback gameclient with remainder of hello packet
		connected(hello);

	} catch (int ex) {

		con->xprintf(2,"EXCEPTION zigclient_c::leet_connected() : %i !!\n", ex);

		//this means the accept-connection packet was corrupted. let's drop
		//the connection.
		disconnect( ZIGCLIENT_DISCONNECTED_PROTOCOL_VIOLATION );
	}
}

//connection attempt timed out
void zigclient_c::leet_connection_timed_out() { 
	connection_timed_out(); 
}

//connection refused, custom reason data passed
void zigclient_c::leet_connection_refused(buffer_c &reason) {

	try {

		//get version
		NLubyte ver = reason.getByte();

		con->xprintf(2,"ZIGSERVER ZIGNET VERSION = %i\n", ver);

		//get reason
		NLubyte rcode = reason.getByte();

		if (rcode == ZIGNET_REJECT_VERSION) {

			con->xprintf(2,"ZIGNET connection rejected by version mismatch.\n");

			// passing the code of the failure so the gameclient knows what's going on
			// also passes the remainder of the reason packet (which of course contains
			// nothing else to be read -- after a ZIGNET_REJECT_VERSION, there is nothing else
			// according to the zignet protocol)
			buffer_c empty_dummy;  //that's why I'm passing an empty dummy buffer!

			connection_refused(empty_dummy /*reason*/, ZIGCLIENT_CONNECTFAILED_ZIGNET_VERSION_MISMATCH);
		}
		else if (rcode == ZIGNET_REJECT_GAMESERVER) {

			con->xprintf(2,"ZIGNET connection rejected because of gameserver (check rest of answer...)\n");

			connection_refused(reason, ZIGCLIENT_CONNECTFAILED /* this is always 0 */ );
		}
		else {

			con->xprintf(2,"WARNING zigclient_c::leet_connection_refused() : unknown reason = %hhi\n", rcode);
			
			//let connection time out on server, and simulate connection timeout to the gameclient:
			//leet_connection_timed_out();
						
			// REVIEW: send a disconnect packet or something to the server...

			//...and use a callback "connection error":
			buffer_c empty_dummy;

			connection_refused(empty_dummy, ZIGCLIENT_CONNECTFAILED_UNKNOWN);

			return;	
		}

	} catch (int ex) {

		con->xprintf(2,"EXCEPTION zigclient_c::leet_connection_refused() : %i\n", ex);

		//let's be sure that the gameserver gets notified of the failure!
		buffer_c empty_dummy;

		connection_refused(empty_dummy, ZIGCLIENT_CONNECTFAILED_UNKNOWN);
	}
}

//client has been disconnected -- reason given
void zigclient_c::leet_disconnected(bool server_initiated, buffer_c &reason, int code_reason, int internal_reason) {

	//call back game client
	if (running_this_destructor == false)	{	// NOT if gameclient is already destroyed!

		//NEW v1.3.0: translante internal_reason into zig_reason (ZIGCLIENT_DISCONNECTED_xxx)
		int zig_reason = ZIGCLIENT_DISCONNECTED;  // default catch-all

		if (internal_reason == LEETCLIENT_DISCONNECTED_PROTOCOL_VIOLATION)
			zig_reason = ZIGCLIENT_DISCONNECTED_PROTOCOL_VIOLATION;
		else if (internal_reason == LEETCLIENT_DISCONNECTED_SOCKET_ERROR)
			zig_reason = ZIGCLIENT_DISCONNECTED_SOCKET_ERROR;
		else if (internal_reason == SENDPACKET_SOCKET_ERROR)
			zig_reason = ZIGCLIENT_DISCONNECTED_SOCKET_ERROR;

		disconnected(server_initiated, reason, code_reason, zig_reason); 
	}
}

//incoming data from server! this refreshes the zigclient's last_server_packet_time var which
//is used to detect that the server timed out.
void zigclient_c::leet_incoming_data(buffer_c &in, int packet_id) {

	//push server timeout value to the future
	last_server_packet_time = get_time();

	//depending on the packet_id, this can be an implicit ping request from the server!
	//check the "magic modulus" rule:
	if ( (packet_id % implicit_ping_modulus) == 0 ) {

		//we're on!
		//con->printf("ZIGCLIENT: implicit ping request from server, pid=%i\n", packet_id);
		server_ping_id = packet_id;
		server_ping_arrive_time = get_time();

		//debug
		//con->printf("  >>> CLIENT RECEIVE PING PACKET, ID = %i   (%i)\n", packet_id, implicit_ping_modulus);
//con->xprintf(0, "zigclient: before call send_input_packet");
		//NEW (v1.2.6): at least when receiving a "ping" packet, try to answer NOW
		send_input_packet();
	}
//con->xprintf(0, "zigclient_c::leet_incomig_data: before call gameclient::incoming_data\n");	
	//tell zigclient's subclass (the game client...)
	incoming_data(in, packet_id); //, late); 
}

/// IMPORTANT: after calling run_non_blocking() to start running the client, you MUST call this 
/// method periodically (on your own code's "main loop" probably) or the client won't fully work. 
/// RETURN VALUE: 'false' if some failure occurs (client is not running/connected), 'true' otherwise.
bool zigclient_c::process_nonblocking() {

	//return if not running in nonblocking mode yet
	if (running_nonblocking == false)
		return false;

	//update lastrender, calc fps
	// REVIEW: since we're not calling render_frame(), we won't update the FPS tracker anymore..
	//fps = 0.0;

	//NEW (v1.5.0): poll our serverinfo_c object for pending server-info results/timeouts
	serverinfo.process_nonblocking();

	//NEW AND IMPORTANT (ZIG v1.2.1)
	// since ZIG 1.2.1, zigclient_c::process_nonblocking() will also be responsible for doing all the reading 
	// from the the client's UDP socket.
	// so, we must check with our client_c if there are any packets for reading. this call will cause
	// process_nonblocking() to call the "incoming data" etc. callbacks which are all triggered by socket
	// reading results.
	if (client) client->poll_socket();

	// NEW: run the "client packet sending" logic here, not on a separate "sender thread"!
	//check if has stuff to send. if yes, send it.
	//connected?
	if (is_connected()) {

		// code shared with the "sender thread"
		// MAY send input packet if it's time
		check_send_input_packet();

	//check for timeout - only if I am connected, of course!
#ifndef ZIGCLIENT_NO_TIMEOUT
		double now = get_time();
		if (now - last_server_packet_time > ((double)cfg_server_timeout)) {

			con->xprintf(2,"ZIGCLIENT.CPP: server TIMED OUT!\n");
			con->xprintf(2,"  now = %f\n", now);
			con->xprintf(2,"  last_server_packet_time = %f\n", last_server_packet_time);
			con->xprintf(2,"  now - last = %f\n", (now - last_server_packet_time) );
			con->xprintf(2,"  cfg_server_timeout = %f\n", (double)cfg_server_timeout);

			disconnect( ZIGCLIENT_DISCONNECTED_TIMEOUT ); // timed out - disconnect
		}
#endif
	}
	else
		return false;

	return true;
}


//--------------------------------------------------------------
//  v1.5.0 new serverinfo stuff:
//--------------------------------------------------------------

// legacy/compatability service methods: forward to serverinfo_c object
void zigclient_c::get_server_info(address_c &server_addr, int timeout_ms) {	
	serverinfo.get_server_info(server_addr, timeout_ms); 
}
void zigclient_c::get_server_info(address_c &server_addr, buffer_c &custom, int timeout_ms) {	
	serverinfo.get_server_info(server_addr, custom, timeout_ms); 
}
void zigclient_c::get_local_server_info(int timeout_ms, int broadcast_port) {	
	serverinfo.get_local_server_info(timeout_ms, broadcast_port); 
}
void zigclient_c::get_local_server_info(buffer_c &custom, int timeout_ms, int broadcast_port) { 
	serverinfo.get_local_server_info(custom, timeout_ms, broadcast_port); 
}

// serverinfo_listener_i impl. these just forward to the application. the actual 
// blocking/nonblocking deal (queue results or call directly) is dealt by the 
// serverinfo_c implementation.

// serverinfo_c: single-server query result
void zigclient_c::serverinfo_result(address_c &addr, buffer_c &info, int time_ms) {
			info.code = 0; // emulate old behavior
			this->incoming_server_info(addr, info, time_ms, false); // emulate old callback
}

// serverinfo_c: single-server query timeout (target server did not respond)
void zigclient_c::serverinfo_timeout(address_c &addr, int time_ms) {
			buffer_c info;
			info.code = 1; // emulate old behavior
			this->incoming_server_info(addr, info, time_ms, true); // emulate old callback
}

// serverinfo_c: LAN query result
void zigclient_c::serverinfo_local_result(address_c &addr, buffer_c &info, int time_ms) {
			info.code = 0; // emulate old behavior
			this->incoming_server_info(addr, info, time_ms, false); // emulate old callback
}

// serverinfo_c: LAN query timeout (end of search)
void zigclient_c::serverinfo_local_timeout(int time_ms) {
			address_c addr; // dummy addr (= LAN)
			buffer_c info;
			info.code = 1; // emulate old behavior
			this->incoming_server_info(addr, info, time_ms, true); // emulate old callback
}
