\documentclass[a4paper]{sbgames}               % final
%\usepackage[scaled=.92]{helvet}
\usepackage{times}

%% use this for zero \parindent and non-zero \parskip, intelligently.
\usepackage{parskip}

%% the 'caption' package provides a nicer-looking replacement
\usepackage[labelfont=bf,textfont=it]{caption}

\usepackage{url}
\usepackage{graphicx}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{algorithm}



\newcommand{\misccite}[2]{#1. Disponível em: \textless#2\textgreater. Acesso em: 26 jun. 2009}
\newcommand{\gamecite}[2]{\misccite{#1}{#2}}

%% Paper title.
\title{[FIXME] A fine granularity load balancing technique for MMOG servers using a kd-tree to partition the space}

%% Author and Affiliation (multiple authors). Use: and between authors

\author{Carlos Eduardo B. Bezerra, João L. D. Comba, Cláudio F. R. Geyer\\
				Instituto de Informática\\
				Universidade Federal do Rio Grande do Sul\\
				Av. Bento Gonçalves, 9500, Porto Alegre
}
\contactinfo{\{carlos.bezera, comba, geyer\}@inf.ufrgs.br
}
%% Keywords that describe your work.
\keywords{MMOGs, load balancing, distributed server, kd-trees.}

%% Start of the paper
% Attention: As you need to insert EPS images in Postscript, 
% you need to insert PDF images into PDFs. 
% In the text, extensions cancbe omitted (latex use .eps, pdflatex get .pdf) 
% To convert them: epstopdf myimage.eps
\begin{document}

%\teaser{
%  \includegraphics[width=\linewidth]{sample.pdf}
%  \caption{Optional image}
%}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

\maketitle

%% Abstract section.

\begin{abstract}
MMOGs (massively multiplayer online games) are applications that require high bandwidth connections to work properly. This demand for bandwidth is specially critical on the servers that host the game. This happens because the typical number of simultaneous participants in this kind of game varies from a few hundreds to several tens of thousands, and the server is the one responsible for mediating the interaction between every pair of players connected to it. To deal with this problem, decentralized architectures with multiple servers have been proposed, where each server manages a region of the virtual environment of the game. Each player, then, connects only to the server that manages the region where he is playing. However, to distribute the load among the servers, it is necessary to devise an algorithm for partitioning the virtual environment. In order to readjust the load distribution during the game, this algorithm must be dynamic. Some work has already been made in this direction, but using a geometric algorithm, more appropriate than those found in the literature, it should be possible to reduce the distribution granularity without compromising the rebalancing time, or even reducing it. In this work, we propose the use of a kd-tree for dividing the virtual environment of the game in regions, each of which being designated to one of the servers. The split coordinates of the regions are adjusted dynamically according to the distribution of avatars in the virtual environment. We compared our algorithm to some approaches found in the literature and the simulation results show that our algorithm performed better in most aspects we analysed.
\end{abstract}

%% The ``\keywordlist'' command prints out the keywords.
\keywordlist
\contactlist

\section{Introduction}

The main characteristic of MMOGs is the large number of players interacting simultaneously, reaching the number of tens of thousands \cite{schiele2007rpp}. When using a client-server architecture for the players to communicate with one another, the server intermediates the communication between each pair of players.

To allow the interaction of players, each one of them sends his commands to the server, which calculates the resulting game state and sends it to all the players to whom the state change is relevant. We can see that the number of state update messages sent by the server may grow proportionally to the square of the number of players, if all players are interacting with one another. Obviously, depending on the number of players, the cost of maintaining a centralized infrastructure like this is too high, restricting the MMOG market to large companies with enough resources to pay the upkeep of the server.

In order to reduce this cost, several decentralized solutions have been proposed. Some of them use peer-to-peer networks, such as \cite{schiele2007rpp,rieche2007ppb,hampel2006ppa,elrhalibi2005abm,iimura2004zfg,knutsson2004pps}. Others propose the use of a distributed server composed of low-cost nodes connected through the Internet, as in \cite{ng2002msa,chertov:olb,lee2003sdl,assiotis2006dam}. Anyway, in all these approaches, the ``world'', or virtual environment of the game is divided into regions and for each region is assigned a server -- or a group of peers to manage it, when using peer-to-peer networks. Each of these regions must have a content such that the load imposed on the corresponding server is not greater than its capacity.

When an \emph{avatar} (representation of the player in the virtual environment) is located in a region, the player controlling that avatar connects to the server associated to that region. That server, then, is responsible for receiving the input from that player and for sending, in response, the update messages. When a server becomes overloaded due to an excessive number of avatars in its region and, therefore, more players to be updated, the division of the virtual environment must be recalculated in order to alleviate the overloaded server.

Usually, the virtual environment is divided into relatively small cells, which are then grouped into regions and distributed among the servers. However, this approach has a severe limitation in its granularity, since the cells have fixed size and position. Using a more appropriate geometric algorithm, it should be possible to achieve a better player distribution among different servers, making use of traditional techniques that are generally used for computer graphics.

In this work, we propose the utilization of a kd-tree to perform the partitioning of the virtual environment. When a server is overloaded, it triggers the load balancing, readjusting the limits of its region by changing the split coordinates stored in the kd-tree. A prototype has been developed and used in simulations. The results found in these simulations have been compared to previous results from approaches which use the cell division technique.

The text is organized as follows: in section \ref{context}, some related works are described; in section \ref{sec:proposal}, the algorithm proposed here is presented in detail; in the sections \ref{sec:simul} and \ref{sec:result}, we present, respectively, the simulation details and its results and, in section \ref{sec:conc}, the conclusions of this work are presented.




\section{Related Work}
\label{context}

Different authors have attacked the problem of partitioning the virtual environment in MMOGs for distribution among multiple servers \cite{ahmed2008mol,bezerra2009lbs}. Generally, there is a static division into cells of fixed size and position. The cells are then grouped into regions (Figure \ref{fig:cells}), and each region is delegated to one of the servers. When one of them is overwhelmed, it seeks other servers, which can absorb part of the load. This is done by distributing one or more cells of the overloaded server to other servers.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.85\linewidth]{images/macromicro}
	\caption{Division into cells and grouping into regions}
	\label{fig:cells}
\end{figure}

\cite{ahmed2008mol}, for example, propose a cell-oriented load balancing model. To balance the load, their algorithm finds, first, all clusters of cells that are managed by the overloaded server. The smallest cluster is selected and, from this cluster, it is chosen the cell which has the least interaction with other cells of the same server -- the interaction between two cells A and B is defined by the authors as the number of pairs of avatars interacting with each other, one of them in A and the other one in B. The selected cell is then transferred to the least loaded server, considering ``load'' as the bandwidth used to send send state updates to the players whose avatars are positioned in the cells managed by that server. This process is repeated until the server is no longer overloaded or there is no more servers capable of absorbing more load -- in this case, one option could be to reduce the frequency at which state update messages are sent to the players, as suggested by \cite{bezerra2008a3}.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.5\linewidth]{images/grafo}
	\caption{Graph representation of the virtual environment}
	\label{fig:graph}
\end{figure}

In \cite{bezerra2009lbs}, it is also proposed the division into cells. To perform the division, the environment is represented by a graph (Figure \ref{fig:graph}), where each vertex represents a cell. Each edge in the graph connects two vertices representing neighboring cells. The weight of a vertex is the server's bandwidth occupied to send state updates to the players whose avatars are in the cell represented by that vertex. The interaction between any two cells define the weight of the edge connecting the corresponding vertices. To form the regions, the graph is partitioned using a greedy algorithm: starting from the heaviest vertex, at each step it is added the vertex connected by the heaviest edge to any of the vertices already selected, until the total weight of the partition of the graph -- defined as the sum of the vertices' weights -- reaches a certain threshold related to the total capacity of the server that will receive the region represented by that partition of the graph.

Although this approach works, there is a serious limitation on the distribution granularity it can achieve. If a finer granularity is desired, it is necessary to use very small cells, increasing the number of vertices in the graph that represents the virtual environment and, consequently, the time required to perform the balancing. Besides, the control message containing the of cells designated to each server also become larger. Thus, it may be better to use another approach to perform the partitioning of the virtual environment, possiby using a data structure more suitable, such as a kd-tree \cite{bentley1975mbs}.

This kind of data structure is generally used in computer graphics. However, as in MMOGs there is geometric information -- such as the position of each avatar in the environment --, space partitioning trees could be used. Moreover, we cand find in the literature techniques for keeping the partitions defined by the tree with a similar ``load''. In \cite{luque2005bpc}, for example, it is sought to reduce the time needed to calculate the collisions between pairs of objects moving through space. The authors propose the use of a BSP (binary space partitioning) tree to distribute the objects in the scene (Figure \ref{fig:bsp}). Obviously, if each object of one pair is completely inserted in a different partition, they do not collide and there is no need to perform a more complex test for this pair. Assuming an initial division, it is proposed by the authors a dynamic readjustment of the tree as objects move, balancing their distribution on the leaf-nodes of the tree and, therefore, minimizing the time required to perform the collision detection. Some of the ideas proposed by the authors may be used in the context of load balancing between servers in MMOGs.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.5\linewidth]{images/bsp}
	\caption{Space partitioning using a BSP tree}
	\label{fig:bsp}
\end{figure}

\section{FIXME:changetitle Proposed approach}
\label{sec:proposal}

The load balancing approach proposed here is based on two criteria: first, the system should be considere heterogeneous (i.e. each server has a different amount of resources) and, second, the load on each server is \emph{not} proportional to the number of players connected to it, but to the amount of bandwidth required to send state update messages to them.

This choice is due to the fact that each player sends commands to the server at a constant rate, so the number of messages received by the server per unit time grows linearly to the number of players, whereas the number of state update messages sent by the server may be quadratic, in the worst case.

As mentioned in the introduction, to divide the environment of the game into regions, we propose the utilization of a data structure known as kd-tree. The vast majority of MMOGs, such as World of Warcraft \cite{worldofwarcraft}, Ragnarok \cite{ragnarok} and \mbox{Lineage II} \cite{lineage2}, despite having three-dimensional graphics, the simulated world -- cities, forests, swamps and points of interest in general -- in these games is mapped in two dimensions. Therefore, we propose to use a kd-tree with \mbox{k = 2}.

Each node of the tree represents a region of the space and, moreover, in this node it is stored a split coordinate. Each one of the two children of that node represent a subdivision of the region represented by the parent node, and one of them represents the sub-region before the split coordinate and the other one, the sub-region containing points whose coordinates are greter than or equal to the split coordinate. The split axis (in the case of two dimensions, the axis $x$ and $y$) of the coordinate stored alternates for each level of the tree -- if the first level node store x-coordinates, the second level nodes store an y-coordinates and so on. Each leaf node also represents a region of the space, but it does not store any split coordinate. Instead, it stores a list of the avatars present in that region. Finally, each leaf node is associated to a server of the game. When a server is overloaded, it triggers the load balancing, which uses the kd-tree to readjust the split coordinates that define its region, reducing the amount of content managed by it.

Each node of the tree also stores two other values: capacity and load of the subtree. The load of a node is equal to the sum of the load of its children. Similarly, the capacity of a non-leaf node is equal to the sum of the capacity of its children nodes. For the leaf node, these values are the same as the server associated to each one of them. The tree root stores, therefore, the total weight of the game and the total capacity of the server system.

In the following sections, it will be described the construction of the tree, the calculation of the load associated with each server and the proposed balancing algorithm.

\subsection{Building the kd-tree}

To make an initial space division, it is constructed a balanced kd-tree. For this, we use the recursive function shown in Algorithm \ref{alg:buildtree} to create the tree.

\begin{algorithm}
\caption{node::build\_tree(id, level, num\_servers)}
\label{alg:buildtree}
\begin{algorithmic}
	\IF{id + $2^{level} \ge num\_servers$ }
		\STATE $left\_child \leftarrow right\_child \leftarrow NIL$;
		\STATE return;
	\ELSE
		\STATE $left\_child \leftarrow$ new\_node();
		\STATE $left\_child.parent \leftarrow$ \textbf{this};
		\STATE $right\_child \leftarrow$ new\_node();
		\STATE $right\_child.parent \leftarrow$ \textbf{this};
		\STATE $left\_child$.build\_tree$(id, level + 1, num\_servers)$;
		\STATE $right\_child$.build\_tree$(id + 2^{level}, level + 1, num\_servers)$;
	\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.75\linewidth]{images/kdtree}
	\caption{Balanced kd-trees built with the described algorithm}
	\label{fig:kdtree}
\end{figure}

In Algorithm \ref{alg:buildtree}, the $id$ value is used to calculate whether each node has children or not and, in the leaf nodes, it determines the server associated to the region represented by each leaf of the tree. The purpose of this is to create a balanced tree, where the number of leaf nodes on each of the two sub-trees of any node differs, in the maximum, by one. In Figure \ref{fig:kdtree} (a), we have a full kd-tree formed with this simple algorithm and, in Figure \ref{fig:kdtree} (b), an incomplete kd-tree with six-leaf nodes. As we can see, each node of the tree of (b) has two sub-trees whose number of leaf nodes differs by one in the worst case.

\subsection{Calculating the load of avatars and tree nodes}

The definition of the split coordinate for every non-leaf node of the tree depends on how the avatars distribution among the regions will be made. An initial idea might be to distribute the players among servers, so that the number of players on each server is proportional to the bandwidth of that server. To calculate the split coordinate, it would be enough to simply sort the avatars in an array along the axis used ($x$ or $y$) by the tree node to split the space and, then, calculate the index in the vector, such that the number of elements before this index is proportional to the capacity of the left child and the number of elements from that index to the end of the array is proportional to the capacity of the right child (Figure \ref{fig:vector}). The complexity of this operation is $O(nlogn)$, due to the sorting of avatars.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{images/vector}
  \caption{A load splitting considering only the number os avatars}
  \label{fig:vector}
\end{figure}

However, this distribution is not optimal, for the load imposed by the players depends on how they are interacting with one another. For example, if the avatars of two players are distant from each other, there will be probably no interaction between them and, therefore, the server will need only to update each one of them about the outcome of his own actions -- for these, the growth in the number of messages is linear to the number of players. On the other hand, if the avatars are close to each other, each player should be updated not only about the outcome of his own actions but also about the actions of every other player -- in this case, the number of messages may grow quadratically to the number of players (Figure \ref{fig:load}). For this reason, it is not sufficient only to consider the number of players to divide them among the servers.

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{images/carga}
  \caption{Relation between avatars and load}
  \label{fig:load}
\end{figure}

A more appropriate way to divide the avatars is by considering the load imposed by each one of them on the server. A brute-force method for calculating the loads would be to get the distance separating each pair of avatars and, based on their interaction, calculate the number of messages that each player should receive by unit of time. This approach has complexity $O(n^2)$. However, if the avatars are sorted according to their coordinate on the axis used to divide the space in the kd-tree, this calculation may be performed in less time.

For this, two loops are also used to sweep the avatars array, where each of the avatars contains a $load$ variable initialized with zero. As the vector is sorted, the inner loop may start from an index before which it is known that no avatar $a_j$ has relevance to that being referenced in the outter loop, $a_i$. It is used a variable $begin$, with initial value of zero: if the coordinate of $a_j$ is smaller than the $a_i$, with a difference greater than the maximum view range of the avatars, the variable $begin$ is incremented. For each $a_j$ which is at a distance smaller than the maximum view range, the $load$ of $a_i$ is increased according to the relevance of $a_j$ to $a_i$. When the inner loop reaches an avatar $a_j$, such that its coordinate is greater than the one of $a_i$, with a difference greater than the view range, the outer loop moves immediately to the next step, incrementing $a_i$ and setting the value of $a_j$ to that stored in $begin$ (Figure \ref{fig:sweep}).

Let $width$ be the length of the virtual environment along the axis used for the splitting; let also $radius$ be the maximum view range of the avatars, and $n$, the number of avatars. The number of relevance calculations, assuming that they are uniformly distributed in the virtual environment is \mbox{$O(m \times n)$}, where $m$ is the number of avatars compared in the internal loop, i.e. \mbox{$m = \frac{2 \times radius \times n}{width}$}. The complexity of the avatars sorting along one of the axes is $O(nlogn)$. Although it is still quadratic, the execution time is reduced significantly, depending on the size of the virtual environment and on the view range of the avatars. The algorithm could go further and sort each set of avatars $a_j$ which are close (in one of the axes) to $a_i$ according to the other axis and, again, perform a sweep eliminating those which are too far away, in both dimensions. The number of relevance calculations would be \mbox{$O(p \ times n)$}, where $p$ is the number of avatars close to $a_i$, considering the two axes of coordinates, i.e. \mbox{$p = \frac{(2 \times radius)^2 \times n}{width \times height}$}. In this case, $height$ is the extension of the environment in the second axis taken as reference. Although there is a considerable reduction of the number of relevance calculations, it does not pay the time spent in sorting the sub-array of the avatars selected for each $a_i$. Adding up all the time spent on sort operations, it would be obtained a complexity of: \mbox{$O(nlogn + n \times mlogm)$}.

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{images/sweep}
  \caption{Sweep of the sorted array of avatars}
   \label{fig:sweep}
\end{figure}

After calculating the load generated by each avatar, this value is used to define the load on each leaf node and, recursively, on the other nodes of the kd-tree. To each leaf node a server and a region of the virtual environment are assigned. The load of the leaf node is equal to the server's bandwidth used to send state updates to the players controlling the avatars located in its associated region. This way, the load of each leaf node is equal to the sum of the weights of the avatars located in the region represented by it.

\subsection{Dynamic load balancing}

Once the tree is built, each server is associated to a leaf node -- which determines a region. All the state update messages to be sent to players whose avatars are located in a region must be sent by the corresponding server. When a server is overloaded, it may transfer part of the load assigned to it to some other server. To do this, the overloaded server collects some data from other servers and, using the kd-tree, it adjusts the split coordinates of the regions.

Each server maintains an array of the avatars located in the region managed by it, sorted according to the $x$ coordinate. Also, each element of the array stores a pointer to another element, forming a chained list that is ordered according to the $y$ coordinated of the avatars (Figure \ref{fig:vectorxlisty}). By maintaining a local sorted avatar list on each server, the time required for balancing the load is somewhat reduced, for there will be no need for the server performing the rebalance to sort again the avatar lists sent by other servers. It will need only to merge all the avatars lists received from the other servers in an unique list, used to define the limits of the regions, what is done by changing the split coordinates which define the space partitions.

\begin{figure}
  \centering
  \includegraphics[width=0.9\linewidth]{images/vectorxlisty}
  \caption{Avatar array sorted by x, containing a list sort by y}
   \label{fig:vectorxlisty}
\end{figure}

When the overloaded server initiates the rebalance, it runs an algorithm that traverses the kd-tree, beginning from the leaf node that defines its region and going one level up at each step until it finds an ancestor node with a capacity greater then or equal to the load. While this node is not found, the algorithm continues recursively up the tree until it reaches the root. For each node visited, it is sent a request for the information about all the avatars and the values of load and capacity to the servers represented by the leaf nodes of the sub-tree whose root is that node (Figure \ref{fig:ancestors}). With these data, and its own list of avatars and values of load and capacity, the overloaded server can calculate the load and capacity of its ancestral node visited in the kd-tree, which are not known beforehand -- these values are sent on-demand to save up some bandwidth of the servers and to keep the system scalable.

\begin{figure}
  \centering
  \includegraphics[width=0.9\linewidth]{images/ancestors}
  \caption{Search for an ancestor node with enough resources}
   \label{fig:ancestors}
\end{figure}

Reaching an ancestral node with capacity greater than or equal to the load -- or the root of the tree, if no such node is found -- the server that initiated the balance adjusts the split coordinates of the kd-tree nodes. For each node, it sets the split coordinate in a way such that the avatars are distributed according to the capacity of the node children. For this, it is calculated the load fraction that should be assigned to each child node. The avatar list is then sweeped, stopping at the index $i$ such that the total load of the avatars before $i$ is approximately equal to the value defined as the load to be designated to the left child of the node whose split coordinate is being calculated (Figure \ref{fig:balancenode}). The children nodes have also, in turn, their split coordinates readjusted recursively, so that they are checked for validity -- the split coordinate stored in a node must belong to the region defined by its ancestors in the kd-tree -- and readjusted to follow the balance criteria defined.

\begin{figure}
  \centering
  \includegraphics[width=0.9\linewidth]{images/balancenode}
  \caption{Division of an avatar list between two brother nodes}
   \label{fig:balancenode}
\end{figure}

As the avatar lists received from the other servers are already sorted along both axes, it is enough to merge these structures with the avatar list of the server which initiated the rebalance. Assuming that each server already calculated the weight of each avatar managed by it, the rebalance time is  $O(nlogS)$, where $n$ is the number of avatars in the game and $S$ is the number of servers. The communication cost is $O(n)$, caused by the sending of data related to te $n$ avatars. The merging of all avatar lists has $O(n)$ complexity, for the avatars were already sorted by the servers. At each level of the kd-tree, $O(n)$ avatars are sweeped in the worst case, in order to find the $i$ index whose avatar's coordinate will be used to split the regions defined by the each node of the tree (Figure \ref{fig:balancenode}). As this is a balanced tree with $S$ leaf nodes, it has a height of $\lceil logS \rceil$.

\section{Simulations}
\label{sec:simul}

To evaluate the proposed dynamic balancing algorithm proposed, it was simulated a virtual environment across which many avatars moved. Starting from a random point in the environment, each avatar moved according to the random waypoint model \cite{bettstetter2004spr}. To force a load imbalance and stress the algorithm defined in the previous section, we defined some \emph{hotspots} -- points of interest to which the avatars move with a higher probability than to other parts of the map. This way, it is formed a higher avatars concentration in some areas. Although the used movement model is not very realistic in terms of the way the players move their avatars in real games, it was only used to put to test the load balance algorithms simulated. For each algorithm tested, we simulated two situations: one with the presence of hotspots and one without hotspots.

The proposed approach was compared to the ones presented in section \ref{context}, from other authors. However, it is important to observe that the model employed by \cite{ahmed2008mol} considers hexagonal cells, whereas in our simulation we used rectangular cells. Furthermore, the authors considered that there is a trasmission rate threshold, which is the same for all servers in the system. As we assume a heterogenous system, their algorithm was simulated considering that each server has its own transmission rate threshold, depending on the upload bandwidth available in each one of them. However, we kept what we consider the core idea of the authors' approach, which is the selection of the smallest cell cluster managed by the overload server, then chosing that cell with the lowest interaction with other cells of the same server, and finally the transfering of this cell to the least loaded server. Besides this algorithm, we also simulated some of the ones proposed in \cite{bezerra2009lbs}.

The simulated virtual environment consisted of a two-dimensional space, with 750 moving avatars, whose players were divided among eight servers ($S_1, S_2, ..., S_8$), each of which related to one of the regions determined by the balancing algorithm. For the cell-oriented approaches simulated, the space was divided into a \mbox{15 $\times$ 15} cell grid, or 225 cells. The capacity of each server $S_i$ was equal to $i \times 20000$, forming a heterogeneous system. This heterogeneity allowed us to evaluate the load balancing algorithms simulated according to the criterion of proportionality of the load distribution on the servers.

In addition to evaluate the algorithms according to the proportionality of the load distribution, it was also considered the number of player migrations between servers. Each migration involves a player connecting to the new server and disconnecting from the old one. This kind of situation may occur in two cases: the avatar moved, changing the region in which it is located and, consequently, changing the server to which its player is connected, or the avatar was not moving and still its player had to migrate to a new server. In the latter case, obviously the player's transfer was due to a rebalancing. An ideal balancing algorithm performs the load redistribution requiring the minimum possible number of player transfers between servers, while keeping the load on each server proportional to its capacity.

Finally, the intra-server communication overhead will also be evaluated. It occurs when two players are interacting, but each one of them is connected to a different server. Although the algorithm proposed in this work does not address this problem directly, it would be interesting to evaluate how the load distribution performed by it influences the communication between the servers.

\section{Results}
\label{sec:result}

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/distribution_uniform}
	\caption{Average load on each server (by algorithm, without hotspots)}
	\label{fig:distribution:uniform}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/distribution_hotspots}
	\caption{Average load on each server (by algorithm, with hotspots)}
	\label{fig:distribution:hotspots}
\end{figure}

Figures \ ref (fig: distribution: uniform) and \ ref (fig: distribution:) hotspots have the average load (plus the overhead of communication between servers) on each server for each algorithm tested. The first figure shows the values in a situation without agglomerations of players and therefore less total load. The second, in turn, shows the distribution of the load in a situation of overloading the server system. There is, in Figure \ ref (fig: distribution: uniform), that all algorithms have met with the goal of keeping the load on each server less than or equal to its capacity, when the system has sufficient resources to do so. In figure \ ref (fig: distribution: hotspots), which represents a situation of overloading the system, we find that all the algorithms managed to dilute a manner roughly proportional to overloading of the servers.

As figuras \ref{fig:distribution:uniform} e \ref{fig:distribution:hotspots} apresentam a carga média (mais o overhead da comunicação entre servidores) sobre cada servidor, para cada algoritmo testado. A primeira figura mostra esses valores em uma situação sem aglomerações de jogadores e, portanto, com menor carga total. A segunda, por sua vez, mostra a distribuição da carga em uma situação de sobrecarga do sistema servidor. Observa-se, na figura \ref{fig:distribution:uniform}, que todos os algoritmos testados cumpriram com o objetivo de manter a carga sobre cada servidor menor ou igual à sua capacidade, quando o sistema dispõe de recursos suficientes para tal. Na figura \ref{fig:distribution:hotspots}, que representa uma situação de sobrecarga do sistema, percebe-se que todos os algoritmos conseguiram diluir de maneira aproximadamente proporcional a sobrecarga entre os servidores.

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/usagedeviation_uniform}
	\caption{Desvio médio da taxa de uso ideal dos servidores (sem hotspots)}
	\label{fig:usagedeviation:uniform}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/usagedeviation_hotspots}
	\caption{Desvio médio da taxa de uso ideal dos servidores (com hotspots)}
	\label{fig:usagedeviation:hotspots}
\end{figure}

Nas figuras \ref{fig:usagedeviation:uniform} e \ref{fig:usagedeviation:hotspots}, é apresentado o quanto o balanceamento gerado por cada algoritmo desvia de um balanceamento ideal -- isto é, o quanto, em média, a carga sobre os servidores desviam do valor exatamente proporcional à sua capacidade -- ao longo do tempo. O que se descobre é que, em ambas as situações -- com e sem hotspots -- o algoritmo que utiliza a kd-tree tem o menor desvio. Isso se deve à granularidade mais fina da sua distribuição, que, diferentemente das outras abordagens testadas, não é limitada por um tamanho de célula. Na situação com hotspots, o algoritmo que utiliza a kd-tree é especialmente eficaz, pelo fato de balanceamentos serem necessários. Numa situação em que o sistema dispõe de muito mais recursos que o necessário, a proporcionalidade da distribuição não é tão importante, bastando que cada servidor administre uma carga inferior à sua capacidade.

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/migrations_uniform}
	\caption{Migrações de jogadores entre servidores (sem hotspots)}
	\label{fig:migrations:uniform}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/migrations_hotspots}
	\caption{Migrações de jogadores entre servidores (com hotspots)}
	\label{fig:migrations:hotspots}
\end{figure}

No quesito migrações de jogadores, todos os algoritmos testados -- exceto o BFBCT -- causaram um número semelhante de migrações de usuários na ausência de hotspots (Figura \ref{fig:migrations:uniform}). Isso se deve ao fato da carga do jogo ser inferior à capacidade total do sistema servidor, o que exigia poucos rebalanceamentos e, consequentemente, poucas migrações de jogadores entre servidores. Na Figura \ref{fig:migrations:hotspots}, porém, percebe-se que o algoritmo que utiliza a kd-tree teve um número significativamente menor de migrações de usuários do que as outras abordagens. Isso se deve, primeiro, ao fato de que as regiões definidas pelos nós folhas da kd-tree são necessariamente contíguas, e cada servidor estava associado a apenas um desses nós folha. Um avatar movendo-se por um ambiente com regiões muito fragmentadas atravessaria constantemente fronteiras entre essas regiões e faria, consequentemente, com que seu jogador trocasse de servidor repetidas vezes. Outra razão para este resultado é que cada rebalanceamento de carga executado com a kd-tree aproxima bastante a carga sobre os servidores do valor ideal, exigindo menos rebalanceamentos futuros e, consequentemente, causando menos migrações de jogadores do que nas abordagens com células.

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/overhead_uniform}
	\caption{Comunicação entre servidores para cada algoritmo ao longo do tempo (sem hotspots)}
	\label{fig:overhead:uniform}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{images/overhead_hotspots}
	\caption{Comunicação entre servidores para cada algoritmo ao longo do tempo (com hotspots)}
	\label{fig:overhead:hotspots}
\end{figure}

Por fim, é mostrada a comunicação entre servidores, para cada algoritmo simulado, ao longo do tempo. Na Figura \ref{fig:overhead:uniform}, todos os algoritmos têm um resultado semelhante, sendo que o que utiliza a kd-tree tem um pouco menos de overhead do que os outros. Isso também se explica pelo fato das regiões serem contíguas, minimizando o número de fronteiras entre as mesmas e, consequentemte, reduzindo a probabilidade de haver interações entre pares de avatares em que cada um está em uma região diferente. Na Figura \ref{fig:overhead:hotspots}, percebe-se que o algoritmo Progrega causou uma comunicação entre servidores significativamente menor que os outros em uma situação de sobrecarga. A razão para isto é que o objetivo principal -- além de balancear a carga -- do Progrega é de justamente reduzir a comunicação entre servidores. No entanto, mesmo não considerando esse sobrecusto, o algoritmo que utiliza a kd-tree ficou em segundo lugar nesse critério.

\section{Conclusions}
\label{sec:conc}

Use \emph{template.tex} and  \emph{template.tex} to write your paper and enumerate bibliographic references. So, run:

\begin{description}
\item pdflatex template
\item bibtex template
\item pdflatex template
\item pdflatex template
\end{description}

That's it. You can rename template.tex and .bib. So, keep
\emph{sbgames.cls} and \emph{sbgames.bst} without modifications. They
are required to format text and bibliography according to SBGAMES
format.


\section{How to submit}
\label{sec:how-submit}

Each manuscript must be submitted electronically using the JEMS
submission site at \url{https://submissoes.sbc.org.br/sbgames2007} ONLY PDF
file format is accepted. An additional 10 MB will be available for the
(optional) ZIP file with the supplementary material.

Every co-author of a manuscript must also be registered as a user of
JEMS before the manuscript is submitted. Instructions on how to
register new JEMS users and how to retrieve forgotten JEMS passwords
are available at the same URL above. PLEASE MAKE SURE THAT EVERY
CO-AUTHOR IS INCLUDED AT THE TIME OF SUBMISSION. WE CANNOT LATER ON
ADD AND/OR REMOVE AUTHORS FROM SUBMITTED PAPERS.

Upon logging on at \url{https://submissoes.sbc.org.br/sbgames2007}
select the icon ``submit paper'' for the track ``Computing - Full
Papers'', in order to submit a full paper. You will then be taken to a
page with the title "Submit a paper to SBGAMES 2007 - Computing
Track". Fill in the paper registration information requested in that
page (don't forget to chose the keywords for your paper at the bottom
of the page) and then click on the ``submit'' icon, in order to
complete your paper's registration. After doing so, you will view a
page called "Registering Paper". The first line after the title of
this page should say ``Paper $<$5digits$>$ created'', where
$<$5digits$>$ is a five-digit number assigned by JEMS to your
manuscript. Before you upload your manuscript, include this five-digit
number in the place where you would normally put the author names (for
instance, by including the command
$\backslash$\emph{author}\{Manuscript number $<$5digits$>$\} in your
LaTeX source file).

After you have generated the final PDF file containing the manuscript
number (which should be renamed as $<$5digits$>$.pdf), you can upload
it immediately by following the "upload" link available on the page
"Registering Paper", or log out of the JEMS site and return later to
upload your paper.  If you choose the latter option, an "Upload" icon
for each registered manuscript will be accessible from your SBGAMES
2007 home page within JEMS. In any case, please upload the PDF file
with your manuscript first and then, if desired, return to the
manuscript upload page (either using your browser's "Back" button or
through your SBGAMES 2007 JEMS home) and upload the optional ZIP file
with the supplementary material.  You should receive an e-mail
confirmation every time you perform an upload.

\section{Conclusion}
\label{sec:conclusion}

The final sections of your work are: acknowledgements and references.
These final sections are not numbered.

\section*{Acknowledgements}

To Robert, for all the bagels.

\bibliographystyle{sbgames}
\bibliography{kdtree}
\end{document}
