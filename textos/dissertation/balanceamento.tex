%\newcommand{\ggp}{ProGReGA} [TODO:mudar esse nome]
%\newcommand{\ggpmeaning}{proportional greedy region growing algorithm}
%\newcommand{\wtodiv}{weight\_to\_divide}
%\newcommand{\freecap}{free\_capacity}
%\newcommand{\rlist}{region\_list}
%\newcommand{\wshare}{weight\_share}

\newcommand{\ggp}{ProGReGA}
\newcommand{\ggpmeaning}{proportional greedy region growing algorithm}
\newcommand{\wtodiv}{carga\_a\_dividir}
\newcommand{\freecap}{capacidade\_livre}
\newcommand{\rlist}{lista\_de\_regi\tilde{o}es}
%\newcommand{\wshare}{por\text{\emph{\c{c}}}\tilde{a}o\_da\_carga}
\newcommand{\wshare}{parcela\_da\_carga}

[TODO:cap/lista de termos e definições]
%por figuras para ilustrar o que se está falando
\chapter {Balanceamento de carga}

A principal característica dos jogos maciçamente multijogador é a grande quantidade de jogadores, chegando a ter dezenas ou centenas de milhares de participantes simultaneamente [TODO:ref]. Essa grande quantidade de jogadores interagindo entre si gera um tráfego na rede de suporte que tem crescimento quadrático em relação ao número de jogadores, no pior caso [TODO:referenciar/provar].

Quando se utiliza uma arquitetura cliente-servidor, é necessário que o servidor intermedie a comunicação entre cada par de jogadores -- supondo que se pretende prover ao jogo garantias de consistência e resistência a trapaça. Obviamente, esse servidor terá uma grande carga de comunicação e, conseqüentemente, deverá ter recursos (largura de banda disponível) proporcional à demanda do jogo.

[TODO:largura de banda X CPU]

A questão posta aqui é que, quando se faz uso de um servidor distribuído, principalmente com recursos escassos, que é a proposta deste trabalho, é necessário otimizar o uso destes recursos, atribuindo a cada servidor uma carga que ele seja capaz de suportar. Dessa forma, não importando a qual servidor cada jogador estiver conectado, sua experiência de jogo será semelhante, no que diz respeito ao tempo de resposta para suas ações e o tempo que leva para ser notificado de ações de outros jogadores, assim como de mudanças de estado no ambiente virtual do jogo.

[aqui já fala do n ao quadrado, por cima]

Uma idéia inicial poderia ser a de distribuir os jogadores entre servidores, de maneira que o número de jogadores em cada servidor fosse proporcional à largura de banda daquele servidor. No entanto, essa distribuição não funcionaria, pelo fato de que a carga causada pelos jogadores depende também do quanto os jogadores estão interagindo entre si. Por exemplo, se os avatares de dois jogadores estiverem muito distantes um do outro, provavelmente não haverá interação entre eles e, portanto, o servidor precisará apenas atualizar cada um a respeito de suas próprias ações. No entanto, se estes avatares estiverem próximos, cada jogador deverá ser atualizado não apenas a respeito de suas próprias ações, como também das ações do outro jogador.

Percebe-se, então, que quando os avatares estão distantes uns dos outros, o tráfego cresce linearmente com o número de jogadores. Porém, se eles estão próximos uns dos outros, o tráfego cresce quadraticamente. Por fim, ambas as funções de crescimento do número de mensagens podem estar presentes no mesmo jogo se, em alguns lugares do ambiente virtual, os avatares estiverem próximos e, em outros lugares, eles estiverem distantes.

Essa característica de localidade, no que diz respeito à distribuição dos avatares no ambiente virtual, está presente na grande maioria dos jogos multijogador. Existem alguma exceções, como GuildWars [TODO:ref], em que apenas grupos com um número limitado de jogadores podem iniciar uma partida. Este tipo de jogo é baseado no modelo de instâncias, onde todos os avatares dos jogadores se encontram em um espaço social, de interação limitada, menos dinâmica e, portanto, com tráfego de rede algumas ordens de grandeza menor [TODO:ref/prove]. Quando pretende-se iniciar uma partida ``real'', os jogadores requisitam ao servidor que seja criado um grupo de ação. Dessa forma, impede-se que um número teoricamente ilimitado de jogadores interajam entre si, sobrecarregando o servidor.

Normalmente, porém, os jogadores podem mover seus avatares livremente através do mundo do jogo. Isso torna possível a formação de pontos de interesse -- também conhecidos como \emph{hotspots} [TODO:ref] -- ao redor dos quais os jogadores se concentram mais do que em outras regiões do ambiente virtual. Aliás, muitos jogos de RPG online maciçamente multijogador não só permitem como também estimulam, até certo ponto, a formação destes pontos de interesse. Nestes mundos dos MMORPGs, existem cidades inteiras, onde os jogadores se encontram para conversar, trocar mercadorias virtuais do jogo e/ou duelar, assim como existem também zonas desérticas, sem muitos atrativos para os jogadores, e onde o número de avatares presentes é relativamente pequeno, se comparado com outros lugares no jogo.

[TODO:screenshot(s)]

Por esta razão, não é suficiente apenas dividir os jogadores entre os servidores, mesmo que proporcionalmente aos recursos de cada um destes. Em primeiro lugar, em alguns casos o uso de largura de banda do servidor é quadrático ao número de jogadores, enquanto é linear em outros. Essa razão por si só já é suficiente para buscar outro critério para o balanceamento de carga. Além disso, surge outra questão importante: a existência de pontos de interesse. Esta última característica motiva à criação de um esquema de balanceamento de carga para jogos que impeça que a presença de hotspots degrade a qualidade do jogo além do tolerável.


%\section{Introdução (nao precisa por "introdução"}
%dinamica dos avatares
%heterogeneidade dos servidores
%necessidade de bal. de carga


\section{Trabalhos relacionados [TODO:rename]}
%micro/macro-cell
%esquemas já propostos (ahmed, lee, /*devlechauer*/)
%o que falta em cada um

Como foi dito, quando existe um número considerável de avatares em um mesmo ponto de interesse, é gerado um tráfego proporcional ao quadrado do número de avatares ali presentes. Também foi mostrado que os servidores recebem as ações enviadas pelos jogadores, calculam seu resultado e o enviam para todos os jogadores interessados, que são, geralmente, aqueles cujos avatares estiverem próximos do avatar do primeiro jogador. Se esses jogadores forem divididos entre diferentes servidores, cada um destes precisará não apenas enviar o estado do mundo resultante das ações para os jogadores controlados por ele, como também deverá enviá-lo para o servidor ao qual os outros jogadores estão conectados. Este, por sua vez, encaminhará este resultado para seus jogadores.

[por figura do envio de estados através de servidores diferentes. duas figuras: no mesmo servidor, e através de diferentes servidores.]

Percebe-se, então, que cada estado deverá ser enviado duas vezes, para cada par de jogadores que se comunicam através de servidores diferentes. Esse overhead não apenas causa o desperdício de recursos dos servidores, como também aumenta o atraso para atualização de estado das réplicas do jogo nas máquinas dos jogadores. Isto faz com que o tempo entre o envio de uma ação por um jogador conectado a um servidor e o recebimento do estado resultante por outro jogador, conectado a outro servidor, seja maior, prejudicando a interação entre eles.

Assim sendo, jogadores que estão interagindo entre si devem, idealmente, estar conectados ao mesmo servidor. Contudo, é possível que todos os jogadores estejam ligados entre si através de relações transitivas de interação. Por exemplo, dois avatares, de dois jogadores diferentes, podem estar distantes, porém ambos interagindo com um terceiro avatar, entre os dois. A figura [TODO:ref] ilustra melhor este tipo de situação. Contudo, ainda assim será necessário dividí-los entre servidores. A questão é quanto a quais pares de jogadores estarão divididos em servidores diferentes. É necessário, portanto, decidir um critério para agrupar jogadores em um mesmo servidor.

[TODO: figura da interação de A, B e C]

Nas próximas seções, serão apresentados os trabalhos e princípios utilizados nas abordagens de outros autores. Embora apontem direções que se podem tomar para resolver o problema de distribuição e balanceamento de carga dinâmico de MMOGs, não o resolvem por completo, por razões que serão melhor detalhadas ao longo do texto. Com base em alguns desses princípios a seguir, e em pesquisa e implementação realizadas, será definido o esquema de balanceamento de carga aqui proposto.

%falar do macrocell/microcell (usar localidade)
\subsection{Microcélulas e macrocélulas}

%O balanceamento de carga entre servidores de jogos online maciçamente multijogador é fortemente dependente da distribuição dos avatares dos jogadores através do ambiente virtual. Além disso, a depender da concentração de avatares, pode-se alternar entre uma função de crescimento de tráfego linear e uma função quadrática. Sendo assim, é necessário lidar com a localidade dos avatares, de maneira a otimizar o uso de largura de banda do sistema servidor, minimizando, tanto quanto possível, o overhead causado pela comunicação entre jogadores ligados a servidores diferentes.

Uma maneira de fazer uso da localidade dos jogadores é agrupá-los de acordo com a posição ocupada por seus avatares no ambiente virtual. A questão seria a de como formar estes grupos. Uma maneira de fazer isto seria dividindo o mundo do jogo em várias células conectadas entre si. Cada célula consistiria em uma parte do mundo, com conteúdo e características próprios, que seria delegada a um nodo servidor. A forma mais simples de fazer isto é com uma grade de células de mesmo tamanho e formato. 

[TODO:footnote?]Porém, o formato e a disposição destas células irá influenciar no tráfego gerado pelas mesmas entre os servidores. Por exemplo, um ambiente bidimensional poderia ser dividido em uma grade de células quadradas. Neste caso, cada uma destas células teria oito vizinhos, em média -- células nas bordas do mapa poderiam ter cinco ou três vizinhos apenas. Quanto mais servidores vizinhos, maior o tráfego entre servidores, e maior o overhead causado por esta comunicação. A distribuição ideal, então, seria utilizando células hexagonais, cada uma com seis vizinhos. Estudos comprovam que esta é a divisão em células iguais que permite o menor número de vizinhos por célula [TODO:ref]. Outra possibilidade seria utilizando fileiras alternadas de células quadradas, onde cada fileira seria deslocada o equivalente à metade do comprimento de uma célula.

[TODO:figura com diferentes tipos de divisão:sqr/hex/shift]

Uma questão importante deste design é que o conceito de célula é transparente para os jogadores. Estes visualizam um mundo vasto, único e não fragmentado, mesmo que estejam cruzando repetidamente as fronteiras entre diferentes células. Assim, é possível para eles moverem-se livremente através do ambiente virtual, independente de como é feita a distribuição. Obviamente, isso exige que as células se comuniquem, de maneira a atualizarem-se mutuamente e notificarem-se a respeito de eventos que ocorram próximo à fronteira entre elas, assim como a respeito da migração de jogadores entre uma e outra.

Embora essa abordagem com células distribua a carga entre diversos servidores, não há garantias de que essa distribuição será uniforme, devido à grande mobilidade dos jogadores e à existência de pontos de interesse. Uma das idéias propostas na literatura \cite{devleeschauwer2005dma} também segue o princípio de dividir o ambiente virtual em células de tamanho e posição fixos, porém essas células são relativamente pequenas -- ou \textbf{microcélulas} -- e podem ser agrupadas, formando um espaço contínuo chamado de \textbf{macrocélula}. Cada macrocélula é então designada a um diferente servidor, que passa a administrar não apenas uma grande célula de tamanho e posição fixos, mas um conjunto variável de pequenas células. Estas microcélulas podem então ser transferidas dinamicamente entre diferentes macrocélulas, de maneira a manter a carga em cada um dos diferentes servidores abaixo do limite por ele suportado.

Obviamente, as microcélulas designadas ao mesmo nodo servidor não gerarão tráfego adicional para sincronizarem-se entre si, porém torna-se imprevisível o overhead de sincronização entre diferentes macrocélulas, pois o número de vizinhos que cada macrocélula terá é imprevisível, assim como o seu formato. Porém, demonstrou-se \cite{devleeschauwer2005dma} que esse overhead é compensado pela melhor distribuição da carga do jogo entre os servidores. A figura [TODO:ref] ilustra a divisão de um ambiente virtual bidimensional em microcélulas. É ilustrado em [TODO:ref] o agrupamento destas microcélulas em macrocélulas dinâmicas, que podem se adaptar à distribuição de avatares.

[TODO: figuraS com microcélulas e macrocélulas - fazer vetorial ou copiar? depende do tempo que tiver depois de terminar o texto. divisao em micro e agrupamento em macro]

\subsection{<dewan ahmed>}
save for later... find some holes in it...
%ele considera apenas a buffer region, enquanto eu uso uma abordagem mais "fine-grained" (A3)
%load das células está OK, mas não das arestas!
%algoritmo considera que cada aresta tem peso 1, ao invés de considerar a comunicação entre servidores.
%nao usa part. de grafos ou refinamento de partição

\subsection{Balanceamento com informações locais}
%sem detalhes do algoritmo de balanceamento de grafos escolhido, nem faz uso do edge-cut (isso vai pra minha solução proposta)
%o peso é a quantidade de jogadores
%servidores com mesmo peso
%a capacidade do servidor é o poder de processamento, ao invés da banda
%considera-se que os servidores estejam conectados através de uma rede de alta velocidade. (oh de bal. e oh de intercomunicação)
%a cada servidor é alocado 90% de sua capacidade. Isso pode não funcionar. Critério ruim.
%possível loop infinito, se não houverem vizinhos capazes ou disponíveis. Outro critério ruim.

No trabalho de \cite{lee2003sdl}, também é proposto um esquema dinâmico de balanceamento de carga para os servidores de um sistema multi-servidor de ambiente virtual, levando em conta que os usuários podem estar distribuídos através deste mundo de maneira não uniforme. De acordo com o esquema proposto pelos autores, um servidor sobrecarregado inicia o processo selecionando um conjunto de outros servidores para fazerem parte da redistribuição de carga. O conjunto de servidores selecionados dependerá do nível de sobrecarga do servidor inicial, assim como da quantidade de recursos ociosos dos outros servidores. Após a formação desse conjunto, seus elementos repartirão as porções do ambiente virtual que lhes pertencentem utilizando um algoritmo de particionamento de grafo, de forma que os servidores envolvidos tenham carga final de trabalho semelhante.% Após decidir-se quem fica com que trabalho, os servidores envolvidos migram suas cargas entre si de maneira par-a-par.

O principal aspecto da solução proposta pelos autores foi a utilização de informações locais (do servidor que iniciou o processo de balanceamento e de seus vizinhos), ao invés de informações globais (todos os servidores envolvendo-se no balanceamento). A primeira apresenta pouco overhead, mas pode não resolver o problema de maneira eficiente em poucos passos, já que servidores sobrecarregados tendem a estar adjacentes. Já a abordagem global é capaz de dividir a carga de trabalho da forma mais equilibrada possível, mas sua complexidade cresce exponencialmente com o número de servidores envolvidos. A solução apontada no trabalho então é de o balanceamento de carga envolver apenas um subconjunto de servidores, sendo que sua cardinalidade varia de acordo com a necessidade (se os vizinhos do servidor que disparou o balanceamento de carga estiverem também sobrecarregados, são selecionados mais servidores). Dessa forma, tem-se um pouco mais de informação do que a abordagem local, mas sem o problema da complexidade inerente à abordagem global.

%O principal objetivo da distribuição da carga entre os servidores do multi-servidor é manter a qualidade de interação dos usuários em um nível aceitável, reduzindo a carga de servidores sobrecarregados e delegando-a a outros, menos carregados, mantendo o nível de carregamento uniforme, ainda que a distribuição dos usuários no ambiente virtual não o seja. Se um servidor lida com muitos usuários além de sua capacidade computacional, ele não pode enviar mensagens de atualização de estado em tempo satisfatório; como resultado, a interação dos usuários é degradada. Distribuição dinâmica de carga pode evitar tal problema transferindo algumas porções de uma região (células e usuários) de servidores sobrecarregados para servidores menos carregados. No entanto, a migração de células e usuários impõe um novo sobrecusto nos servidores porque a informação de estado atualizada dos usuários que migraram deve ser replicada dos velhos servidores para os novos; consequentemente, a própria distribuição dinâmica da carga também pode degradar a qualidade do jogo. Portanto, um esquema dinâmico de distribuição de carga deve reduzir o número de jogadores prejudicados por servidores sobrecarregados, assim como minimizar o número de migrações necessárias.

%1.1.1
%\subsubsection{Escalabilidade}

%Um esquema dinâmico de distribuição de carga deve funcionar bem, independente do tamanho do sistema. Em termos de overhead, a abordagem local é adequada para sistemas de larga escala porque seu sobrecusto é limitado à comunicação do servidor com seus vizinhos, sem ser afetado pelo tamanho do sistema. No entanto, a abordagem local, apesar de funcionar bem com um pequeno número de servidores, não funciona de maneira eficiente no caso de um desbalanceamento da carga de trabalho entre os servidores, que pode ser altamente assimétrica. A abordagem global apresenta grande eficácia independentemente do tamanho do sistema, pois todos os servidores no sistema pooperam para balancear suas cargas de trabalho. Porém, a abordagem global não é escalável, pois tem um sobrecusto que aumenta exponencialmente com o número de servidores no sistema multi-servidor. Logo, deve ser encontrada uma nova abordagem que funcione de maneira eficiente, com pequeno sobrecusto, independente do tamanho do sistema.

%1.1.2
%\subsubsection{Adaptatividade}

%Para prover tal solução escalável, o esquema dinâmico de distribuição de carga deve ser executado adptando-se dinamicamente ao estado de sobrecarga dos servidores. Infelizmente, os esquemas existentes - local e global - não se adaptam ao estado de sobrecarga dos servidores. Na abordagem local, servidores sobrecarregados apenas consideram servidores vizinhos como seus parceiros para redistribuição da carga, de forma que não pode haver distribuição da sua carga excessiva de forma eficiente, se todos seus vizinhos estão sobrecarregados também. Por outro lado, a abordagem global reparte o ambiente virtual inteiro com informações de todos os servidores. Isto é desnecessário quando apenas um pequeno subconjunto dos servidores pode resolver de forma satisfatória o problema de desbalanceamento de carga do sistema. Sendo assim, um subconjunto de servidores do sistema deve ser determinado, considerando o estado de sobrecarga dos outros servidores.

%1.2
%\subsection{Modelo do sistema}

Para atacar o problema, os autores também subdividem o ambiente virtual em \textbf{células} -- semelhantes às microcélulas -- retangulares, sendo que o número de servidores é muito menor que o número de células. As células são agrupadas em \textbf{regiões} -- ou macrocélulas -- e cada região é gerenciada por um servidor. Cada servidor mantém atualizadas informações de estado dos usuários e lida com as interações entre avatares na região a ele dedicada. Cada usuário envia e recebe atualizações de estado através do servidor que gerencia a região na qual ele está jogando. Duas células são ditas adjacentes (ou vizinhas) se elas compartilharem uma fronteira. Analogamente, duas regiões, e seus respectivos servidores, são ditos adjacentes se existir um par de células adjacentes, cada uma das quais pertencendo a uma das duas regiões. A Figura \ref{fig:leeA} ilustra o modelo de um sistema multi-servidor consistindo de 16 servidores. O ambiente virtual é dividido em 256 células, que são agrupadas em 16 regiões.

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{images/LEE_leeA.jpg}
 \caption{Um modelo multi-servidor para ambiente virtual distribuído}
 \label{fig:leeA}
\end{figure}

Foi definida a carga de trabalho de uma célula como o número de avatares presentes naquela célula. Os autores assumiram que todos avatares atualizam seus estados na mesma frequência, de forma que a carga de processamento (computação e comunicação) que uma célula impõe a um servidor é proporcional ao número de usuários naquela célula. A carga de trabalho de uma região e seu servidor designado é definida como a soma das cargas de trabalho individuais das células que compõem aquela região. Cada servidor periodicamente avalia sua carga de trabalho e troca informações de carga com os servidores vizinhos. Assumiu-se, também, que estes servidores estão conectados através de uma rede de alta velocidade. Dessa forma, o overhead de trocar informações de sobrecarga entre vizinhos é limitada e considerada negligenciável, se comparada com outros custos da distribuição de carga. Pelo mesmo motivo, também assumiu-se como negligenciável o overhead de comunicação entre servidores quando jogadores em diferentes regiões estão interagindo.

%A capacidade de processamento de um servidor é limitada; isto é, uma grande quantidade de carga, além da capacidade de um servidor aumenta o tempo de processamento das mensagens de atualizações de estado dos usuários. Define-se como capacidade de um servidor, representada por CP, o máximo número de usuários que o servidor pode suportar sem prejudicar a performance da interação entre os usuários. Considera-se que todos os servidores têm a mesma capacidade.

%1.3
%\subsubsection{O esquema de distribuição de carga dinâmico proposto}
\subsubsection{Seleção de grupo local para balancear a carga}

%o servidor que iniciou reparte as regiões que eram dedicadas a ele entre os servidores envolvidos, de forma que eles terão aproximadamente a mesma carga. Então, os servidores envolvidos migram suas celulas e usuários entre si de maneira par-a-par, de acordo com o resultado do reparticionamento. Nas sessões seguintes, será descrito em detalhes como isso é realizado.

%1.3.1
%\subsubsection{Seleção adaptativa de servidor}

Um servidor dispara o balanceamento quando a carga atribuída a ele excede sua capacidade. Este servidor seleciona um conjunto de outros servidores para se envolverem com a distribuição. Primeiro, o servidor que iniciou escolhe o menos carregado dentre seus vizinhos e envia um pedido de que ele participe do balanceamento de carga. O vizinho escolhido rejeita o pedido se ele já está envolvido em outro grupo de balanceamento; caso contrário, ele responde ao servidor iniciador com a informação de carga de seus próprios vizinhos. Se o servidor vizinho que está partcipando não for capaz de absorver a carga de trabalho excedente do servidor iniciador, a seleção é executada novamente entre os servidores vizinhos de não apenas o servidor sobrecarregado, como também os vizinhos do vizinho escolhido na primeira fase. A seleção continua até que a carga de trabalho excedente do primeiro servidor possa ser absorvida -- isto é, a carga de trabalho de todos os servidores selecionados torna-se menor que um limite pré-definido. Os autores definiram este limite como sendo 90\% da capacidade total do conjunto de servidores. O critério utilizado foi o de evitar o imediato reinício da balanceamento de carga.

Sejam SELECIONADOS e CANDIDATOS conjuntos de servidores, ambos inicialmente vazios e seja $CP$ a capacidade de cada servidor. O procedimento para determinar quem serão os servidores envolvidos é o seguinte:

\begin{enumerate}	

	\item O servidor que disparou o balanceamento, $S_i$, é inserido em SELECIONADOS, que são os servidores envolvidos na distribuição de carga. Os servidores vizinhos do iniciador são adicionados em CANDIDATOS, que são os servidores que podem vir a participar da seleção.
	
	\item De CANDIDATOS, é selecionado o servidor com menor carga de trabalho, $S_v$; então, $S_i$ envia um pedido a ele para participar na distribuição de carga
	
	\begin{enumerate}
	
		\item Se o servidor $S_v$ não está envolvido em outra distribuição de carga, ele responde ao servidor $S_i$ com a carga de trabalho de seus vizinhos. Quando $S_i$ recebe esta resposta, ele insere $S_v$ em SELECIONADOS e seus vizinhos são inseridos em CANDIDATOS, se eles já não estiverem dentro de SELECIONADOS ou de CANDIDATOS.
		
		\item Se $S_v$ já está participando de outra distribuição de carga, ele rejeita o pedido e é removido do conjunto CANDIDATOS.
	
	\end{enumerate}
	
	\item O passo 2 é repetido até que a carga de trabalho média dos servidores selecionados se torne menor que um limite: $0,9 \times CP$.
	
\end{enumerate}

Para exemplificar o funcionamento do algoritmo, pode-se observar a Figura \ref{fig:lee2}. Todos os servidores têm a mesma capacidade, podendo cada um comportar 100 usuários. Primeiro, o servidor iniciador, $S_6$, é inserido em SELECIONADOS e seus vizinhos ($S_2$, $S_5$, $S_7$ e  $S_{10}$) são adicionados a CANDIDATOS (Figura \ref{fig:lee2}(a)). Então, $S_7$, que tem a menor carga de trabalho dentre os servidore em CANDIDATOS, é selecionado e convidado a participar da distribuição de carga. Quando $S_7$ responde a $S_6$ com a informação de carga de seus vizinhos ($S_3$, $S_6$, $S_8$ e $S_{11}$), $S_7$ é inserido em SELECIONADOS e seus vizinhos, exceto $S_6$, são adicionados a CANDIDATOS (Figura \ref{fig:lee2}(b)). Agora, $S_{11}$, que tem a menor carga de trabalho dentre os servidores em CANDIDATOS, é selecionado e convidado a participar da distribuição de carga. Porém, $S_{11}$ rejeita o convite, pois já está envolvido em outra distribuição, iniciada por $S_{12}$. Assim, $S_{11}$ é removido de CANDIDATOS e $S_{10}$ é selecionado porque tem agora a menor carga de trabalho dentre os servidores em CANDIDATOS (Figura \ref{fig:lee2}(c)). Até que a carga de trabalho média dos servidores em SELECIONADOS se torne menor que $0,9 \times CP$, ou seja, $90$, o procedimento acima continua (Figura \ref{fig:lee2}(d) e Figura \ref{fig:lee2}(e)).

\begin{figure}
 \centering
 \includegraphics[width=1.0\textwidth]{images/LEE_distribution.jpg}
 \caption{Seleção do grupo de servidores para balanceamento local}
 \label{fig:lee2}
\end{figure}

%1.3.2
\subsubsection{Reparticionamento das regiões}

Uma vez que o servidor iniciador seleciona um conjunto de servidores para se envolverem na distribuição de carga, ele reparte as regiões a ele dedicadas com os servidores envolvidos. É sugerido pelos autores, embora não sejam dados detalhes, o uso de alguma técnica de particionamento de grafos para repartir essas regiões. Cada célula seria representada por um vértice adjacente àqueles que correspondessem às células vizinhas. O peso de cada vértice é então ajustado como a carga de trabalho da célula que representa. Eles são agrupados em partições, cada uma das quais representa uma região, e o número de partições deve ser igual ao número de elementos do conjunto SELECIONADOS. Cada uma das partições formadas após a execução do algoritmo de particionamento de grafo deverá ter um conjunto de vértices tal que o peso das partições seja semelhante -- ou seja, cada servidor terá aproximadamente a mesma carga de trabalho.

%1.3.3

Com o término do reparticionamento das regiões, o servidor que iniciou todo o processo de balanceamento de carga dissemina o novo particionamento, que acabou de ser calculado, para os outros servidores envolvidos. Isso inclue a informação de que células devem migrar para quais regiões/servidores. Após receber estas informações, cada servidor inicia o processo de emigração de células e usuários. Primeiro, envia-se o estado dos avatares e das células que serão transferidos para o servidor que os receberá. A informação a ser enviada varia de acordo com as características da aplicação. Por exemplo, pode incluir apenas a localização dos avatares, ou pode conter informações mais detalhadas, como qual é o modelo visual que representa aquele jogador. Depois de enviar esses dados, o servidor notifica cada usuário que migrou, que passa então a comunicar-se apenas com seu novo servidor.

%2
%\section{Padrão de movimentação do usuário}
%[TODO:usar no meu modelo de movimentação. incrementar para explicar o meu]
%Este artigo também propõe um modelo de movimentação de usuário, que baseia-se no \emph{Random Waypoint Mobility Model}, que é extensivamente utilizado para avaliação de performance em redes sem fio ad-hoc. Usuários estão aleatoriamente distribuídos no ambiente virtual. Eles têm suas próprias localizações de destino traçadas, que são escolhidas aleatoriamente no mundo virtual. A cada passo t no tempo, cada usuário se move em direção ao seu destino através de uma linha reta com velocidade escolhida aleatoriamente entre 0 e max\_speed. A velocidade máxima dos usuários, max\_speed, é escolhida de forma que um usuário possa ir da esquerda para a direita do ambiente virtual em 100 passos de tempo. Por exemplo, se o tamanho do ambiente virtual é de $500x500(m^{2})$, a velocidade máxima dos usuários é de 500/100 = 5 (m/passo de tempo). Quando um usuário chega à sua posição de destino, ele começa a se mover novamente de acordo com a mesma regra. Figura \ref{fig:lee3}(a) mostra a distribuição inicial de usuários no ambiente virtual no instante t=0 e a Figura \ref{fig:lee3}(b) mostra a distribuição de usuários no instante t=100. A distribuição de usuários mostrada nas figuras está de acordo com os resultados da distribuição espacial do \emph{Random Waypoint Mobility Model}: os usuários tendem a se aglomerar na área central, ao invés da área das bordas.

%\begin{figure}
% \centering
% \includegraphics[width=1.0\textwidth]{images/LEE_mobility.jpg}
% \caption{Distribuição dos usuários com o modelo de movimentação proposto}
% \label{fig:lee3}
%\end{figure}

%3
%\section{Avaliação do trabalho}

%Tal como os trabalhos vistos anteriormente, \cite{lee2003sdl} contém uma proposta de suporte a ambientes virtuais distribuídos (onde se encaixam jogos maciçamente multijogador), baseada na distribuição do servidor do ambiente, porém, considerando uma rede local e que não há atraso significativo na comunicação entre os nodos servidores.

%De qualquer forma, este trabalho traz um algoritmo interessante para reparticionamento do ambiente virtual do jogo, de maneira dinâmica e adaptativa, buscando repartir a carga de trabalho com servidores menos sobrecarregados, seguindo uma heurística definida pelos autores.

%Além disso, é proposto um modelo simples de movimentação dos usuários, baseado no \emph{Random Waypoint Mobility Model}, que pode vir a ser útil numa futura simulação em algum trabalho futuro.


\section{Esquema proposto}

Na seção anterior foram apresentados trabalhos existentes no que se refere a balanceamento de carga em MMOGs que utilizam vários servidores para prover o suporte de rede. O esquema de balanceamento de carga proposto neste trabalho tem como base alguns dos princípos já existentes na literatura. Um deles é o da divisão do ambiente virtual em microcélulas, para posterior agrupamento em macrocélulas. Isto permite tratar de maneira relativamente simples a questão da dinâmica da movimentação dos avatares através do mundo do jogo, através da formação dos conjuntos de microcélulas, cujos elementos podem ser transferidos dinamicamente de acordo com a necessidade.

Além disso, também será utilizada a idéia de fazer o balanceamento baseado apenas em informações locais -- cada servidor, quando precisar diminuir a carga atribuída a ele, seleciona somente alguns outros servidores para participar de um rebalanceamento de carga local. Dessa forma, pode-se reduzir consideravelmente a complexidade do balanceamento, pois não será necessário que todos os servidores do jogo troquem mensagens entre si cada vez que qualquer um deles estiver desbalanceado. %[TODO: falar da vantagem de diminuir migrações também, assim que se entender/provar com resultados]

%sem detalhes do algoritmo de balanceamento de grafos escolhido, nem faz uso do edge-cut (isso vai pra minha solução proposta)
%o peso é a quantidade de jogadores
%considera-se que os servidores estejam conectados através de uma rede de alta velocidade. (oh de bal. e oh de intercomunicação)
%a capacidade do servidor é o poder de processamento, ao invés da banda

%servidores com mesmo peso
%a cada servidor é alocado 90% de sua capacidade. Isso pode não funcionar. Critério ruim.
%possível loop infinito, se não houverem vizinhos capazes ou disponíveis. Outro critério ruim.


Os trabalhos relacionados que foram descritos na seção anterior buscam resolver o problema do balanceamento de carga dinâmico. No entanto, carecem de diversas melhorias para que sejam mais coerentes com as necessidades dos MMOGs. Por exemplo, em momento algum foi considerado que, geralmente, o tráfego gerado pelos jogadores não é simplesmente linear, mas quadrático para cada aglomerado de jogadores. Tal equívoco pode gerar diferenças consideráveis entre a carga real de cada servidor e a carga estimada pelo algoritmo de balanceamento. Uma célula com 100 avatares esparsamente distribuídos no ambiente virtual teria um peso muito menor que uma célula onde outros 100 avatares estivessem todos próximos uns dos outros e interagindo entre si.

Outra questão que foi deixada de lado refere-se ao overhead, tanto no atraso para o envio de mensagens, quanto no uso de largura de banda dos servidores, quando jogadores estão interagindo cada um conectado a um servidor diferente. Em \cite{lee2003sdl}, é considerado que os servidores estão todos em uma mesma rede local, de alta velocidade e baixo atraso, e que esse overhead é desprezível. No entanto, ao se considerar um sistema servidor geograficamente distribuído, não se pode partir desse pressuposto. Esse overhead deve ser levado em conta para qualquer que seja o algoritmo de balanceamento a ser utilizado nesse sistema.

Mais um ponto importante que não foi devidamente considerado por outros trabalhos existentes: o critério principal a ser levado em consideração em um balanceamento de carga de servidores de MMOGs é o da largura de banda, e nem tanto o poder de processamento. Diversos jogos eletrônicos incluem simulações de ambientes virtuais, de várias centenas ou milhares de entidades, como é o caso do jogo Age of Empires [TODO:ref], que são efetuadas sem problemas nos computadores pessoais de hoje em dia. No entanto, se esse jogo fosse multijogador e cada uma dessas mesmas entidades fosse controlada por um jogador conectado em rede aos outros jogadores, muito provavelmente seria gerado um tráfego que dificilmente seria suportado por uma conexão doméstica[TODO:ref].

Além disso, a largura de banda de envio, ou \emph{upload}, deve ser levada em conta, muito mais do que a de recebimento, ou \emph{download}. Isso ocorre por duas razões: em primeiro lugar, o uso da banda de recebimento por cada nodo servidor cresce linearmente com o número de jogadores a ele conectados, enquanto que o uso da banda de envio pode ter um crescimento quadrático, saturando-a muito mais rapidamente; segundo, as conexões domésticas -- pretende-se obter recursos para formar o sistema servidor dos próprios jogadores, pelo menos em parte -- geralmente possuem uma banda de envio pequena em comparação com a banda de recebimento.

Há questões de menor importância, mas que também devem ser levadas em consideração e que não foram consideradas em outros trabalhos. Uma delas é que dificilmente o sistema servidor será homogêneo -- considerando-se que é baseado em recursos voluntários. Portanto, não se pode assumir que os servidores tenham a mesma quantidade de recursos. Outro problema, específico do algoritmo proposto por \cite{lee2003sdl}, o critério de alocar para cada servidor uma carga equivalente a 90\% da sua capacidade, com o fim de evitar rebalanceamentos constantes, é fraco. Não há garantias de que o sistema servidor terá 11,11\% a mais de capacidade total do que o necessário. Muito pelo contrário, ele deve se adaptar a situações de sobrecarga generalizada. Além disso, o critério de parada é fraco pois o algoritmo não termina se o sistema todo estiver com carga acima de 90\% da sua capacidade, ou se o servidor sobrecarregado não tiver vizinhos disponíveis para balanceamento.

Porém, uma idéia importante que foi sugerida é a do uso de grafos para representar o ambiente virtual, e usar algoritmos de particionamento de grafo para realizar o balanceamento de carga. Na seção seguinte, será feita uma breve introdução a respeito desse princípio, que é a base do esquema de balanceamento de carga aqui proposto.

%revisar rapidamente os trabalhos existentes, apontando o que falta e mostrando que foi feito nesta dissertação
%FALAR MAL:
%sem detalhes do algoritmo de balanceamento de grafos escolhido, nem faz uso do edge-cut (isso vai pra minha solução proposta)
%o peso é a quantidade de jogadores
%servidores com mesmo peso
%a capacidade do servidor é o poder de processamento, ao invés da banda
%considera-se que os servidores estejam conectados através de uma rede de alta velocidade. (oh de bal. e oh de intercomunicação)
%a cada servidor é alocado 90% de sua capacidade. Isso pode não funcionar. Critério ruim.
%possível loop infinito, se não houverem vizinhos capazes ou disponíveis. Outro critério ruim.

%[TODO:isso não deveria ir para os "trabalhos relacionados" deste capítulo?]
\subsection{Uso de grafos em distribuição de tarefas [TODO:rename]}
%***princípio do uso de particionamento de grafos para distribuição de tarefas com corte de aresta tão pequeno quanto possível -> tarefas mais independentes
%    ggp, gggp, spectral bissection, kernighan-lin
%falar do kernighan-lin e a dependência entre tarefas
%as tarefas são geralmente estáticas..

Um problema clássico de alocação de tarefas em sistemas distribuídos é o da dependência entre tarefas [TODO:refsDEdistGRAPH]. Tarefas dependentes entre si fazem com que os processadores nos quais elas estão sendo executadas tenham que se comunicar para que o processamento possa continuar. Isso gera dois problemas principais: em primeiro lugar, o processamento como um todo é atrasado por causa do tempo de espera de cada transmissão e recebimento de mensagens -- supondo que a comunicação entre os processos seja por meio de mensagens, como é o caso do MPI [TODO:ref].

Para resolver este problema, são utilizados grafos, da seguinte maneira: o conjunto de tarefas a realizar é mapeado em um grafo com pesos. Cada vértice representa uma tarefa e cada aresta representa a comunicação entre as tarefas. O peso de cada vértice representa o custo de processamento e o peso da aresta a carga de comunicação. Para fazer a distribuição, é feito um particionamento do grafo gerado. Cada partição terá um conjunto de tarefas que serão executadas no mesmo nodo e, conseqüentemente, o atraso de comunicação entre elas será relativamente pequeno [TODO:refbli]. No entanto, as arestas do grafo que ligam partições diferentes representam comunicação entre diferentes nodos. A Figura [TODO:ref] ilustra essa situação.

[TODO:figura do grafo de tarefas e dependências, assim como particionamento com corte de arestas e diferentes particionamentos levando a diferentes cortes de aresta]

Os algoritmos de particionamento do grafo de tarefas, geralmente, buscam atingir dois objetivos: gerar partições de peso aproximadamente igual, ou seja, cada nodo terá uma carga computacional semelhante à dos outros; e minimizar o corte de aresta, ou seja, fazer com que a dependência entre os conjuntos de tarefas seja a menor possível, reduzindo a comunicação entre os nodos de processamento. Por corte de aresta, entende-se o somatório dos pesos de todas as arestas que ligam vértices que estão em partições diferentes. [TODO:reffig]

O problema de particionamento de grafos é NP-completo [TODO:ref]. Contudo, já foi feita bastante pesquisa nessa área, resultando em heurísticas que obtêm boas soluções, muitas vezes se aproximando de valores ótimos [TODO:ref]. Uma das heurísticas mais conhecidas é a de Kernighan e Lin \cite{kernighan1970ehp}, que tem como objetivo, partindo de duas partições iniciais quaisquer, chegar a duas partições com peso semelhante e corte de aresta reduzido. O algoritmo de Fiduccia e Mattheyses \cite{fiduccia1982lth} incrementa a solução de Kernighan e Lin, generalizando-a para hipergrafos, além de permitir que cada partição tenha uma fração diferente do peso total do hipergrafo.

Existem outros algoritmos mais recentes, como os baseados em divisão espectral [TODO:ref-33-e-20-karypisirreggraphs]. Este é computacionalmente caro, por envolver complexos de álgebra linear, precisando autovetor associado ao menor autovalor da matrix laplaciana associada ao grafo [TODO:ref]. No entanto, o particionamento resultante é considerado excelente para uma vasta gama de problemas [TODO:ref]. Existe também a abordagem em vários níveis [TODO:citemultilevel], através da simplifação do grafo por meio de contração dos mesmos e sobreposição das arestas correspondentes. Com o grafo mais simples, é aplicado algum algoritmo de particionamente e então ele se desdobra, já particionado, até o grafo original. Eventualmente, refinamentos no particionamento podem ser necessários. Esta última técnica é especialmente útil em grafos com grande número de vértices, na ordem de centenas a milhares, ou mais. Na figura [TODO:ref] é ilustrado esse particionamento em vários níveis.

[TODO:figura do multilevel]

Contudo, MMOGs são geralmente aplicações de tempo-real, além de a carga imposta sobre os servidores mudar constantemente em tempo de execução. Por esse motivo, o algoritmo de particionamento utilizado deve ser rápido, tornando inviável o uso da divisão espectral. É proposto neste trabalho utilizar um algoritmo guloso, mais simples, definido em [TODO:aOUTRArefdekarypis], que pode não atingir soluções tão boas quanto as da divisão espectral, porém é consideravelmente mais rápido. Além disso, o custo para encontrar uma solução muito próxima do ótimo não se justifica no contexto de MMOGs, pelo fato dos pesos mudarem constantemente, precisando de um novo particionamento em relativamente pouco tempo. Já quanto ao particionamento em vários níveis, seu uso não foi considerado necessário pois o número de vértices do grafo que representará o ambiente virtual é relativamente pequeno.

%TODO:ver esse "definições e parametros"
Nas próximas seções, será apresentada a solução proposta neste trabalho para balanceamento de carga, começando pelas definições e parâmetros utilizados, assim como será descrito como o problema foi mapeado para grafos e quais os objetivos e critérios do esquema proposto.
%even
%uneven

\subsection{Definições e mapeamento para grafo}

Como já foi dito, será utilizada a idéia de mapear o ambiente virtual em um grafo, que será então particionado para dividir a carga do jogo entre os diferentes servidores. Para isso, é necessário primeiramente definir o que são vértices, arestas, pesos e partições no grafo que representa o mundo do jogo, além de outros conceitos que serão utilizados ao longo do texto.

%TODO:definir um por um em detalhes, depois enumerá-los no parágrafo acima ^ para o leitor não se perder

\begin{itemize}
	\item \textbf{Servidor}: aqui, servidor é definido como sendo um nodo pertencente ao sistema distribuído que servirá o jogo. A cada servidor, pode ser atribuída uma única região;
	\item \textbf{Capacidade do servidor}: a capacidade do servidor, $p(S)$, é um valor numérico proporcional à largura de banda de envio do servidor, que será um dos critérios para o algoritmo de balanceamento de carga utilizado;
	\item \textbf{Capacidade do sistema}: a capacidade total do sistema, $P_{total}$, é igual a soma da capacidade dos $n$ servidores que o compõem:
	
		\begin{center}
			$\displaystyle P_{total} = \sum_{i=1}^{n} p(Si)$
		\end{center}
	
	\item \textbf{Célula}: semelhante às microcélulas do modelo de \cite{devleeschauwer2005dma}, considera-se aqui o ambiente dividido em células pequenas, com tamanho e posições fixas;
	\item \textbf{Região}:  as células se agrupam, formando o que será chamado de regiões. Geralmente essas regiões são contíguas, embora em alguns casos o subgrafo que as representa pode ser desconexo, resultando na presença de células isoladas umas das outras. Cada região é atribuída a um único servidor, sendo $s(R)$ o servidor associado à região $R$;
	%[TODO:ver se realmente precisa do item interação, ou se nao eh melhor usar relevancia mesmo]
	\item \textbf{Relevância}: a relevância de um avatar $A_i$ para outro, $A_j$, determina a freqüência das atualizações do estado de $A_i$ que o servidor deve enviar ao jogador controlando $A_j$ \cite{bezerra2008a3}. Pode ser representada pela função $R(a,b)$, onde $a$ e $b$ são avatares quaisquer;
	\item \textbf{Carga de um avatar}: a cada avatar estarão associados diversas outras entidades (aqui, considera-se apenas outros avatares) do jogo, cada uma com uma freqüência de atualizações de estado que precisarão ser enviadas para o jogador que controla aquele avatar. Assim sendo, para cada avatar $A$, a sua carga individual -- ou banda de envio que o servidor utilizará para enviar a seu jogador atualizações de estado -- $w_a(A)$ dependerá de quais outras entidades lhe são relevantes, e o quanto. Seja $\{A_1, A_2, ..., A_t\}$ o conjunto de todos os avatares presentes no ambiente virtual, temos:
	
		\begin{center}
			$\displaystyle w_a(A) = \sum_{i=1}^{t} R(A,Ai)$
		\end{center}
		
		Seja o servidor $S$ aquele ao qual está conectado o jogador $P$ que controla o avatar $A$. Seré $S$ quem deverá enviar a $P$ atualizações de estado de qualquer outro avatar, independente de onde esteja. Se $A$ estiver interagindo com um avatar $A'$, cujo jogador estiver conectado a outro servidor, $S'$, este deverá primeiro enviar o estado de $A'$ para $S$, que então encaminhará para o jogador $P$.
		
	\item \textbf{Carga de uma célula}: aqui, carga total da célula (ou uso da banda de envio do servidor) será igual à soma das cargas individuais dos jogadores. Seja a célula $C$, onde estão presentes $n$ avatares $\{A_1, A_2, ..., A_n\}$, sendo que em todo o ambiente virtual existem, no total, $t$ avatares. A carga da célula, $w_c(C)$, é encontrada com o seguinte somatório:
	
		\begin{center}		
			$\displaystyle w_c(C) = \sum_{i=1}^{n} w(Ai) = \sum_{i=1}^{n} \sum_{j=1}^{t} R(A_i,A_j)$
		\end{center}
		
	\item \textbf{Carga de uma região}: a carga da região equivale à soma das cargas individuais das células que a compõem. Seja a região $R$ formada pelas células $\{C_1, C_2, ..., C_p\}$, a carga da região, $w_r(R)$, será definida por:
	
		\begin{center}
			$\displaystyle w_r(R) = \sum_{i=1}^{p} w_c(Ci)$
		\end{center}
		
		Uma região é considerada sobrecarregada quando seu peso é maior que a capacidade do servidor que a administra, ou seja, $w_r(R) > p(s(R))$;
		
	\item \textbf{Carga total do jogo}: a carga total do jogo, $W_{total}$ independe de como será feita a distribuição e será usado como parâmetro para o particionamento do ambiente virtual. Equivale à soma da carga individual de todas as células. Seja $\{C_1, C_2, ..., C_w\}$ o conjunto de todas as células em que está subdivido o mundo do jogo, temos:
	
		\begin{center}
			$\displaystyle W_{total} = \sum_{i=1}^{w} w_c(Ci)$
		\end{center}
	
	%explicar o pq da carga ser isso (upload)
	
	\item \textbf{Interação entre células}: a interação entre duas células é igual à soma de todas as interações entre pares de avatares onde cada um está situado em uma dessas células. Para tornar mais claro, sejam $C_i$ e $C_j$, $i \neq j$, duas células quaisquer. Sejam $AvSet_i$ e $AvSet_j$ os conjuntos de avatares presentes em $C_i$ e $C_j$, respectivamente, com cardinalidades $m$ e $n$. A interação entre essas células é dada por:
	
		\begin{center}
			$\displaystyle Int_c(C_i,C_j) = \sum_{i=1}^{m} \sum_{j=1}^{n} R(A_i,A_j)$,
			
			onde $A_i \in AvSet_i$ e $A_j \in AvSet_j$.
		\end{center}
	
	\item \textbf{Overhead} entre duas regiões: se houver apenas um servidor e uma região, compreendendo todo o ambiente virtual do jogo, o uso da banda de envio do servidor será proporcional à carga total do jogo. No entanto, devido à distribuição em diversos servidores, surge o problema de haver jogadores de diferentes regiões interagindo um com o outro muito próximos à fronteira entre as regiões (Figura [TODO:ref]). Por causa disso, cada atualização de estado dos avatares desses jogadores será enviada duas vezes. Para exemplificar, seja $A_i$ o avatar do jogador $P_i$, conectado ao servidor $S_i$, e $A_j$ o avatar do jogador $P_j$, conectado ao servidor $S_j$. Para que $P_i$ interaja com $P_j$, é necessário que $S_i$ envie o estado de $A_i$ ao servidor $S_j$, que então encaminha ao computador de $P_j$. O mesmo ocorre no caminho inverso. O overhead entre as regiões $R_i$ e $R_j$ é igual, portanto, à soma das interações entre pares de células onde cada uma está em uma dessas regiões. Se $R_i$ e $R_j$ possuem respectivamente $m$ e $n$ células, temos que a interação -- ou \emph{overhead} -- entre elas é dada por:
	
	  \begin{center}
			$\displaystyle Int_r(R_i,R_j) = \sum_{i=1}^{m} \sum_{j=1}^{n} Int_c(C_i,C_j)$,
			
			onde $C_i \in R_i$ e $C_j \in R_j$.
	  \end{center}
  	
  \item \textbf{Overhead Total}: o overhead total sobre o sistema servidor é calculado como a soma dos overheads entre cada par de regiões. Sendo assim, temos:

    \begin{center}
      $\displaystyle OverHead = \sum_{i} \sum_{j, j \neq i} Int_r(Ri,Rj)$
    \end{center}

\end{itemize}

[TODO:figura ilustrando a carga de uma célula/regiao]

[TODO:figura com o overhead]

Agora que os conceitos necessários para entender o esquema de balanceamento de carga proposto foram definidos, será descrito como será o mapeamento dos mesmo em um grafo com pesos, para posterior particionamento. Seja $GW =(V,E)$ um grafo que reprenta o mundo do jogo, onde $V$ é o conjunto de vértices e $E$ é o conjunto de arestas entre os vértices. A seguir são listados cada componente desse grafo e o que representam:

\begin{itemize}
	\item \textbf{Vértice}: cada vértice do grafo representa uma célula no ambiente virtual;
	\item \textbf{Aresta}: cada aresta do grafo liga dois vértices que representam células adjacentes, ou seja, que compartilham uma fronteira;
	\item \textbf{Partição}: cada partição do grafo $GW$ -- um subconjunto de vértices do grafo $GW$, mais as arestas que ligam pares de vértices nessa mesma partição -- representa uma região;
	\item \textbf{Peso do vértice}: o peso de cada vértice é igual à carga da célula que representa;
	\item \textbf{Peso da aresta}: o peso da aresta que liga dois vértices é igual à interação entre as células que os mesmos representam;
	\item \textbf{Peso da partição}: o peso da partição é igual à soma do peso de seus vértices, ou seja, o peso da região que representa;
	\item \textbf{Corte de aresta}: o corte de aresta em um particionamento é igual à soma dos pesos de todas as arestas que ligam vértices de diferentes partições. Este valor é igual à soma dos overheads entre todos os pares de regiões. Assim sendo, o corte de aresta do grafo $GW$ é igual ao overhead total sobre o sistema servidor, sendo que reduzí-lo é um dos objetivos deste esquema de balanceamento de carga.
\end{itemize}

[TODO:figura do mapeamento de cell/region para vertex/partition/edge]

O objetivo do esquema de balanceamento aqui proposto é atribuir a cada servidor uma carga proporcional à sua capacidade, reduzindo tanto quanto possível o corte de aresta do grafo que representa o ambiente virtual e, portanto, o overhead intrínseco à distribuição do jogo em vários servidores. Embora este seja um problema NP-completo [TODO:ref, de novo?], serão utilizadas heurísticas eficientes para reduzir esse problema. Nas seções a seguir serão apresentados alguns algoritmos propostos neste trabalho.



%arestas assimétricas/grafo orientado (acochambrar ou definir de maneira melhor isto?)
%critérios devem ser definidos com cuidado
%calculo do load, baseado em pares de interações
%macrocélula := região;
%definições de: vértice, aresta (o que é comunicação entre servidores, como é feita e o porquê), partição, weight, overhead e load (weight + overhead)
%\subsubsection{Uso de gerenciamento de interesse}
%uso do IM para definir os pesos das arestas
%[TODO:otimização do IM com células vizinhas]
%granularidade grossa+fina (otimizada) no ger. interesse
%definição do formato das células, vantagens e desvantagens (quadrado, hexagono, pentagono, etc...) - tessellation graph degree
%definir/definição de interação



\subsection{Algoritmos propostos}

Considera-se que uma divisão inicial do ambiente virtual já foi feita. Deverá então ser verificado periodicamente se houve um desbalanceamento e disparar o algoritmo. Embora o overhead resultante da distribuição do ambiente virtual faça parte da carga imposta aos servidores, não há como saber qual será esse overhead sem efetuar o reparticionamento primeiro. Por esta razão, a ``carga'' a ser distribuída não incluirá este sobrecusto. Em um primeiro momento, será utilizado um algoritmo cujos parâmetros são as cargas das células e suas interações (que são os pesos dos vértices e das arestas), pois já se dispõe desses dados. Em uma segunda fase, com o grafo já particionado, será utilizado o algoritmo de Kernighan e Lin para refinar o particionamento, reduzindo o corte de aresta.

Outro aspecto importante é que cada servidor sempre tem uma região associada. O que pode ocorrer é de uma região ser vazia, ou seja, não possui células e o servidor daquela região não participar da distribuição. Isso é útil quando a capacidade total do sistema servidor é muito maior que a carga total do jogo, ou seja, $P_{total} \gg W_{total}$. Neste caso, a introdução de mais servidores aumentaria o overhead de comunicação no sistema, sem melhorar sua qualidade -- salvo quando provesse tolerância a falhas.

Os algoritmos foram desenvolvidos orientados a regiões, ao invés de servidores, para que fossem mais legíveis, levando em conta as constantes transferências de células. Além disso, torna-se mais fácil no futuro estender o modelo de balanceamento utilizado aqui para que mais de um servidor possa administrar a mesma região. Foram feitas diferentes versões do algoritmo de particionamento, que serão descritas a seguir:

\subsubsection{\ggp}

%O algoritmo de crescimento proporcional e guloso de região (\textbf{\ggp}, \emph{\ggpmeaning}) busca atribuir as cregiões mais sobrecarregadas aos servidores mais poderosos, embora seja uma heurística e não há garantias de que isso vá acontecer em 100\% dos casos. Para prover um particionamento balanceado, proporcional e com um corte de aresta já reduzido na primeira fase do balanceamento, os servidores são ordenados em ordem decrescente de capacidade. Cada um então toma uma porção do ambiente virtual, que julga-se ser a mais carregada naquele momento, até que seja atingido o limite daquele servidor, e então passa-se para o próximo da lista. Os detalhes do algoritmo estão em [TODO:refEvercomoficaessaref].

O algoritmo de crescimento proporcional e guloso de região (\textbf{\ggp}, \emph{\ggpmeaning}) busca atribuir as células mais carregadas às regiões gerenciadas pelos servidores mais poderosos. Como entrada do algoritmo, é passada uma lista das regiões a balancear.  Os detalhes estão exibidos no Algoritmo \ref{alg:ggp}.

%parametros: lista de regioes, lista de celulas que pertenciam àquelas regiões, capacidade dos servidores

%\begin{algorithm}
%%\renewcommand{\ALG}{Algoritmo}
%\caption{\ggp}
%\label{alg:ggp}
%\begin{algorithmic}
%	 \STATE $\wtodiv \leftarrow 0$
%	 \STATE $\freecap \leftarrow 0$
%	 \FOR{each region $R$ in the $\rlist$}
%	 		\STATE $\wtodiv \leftarrow \wtodiv + w_r(R)$
%	 		\STATE $\freecap \leftarrow \freecap + p(s(R))$
%	 		\STATE free all cells from $R$, temporarily
%	 \ENDFOR
%	 \STATE sort $\rlist$ in decreasing region's server power order
%	 \FOR{each region $R$ in the $\rlist$}
%	 		\STATE $\wshare \leftarrow \wtodiv \times \frac{p(s(R))}{\freecap}$
%	 		\WHILE{$w_r(R) < \wshare$}
%	 		   \IF{$R$ has a cell with a free neighbor cell}
%	 		   		\STATE $R \leftarrow R \cup \{$free neighbor cell with highest edge$\}$
%	 		   \ELSIF{there is any free cell}
%	 		   		\STATE $R \leftarrow R \cup \{$heaviest free cell$\}$
%	 		   \ELSE
%	 		   		\STATE stop. there are no more free cells.
%	 		   \ENDIF
%	 		\ENDWHILE
%	 \ENDFOR
%\end{algorithmic}
%\end{algorithm}

\begin{algorithm}
%\renewcommand{\ALG}{Algoritmo}
\caption{\ggp}
\label{alg:ggp}
\begin{algorithmic}[1]
	 \STATE $\wtodiv \leftarrow 0$ \label{alg:ggp:begingetlocalinfo}
	 \STATE $\freecap \leftarrow 0$
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wtodiv \leftarrow \wtodiv + w_r(R)$
	 		\STATE $\freecap \leftarrow \freecap + p(s(R))$
	 		\STATE libere temporariamente todas as células de $R$ \label{alg:ggp:freeallcells}
	 \ENDFOR \label{alg:ggp:endgetlocalinfo}
	 \STATE ordene a $\rlist$ em ordem decrescente de $p(s(R))$ de cada região $R$ \label{alg:ggp:sortregions}
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wshare \leftarrow \wtodiv \times \frac{p(s(R))}{\freecap}$
	 		\WHILE{$w_r(R) < \wshare$}
	 		   \IF{existe alguma célula de $R$ vizinha a uma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula vizinha livre ligada pela aresta mais pesada$\}$ \label{alg:ggp:freeneighbor}
	 		   \ELSIF{existe alguma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula livre mais pesada$\}$ \label{alg:ggp:freeheavycell}
	 		   \ELSE
	 		   		\STATE pare. não há mais células livres.
	 		   \ENDIF
	 		\ENDWHILE
	 \ENDFOR
\end{algorithmic}
\end{algorithm}

Como foi dito, é passado ao algoritmo uma lista das regiões cuja carga será rebalanceada. Isso torna possível o uso desse algoritmo tanto em âmbito local quanto em âmbito global, dependendo de quantas regiões lhe são passadas. A distribuição será feita com base nas informações que são passadas a esse algoritmo, e o critério de proporcionalidade e de balanceamento se restringe ao grupo de regiões -- e servidores a elas associados -- que lhe são dadas como entrada. As linhas de \ref{alg:ggp:begingetlocalinfo} a \ref{alg:ggp:endgetlocalinfo} têm por objetivo calcular o peso total do grupo de regiões dados e a capacidade total daquele grupo de regiões. Além disso, na linha \ref{alg:ggp:freeallcells}, as células associadas às regiões passadas ao algoritmo são liberadas para que sejam posteriormente redistribuídas.

Para prover um particionamento balanceado, proporcional e com um corte de aresta já reduzido na primeira fase do balanceamento, as regiões são ordenadas em ordem decrescente de capacidade de seus servidores (linha \ref{alg:ggp:sortregions}). O \ggp então itera através dessa lista ordenada, buscando atribuir às regiões com mais capacidade as células mais pesadas, enquanto que encarrega as regiões com servidores mais fracos de células menos carregadas.

explicar direito o algoritmo, linha por linha

explicar que o objetivo é balancear de verdade, ou seja, cada região com uma carga (ou sobrecarga) proporcional ao p(s(R))

falar dos possiveis contras (regiao pode mudar completamente de lugar. pode ser q nao seja necessario + servidores, e isso so aumentar o overhead, assim como ignora a possibilidade de haver novos servidores, livres)

%[TODO:poe o conceito de DESIRE de mudar de regiao aqui, na secao anterior (kl) ou na dos ->**algoritmos**?)

%Quando é iniciado o jogo, não qualquer particionamento 

%falar do GGP. explicar o GGP
%heterogeneidade dos servidores
%ggp/spectral/etc. -> k-l/f-m

%os servidores já dispõem da informação de arestas, pois precisam disto para ajustar a frequencia de updates? mas nao sabem dos vizinhos... mas cada vizinho envia para o outro esses dados. por isso no algoritmo.

%antes dos algoritmos, falar da redução de overhead, dos hotspots, e de todos os princípios utilizados para desenvolver a solução proposta para balanceamento

%algoritmos propostos: v1, v2, v3, v4... etc.
%kwise-kl
%kwise-repart...
%otimização com redução de overhead e de load
%tolerância a desbalanceamentos (para evitar balanceamentos sucessivos que não parem...), ou algo que resolva este problema, ou não falar deste problema
%falar de cada um dos algoritmos definidos e implementados
%balanceamento global X local
%detecção de hotspots

\section{Implementação}
%detalhes da implementação: classes, métodos, otimização do IM com células vizinhas e uso de long ao invés de float (pode não ter influenciado, mas é melhor prevenir. float causa SIM erros de precisão, especialmente na soma) e adaptação do valor de relevancia para uma escala de 0 a 100 (antes eram 0 ou 1 ...). uso de float para as frações de load e de power.
%implementação: falar TUDO que foi feito como implementação, todos os algoritmos criados



\section{Simulações e resultados}
%definir cada caso da simulação e o porquê dele, em que influenciam os parametros e o que se quer tirar de conclusão
%mostrar quais parametros foram fixados em cada caso, o seu valor e o porquê destes para destes parâmetros terem sido fixados
%resultados: analisar, falar em ganhos em %, e buscar razões para estes ganhos/perdas.





\section{Trabalhos futuros [TODO:move/rename]}
%tirar alguma coisa do plano de doutorado!!!
%o que fazer quando, mesmo pondo apenas uma célula para o servidor mais poderoso, este fica sobrecarregado -> graceful degradation (trabalhos futuros?)
%comentar a respeito do uso de uma média (ou dizer que usei, tanto faz) de load, ao invés de usar o load instantâneo para o bal. de carga.

%refs: Optimal Subset Mapping And Convergence Evaluation of Mapping Algorithms for Distributing Task Graphs on Multiprocessor SoC
%    : Mesh Partitioning for Efficient Use of Distributed Systems, 2002
%    : A survey on solution methods for task graph models, 2004