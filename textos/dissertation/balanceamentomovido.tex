%\newcommand{\ggp}{ProGReGA}
%\newcommand{\ggpmeaning}{proportional greedy region growing algorithm}
%\newcommand{\wtodiv}{weight\_to\_divide}
%\newcommand{\freecap}{free\_capacity}
%\newcommand{\rlist}{region\_list}
%\newcommand{\wshare}{weight\_share}



%por figuras para ilustrar o que se está falando
\chapter {Balanceamento de carga}
\label{cap:balanceamento}

A principal característica dos jogos maciçamente multijogador é a grande quantidade de jogadores, chegando a ter dezenas ou centenas de milhares de participantes simultaneamente \cite{schiele2007rpp}. Essa grande quantidade de jogadores interagindo entre si gera um tráfego na rede de suporte que tem crescimento quadrático em relação ao número de jogadores, no pior caso.

Quando se utiliza uma arquitetura cliente-servidor, é necessário que o servidor intermedie a comunicação entre cada par de jogadores -- supondo que se pretende prover ao jogo garantias de consistência e resistência a trapaça. Obviamente, esse servidor terá uma grande carga de comunicação e, conseqüentemente, deverá ter recursos (largura de banda disponível) proporcional à demanda do jogo. Considera-se que o principal recurso a analisar é a largura de banda disponível, pois esse é o atual gargalo para os MMOGs  \cite{feng2007wnn}.

A questão posta aqui é que, quando se faz uso de um servidor distribuído, principalmente com recursos escassos, que é a proposta deste trabalho, é necessário otimizar o uso destes recursos, atribuindo a cada servidor uma carga que ele seja capaz de suportar. Dessa forma, não importando a qual servidor cada jogador estiver conectado, sua experiência de jogo será semelhante, no que diz respeito ao tempo de resposta para suas ações e o tempo que leva para ser notificado de ações de outros jogadores, assim como de mudanças de estado no ambiente virtual do jogo.

Uma idéia inicial poderia ser a de distribuir os jogadores entre servidores, de maneira que o número de jogadores em cada servidor fosse proporcional à largura de banda daquele servidor. No entanto, essa distribuição não funcionaria, pelo fato de que a carga causada pelos jogadores depende também do quanto os jogadores estão interagindo entre si. Por exemplo, se os avatares de dois jogadores estiverem muito distantes um do outro, provavelmente não haverá interação entre eles e, portanto, o servidor precisará apenas atualizar cada um a respeito de suas próprias ações. No entanto, se estes avatares estiverem próximos, cada jogador deverá ser atualizado não apenas a respeito do resultado de suas próprias ações, como também das ações do outro jogador.

Percebe-se, então, que quando os avatares estão distantes uns dos outros, o tráfego cresce linearmente com o número de jogadores (Figura \ref{fig:playersdistant}). Porém, se eles estão próximos uns dos outros, o tráfego cresce quadraticamente (Figura \ref{fig:playersclose}). Por fim, ambas as funções de crescimento do número de mensagens podem estar presentes no mesmo jogo se, em alguns lugares do ambiente virtual, os avatares estiverem próximos e, em outros lugares, eles estiverem distantes.

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{images/playersdistant}
 \caption{Crescimento linear do tráfego com avatares distantes}
 \label{fig:playersdistant}
\end{figure}

Essa característica de localidade, no que diz respeito à distribuição dos avatares no ambiente virtual, está presente na grande maioria dos jogos multijogador. Existem algumas exceções, como GuildWars \cite{guildwars}, em que apenas grupos com um número limitado de jogadores podem iniciar uma partida. Este tipo de jogo é baseado no modelo de instâncias, onde todos os avatares dos jogadores se encontram em um espaço social, de interação limitada, menos dinâmica e, portanto, com tráfego de rede algumas ordens de grandeza menor \cite{vilanova2008psm}. Quando pretende-se iniciar uma partida ``real'', os jogadores requisitam ao servidor que seja criado um grupo de ação. Dessa forma, impede-se que um número teoricamente ilimitado de jogadores interajam entre si, sobrecarregando o servidor.

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{images/playersclose}
 \caption{Crescimento quadrático do tráfego com avatares próximos}
 \label{fig:playersclose}
\end{figure}

Normalmente, porém, os jogadores podem mover seus avatares livremente através do mundo do jogo. Isso torna possível a formação de pontos de interesse -- também conhecidos como \emph{hotspots} \cite{ahmed2008mol} -- ao redor dos quais os jogadores se concentram mais do que em outras regiões do ambiente virtual (Figura \ref{fig:avatarsdistribution}). Aliás, muitos jogos de RPG online maciçamente multijogador não só permitem como também estimulam, até certo ponto, a formação destes pontos de interesse. Nestes mundos dos MMORPGs, existem cidades inteiras, onde os jogadores se encontram para conversar, trocar mercadorias virtuais do jogo e/ou duelar, assim como existem também zonas desérticas, sem muitos atrativos para os jogadores, e onde o número de avatares presentes é relativamente pequeno, se comparado com outros lugares no jogo.

\begin{figure}
  \centering
  \includegraphics[width=1.0\linewidth]{images/avatarsdistribution}
  \caption{Distribuição de avatares com e sem a presença de pontos de interesse}
  \label{fig:avatarsdistribution}
\end{figure}


Por esta razão, não é suficiente apenas dividir os jogadores entre os servidores, mesmo que proporcionalmente aos recursos de cada um destes. Em primeiro lugar, em alguns casos o uso de largura de banda do servidor é quadrático ao número de jogadores, enquanto é linear em outros. Essa razão por si só já é suficiente para buscar outro critério para o balanceamento de carga. Além disso, surge outra questão importante: a existência de pontos de interesse. Esta última característica motiva à criação de um esquema de balanceamento de carga para jogos que impeça que a presença de hotspots degrade a qualidade do jogo além do tolerável.


%\section{Introdução (nao precisa por "introdução"}
%dinamica dos avatares
%heterogeneidade dos servidores
%necessidade de bal. de carga


%\section{Trabalhos relacionados}
%micro/macro-cell
%esquemas já propostos (ahmed, lee, /*devlechauer*/)
%o que falta em cada um

%Como foi dito, quando existe um número considerável de avatares em um mesmo ponto de interesse, é gerado um tráfego proporcional ao quadrado do número de avatares ali presentes. Também foi mostrado que os servidores recebem as ações enviadas pelos jogadores, calculam seu resultado e o enviam para todos os jogadores interessados, que são, geralmente, aqueles cujos avatares estiverem próximos do avatar do primeiro jogador.


\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{images/overheadgeneration}
 \caption{Overhead causado pela interação de jogadores em diferentes servidores}
 \label{fig:overheadgeneration}
\end{figure}

Outra questão é que se os jogadores em um mesmo ponto de interesse forem divididos entre diferentes servidores, cada um destes precisará não apenas enviar o estado do mundo resultante das ações para os jogadores conectados a ele, como também deverá enviá-lo para o servidor ao qual os outros jogadores estão conectados. Este, por sua vez, encaminhará este resultado para seus jogadores. Percebe-se, então, que cada estado deverá ser enviado duas vezes, para cada par de jogadores que se comunicam através de servidores diferentes (Figura \ref{fig:overheadgeneration}). Esse overhead não apenas causa o desperdício de recursos dos servidores, como também aumenta o atraso para atualização de estado das réplicas do jogo nas máquinas dos jogadores. Isto faz com que o tempo entre o envio de uma ação por um jogador conectado a um servidor e o recebimento do estado resultante por outro jogador, conectado a outro servidor, seja maior, prejudicando a interação entre eles.

Assim sendo, jogadores que estão interagindo entre si devem, idealmente, estar conectados ao mesmo servidor. Contudo, é possível que todos os jogadores estejam ligados entre si através de relações transitivas de interação. Por exemplo, dois avatares, de dois jogadores diferentes, podem estar distantes um do outro, porém ambos interagindo com um terceiro avatar, entre os dois (Figura \ref{fig:alllinked}). Contudo, ainda assim será necessário dividí-los entre servidores. A questão é quanto a quais pares de jogadores estarão divididos em servidores diferentes. É necessário, portanto, decidir um critério para agrupar jogadores em um mesmo servidor.

\begin{figure}
 \centering
 \includegraphics[width=0.6\textwidth]{images/alllinked}
 \caption{Dependência transitiva entre os avatares}
 \label{fig:alllinked}
\end{figure}



%2
%\section{Padrão de movimentação do usuário}
%[TODO:usar no meu modelo de movimentação. incrementar para explicar o meu]
%Este artigo também propõe um modelo de movimentação de usuário, que baseia-se no \emph{Random Waypoint Mobility Model}, que é extensivamente utilizado para avaliação de performance em redes sem fio ad-hoc. Usuários estão aleatoriamente distribuídos no ambiente virtual. Eles têm suas próprias localizações de destino traçadas, que são escolhidas aleatoriamente no mundo virtual. A cada passo t no tempo, cada usuário se move em direção ao seu destino através de uma linha reta com velocidade escolhida aleatoriamente entre 0 e max\_speed. A velocidade máxima dos usuários, max\_speed, é escolhida de forma que um usuário possa ir da esquerda para a direita do ambiente virtual em 100 passos de tempo. Por exemplo, se o tamanho do ambiente virtual é de $500x500(m^{2})$, a velocidade máxima dos usuários é de 500/100 = 5 (m/passo de tempo). Quando um usuário chega à sua posição de destino, ele começa a se mover novamente de acordo com a mesma regra. Figura \ref{fig:lee3}(a) mostra a distribuição inicial de usuários no ambiente virtual no instante t=0 e a Figura \ref{fig:lee3}(b) mostra a distribuição de usuários no instante t=100. A distribuição de usuários mostrada nas figuras está de acordo com os resultados da distribuição espacial do \emph{Random Waypoint Mobility Model}: os usuários tendem a se aglomerar na área central, ao invés da área das bordas.

%\begin{figure}
% \centering
% \includegraphics[width=1.0\textwidth]{images/LEE_mobility.jpg}
% \caption{Distribuição dos usuários com o modelo de movimentação proposto}
% \label{fig:lee3}
%\end{figure}

%3
%\section{Avaliação do trabalho}

%Tal como os trabalhos vistos anteriormente, \cite{lee2003sdl} contém uma proposta de suporte a ambientes virtuais distribuídos (onde se encaixam jogos maciçamente multijogador), baseada na distribuição do servidor do ambiente, porém, considerando uma rede local e que não há atraso significativo na comunicação entre os nodos servidores.

%De qualquer forma, este trabalho traz um algoritmo interessante para reparticionamento do ambiente virtual do jogo, de maneira dinâmica e adaptativa, buscando repartir a carga de trabalho com servidores menos sobrecarregados, seguindo uma heurística definida pelos autores.

%Além disso, é proposto um modelo simples de movimentação dos usuários, baseado no \emph{Random Waypoint Mobility Model}, que pode vir a ser útil numa futura simulação em algum trabalho futuro.





%TODO:ver esse "definições e parametros"
Nas próximas seções, será apresentada a solução proposta neste trabalho para balanceamento de carga, começando pelas definições e parâmetros utilizados, assim como será descrito como o problema foi mapeado para grafos e quais os objetivos e critérios do esquema proposto.
%even
%uneven

\section{Esquema proposto}

No capítulo \ref{cap:contexto}, foram apresentados trabalhos existentes no que se refere a balanceamento de carga em MMOGs que utilizam vários servidores para prover o suporte de rede. O esquema de balanceamento de carga proposto neste trabalho tem como base alguns dos princípos já existentes na literatura. Um deles é o da divisão do ambiente virtual em microcélulas, para posterior agrupamento em macrocélulas. Isto permite tratar de maneira relativamente simples a questão da dinâmica da movimentação dos avatares através do mundo do jogo, através da formação dos conjuntos de microcélulas, cujos elementos podem ser transferidos dinamicamente de acordo com a necessidade.

Além disso, também será utilizada a idéia de fazer o balanceamento baseado apenas em informações locais -- cada servidor, quando precisar diminuir a carga atribuída a ele, seleciona somente alguns outros servidores para participar de um rebalanceamento de carga local. Dessa forma, pode-se reduzir consideravelmente a complexidade do balanceamento, pois não será necessário que todos os servidores do jogo troquem mensagens entre si cada vez que qualquer um deles estiver desbalanceado. %[TODO: falar da vantagem de diminuir migrações também, assim que se entender/provar com resultados]

%sem detalhes do algoritmo de balanceamento de grafos escolhido, nem faz uso do edge-cut (isso vai pra minha solução proposta)
%o peso é a quantidade de jogadores
%considera-se que os servidores estejam conectados através de uma rede de alta velocidade. (oh de bal. e oh de intercomunicação)
%a capacidade do servidor é o poder de processamento, ao invés da banda

%servidores com mesmo peso
%a cada servidor é alocado 90% de sua capacidade. Isso pode não funcionar. Critério ruim.
%possível loop infinito, se não houverem vizinhos capazes ou disponíveis. Outro critério ruim.


Os trabalhos relacionados que foram descritos no capítulo \ref{cap:contexto} buscam resolver o problema do balanceamento de carga dinâmico. No entanto, carecem de diversas melhorias para que sejam mais coerentes com as necessidades dos MMOGs. Por exemplo, em momento algum foi considerado que, geralmente, o tráfego gerado pelos jogadores não é simplesmente linear, mas quadrático para cada aglomerado de jogadores. Tal equívoco pode gerar diferenças consideráveis entre a carga real de cada servidor e a carga estimada pelo algoritmo de balanceamento. Uma célula com 100 avatares esparsamente distribuídos no ambiente virtual teria um peso muito menor que uma célula onde outros 100 avatares estivessem todos próximos uns dos outros e interagindo entre si.

Outra questão que foi deixada de lado refere-se ao overhead, tanto no atraso para o envio de mensagens, quanto no uso de largura de banda dos servidores, quando jogadores estão interagindo cada um conectado a um servidor diferente. Em \cite{lee2003sdl}, é considerado que os servidores estão todos em uma mesma rede local, de alta velocidade e baixo atraso, e que esse overhead é desprezível. No entanto, ao se considerar um sistema servidor geograficamente distribuído, não se pode partir desse pressuposto. Esse overhead deve ser levado em conta para qualquer que seja o algoritmo de balanceamento a ser utilizado nesse sistema.

Mais um ponto importante que não foi devidamente considerado por outros trabalhos existentes foi que o critério principal a ser levado em consideração em um balanceamento de carga de servidores de MMOGs é o da largura de banda, e nem tanto o poder de processamento. Diversos jogos eletrônicos incluem simulações de ambientes virtuais, de várias centenas ou milhares de entidades, como é o caso do jogo Age of Empires \cite{ageofempires}, que são efetuadas sem problemas nos computadores pessoais de hoje em dia. No entanto, se esse jogo fosse multijogador e cada uma dessas mesmas entidades fosse controlada por um jogador conectado em rede aos outros jogadores, muito provavelmente seria gerado um tráfego que dificilmente seria suportado por uma conexão doméstica \cite{feng2007wnn}.

Além disso, a largura de banda de envio, ou \emph{upload}, deve ser levada em conta, muito mais do que a de recebimento, ou \emph{download}. Isso ocorre por duas razões: em primeiro lugar, o uso da banda de recebimento por cada nodo servidor cresce linearmente com o número de jogadores a ele conectados, enquanto que o uso da banda de envio pode ter um crescimento quadrático, saturando-a muito mais rapidamente; segundo, as conexões domésticas -- pretende-se obter recursos para formar o sistema servidor dos próprios jogadores, pelo menos em parte -- geralmente possuem uma banda de envio pequena em comparação com a banda de recebimento.

Há questões de menor importância, mas que também devem ser levadas em consideração e que não foram consideradas em outros trabalhos. Uma delas é que dificilmente o sistema servidor será homogêneo -- considerando-se que é baseado em recursos voluntários. Portanto, não se pode assumir que os servidores tenham a mesma quantidade de recursos. Outro problema, específico do algoritmo proposto por \cite{lee2003sdl}, é que o critério de alocar para cada servidor uma carga equivalente a 90\% da sua capacidade, com o fim de evitar rebalanceamentos constantes, é fraco. Não há garantias de que o sistema servidor terá 11,11\% a mais de capacidade total do que o necessário. Muito pelo contrário, ele deve se adaptar a situações de sobrecarga generalizada. Além disso, o critério de parada é fraco pois o algoritmo não termina se o sistema todo estiver com carga acima de 90\% da sua capacidade, ou se o servidor sobrecarregado não tiver vizinhos disponíveis para balanceamento.

Porém, uma idéia importante que foi sugerida é a do uso de grafos para representar o ambiente virtual e de usar algoritmos de particionamento de grafo para realizar o balanceamento de carga. No capítulo \ref{cap:contexto}, foi feita uma introdução a respeito desse princípio, que é a base do esquema de balanceamento de carga aqui proposto. Na seção seguinte, será mostrado como um ambiente virtual de um MMOG pode ser mapeado em um grafo.

%revisar rapidamente os trabalhos existentes, apontando o que falta e mostrando que foi feito nesta dissertação
%FALAR MAL:
%sem detalhes do algoritmo de balanceamento de grafos escolhido, nem faz uso do edge-cut (isso vai pra minha solução proposta)
%o peso é a quantidade de jogadores
%servidores com mesmo peso
%a capacidade do servidor é o poder de processamento, ao invés da banda
%considera-se que os servidores estejam conectados através de uma rede de alta velocidade. (oh de bal. e oh de intercomunicação)
%a cada servidor é alocado 90% de sua capacidade. Isso pode não funcionar. Critério ruim.
%possível loop infinito, se não houverem vizinhos capazes ou disponíveis. Outro critério ruim.

\subsection{Definições e mapeamento para grafo}

Para mapear o ambiente virtual em um grafo, é necessário primeiramente definir o que são vértices, arestas, pesos e partições no grafo que representa o mundo do jogo, além de outros conceitos que serão utilizados ao longo do texto. Este grafo será então poderá ser particionado para dividir a carga do jogo entre os diferentes servidores. As definições são dada a seguir:

\begin{itemize}
	\item \textbf{Servidor}: aqui, servidor é definido como sendo um nodo pertencente ao sistema distribuído que servirá o jogo. A cada servidor, pode ser atribuída uma única região;
	\item \textbf{Capacidade do servidor}: a capacidade do servidor, $p(S)$, é um valor numérico proporcional à largura de banda de envio do servidor, que será um dos critérios para o algoritmo de balanceamento de carga utilizado;
	\item \textbf{Fração de capacidade do servidor}: dado um conjunto de servidores $Servers$ = $\{S_1, S_2, ..., S_n\}$, a fração de capacidade de um servidor $S$, $frac_p(S)$, em relação àquele conjunto, é igual à sua capacidade dividida pela soma das capacidades dos servidores do conjunto $Servers$. Tem-se:
	
		\begin{center}
			$frac_p(S) = \frac{\displaystyle p(S)}{\displaystyle\sum_{i=1}^{n} p(S_i)}$
		\end{center}
		
	\item \textbf{Capacidade do sistema}: a capacidade total do sistema, $P_{total}$, é igual a soma da capacidade dos $n$ servidores que o compõem:
	
		\begin{center}
			$\displaystyle P_{total} = \sum_{i=1}^{n} p(Si)$
		\end{center}
	
	\item \textbf{Célula}: semelhante às microcélulas do modelo de \cite{devleeschauwer2005dma}, considera-se aqui o ambiente dividido em células pequenas, com tamanho e posições fixas. Se duas células compartilham uma fronteira, elas são ditas adjacentes, ou vizinhas;
	\item \textbf{Região}:  as células se agrupam, formando o que será chamado de regiões. Geralmente essas regiões são contíguas, embora em alguns casos o subgrafo que as representa pode ser desconexo, resultando na presença de células isoladas umas das outras. Cada região é atribuída a um servidor, e apenas um, sendo $s(R)$ o servidor associado à região $R$. Poderá ser lido ao longo do texto ``capacidade da região'', o que se refere na verdade à capacidade do servidor associado àquela região, ou seja, $p(s(R))$;
	
	\item \textbf{Relevância}: a relevância de um avatar $A_j$ para outro, $A_i$, determina a freqüência das atualizações do estado de $A_j$ que o servidor deve enviar ao jogador controlando $A_i$ \cite{bezerra2008a3}. Pode ser representada pela função $R(A_i,A_j)$;

	\item \textbf{Carga de um avatar}: a cada avatar estarão associados diversas outras entidades (aqui, considera-se apenas outros avatares) do jogo, cada uma com uma freqüência de atualizações de estado que precisarão ser enviadas para o jogador que controla aquele avatar. Assim sendo, para cada avatar $A$, a sua carga individual -- ou banda de envio que o servidor utilizará para enviar a seu jogador atualizações de estado -- $w_a(A)$ dependerá de quais outras entidades lhe são relevantes, e o quanto. Seja $\{A_1, A_2, ..., A_t\}$ o conjunto de todos os avatares presentes no ambiente virtual, temos:
	
		\begin{center}
			$\displaystyle w_a(A) = \sum_{i=1}^{t} R(A,Ai)$
		\end{center}
		
		Seja o servidor $S$ aquele ao qual está conectado o jogador $P$ que controla o avatar $A$. Será $S$ a enviar para $P$ atualizações de estado de qualquer outro avatar, independente de onde esteja. Se $A$ estiver interagindo com um avatar $A'$, cujo jogador estiver conectado a outro servidor, $S'$, este deverá primeiro enviar o estado de $A'$ para $S$, que então encaminhará para o jogador $P$.
		
	\item \textbf{Carga de uma célula}: aqui, carga total da célula (ou uso da banda de envio do servidor) será igual à soma das cargas individuais dos avatares naquela célula. Seja a célula $C$, onde estão presentes $n$ avatares $\{A_1, A_2, ..., A_n\}$, sendo que em todo o ambiente virtual existem, no total, $t$ avatares. A carga da célula, $w_c(C)$, é encontrada com o seguinte somatório:
	
		\begin{center}		
			$\displaystyle w_c(C) = \sum_{i=1}^{n} w(Ai) = \sum_{i=1}^{n} \sum_{j=1}^{t} R(A_i,A_j)$
		\end{center}
		
	\item \textbf{Carga de uma região}: a carga da região equivale à soma das cargas individuais das células que a compõem. Seja a região $R$ formada pelas células $\{C_1, C_2, ..., C_p\}$, a carga da região, $w_r(R)$, será definida por:
	
		\begin{center}
			$\displaystyle w_r(R) = \sum_{i=1}^{p} w_c(Ci)$
		\end{center}
		
		\item \textbf{Fração de carga da região}: dado um conjunto de regiões $Regions$ = $\{R_1, R_2,$ $...,$ $R_n\}$, a fração de carga de uma região $R$, $frac_r(R)$, em relação àquele conjunto, é igual à sua carga dividida pela soma das cargas das regiões do conjunto $Regions$. Tem-se:
	
		\begin{center}
			$frac_r(R) = \frac{\displaystyle w_r(R)}{\displaystyle\sum_{i=1}^{n} w_r(R_i)}$
		\end{center}
		
	\item \textbf{Uso de recursos em uma região}: fração que indica o quanto da capacidade do servidor daquela região está sendo utilizada. É definido por:
	
		\begin{center}
			$u(s(R)) = \frac{\displaystyle w_r(R)}{\displaystyle p(s(R))}$	
		\end{center}
		
	\item \textbf{Carga total do jogo}: a carga total do jogo, $W_{total}$ independe de como será feita a distribuição e será usado como parâmetro para o particionamento do ambiente virtual. Equivale à soma da carga individual de todas as células. Seja $\{C_1, C_2, ..., C_w\}$ o conjunto de todas as células em que está subdivido o mundo do jogo, temos:
	
		\begin{center}
			$\displaystyle W_{total} = \sum_{i=1}^{w} w_c(Ci)$
		\end{center}
	
	%explicar o pq da carga ser isso (upload)
	
	\item \textbf{Uso total do sistema}: fração que indica o quanto de recursos do sistema como um todo está sendo utilizado. É definido por:

		\begin{center}
			$\displaystyle U_{total} = \frac{W_{total}}{P_{total}}$
		\end{center}
	
	\item \textbf{Interação entre células}: a interação entre duas células é igual à soma de todas as interações entre pares de avatares onde cada um está situado em uma dessas células. Para tornar mais claro, sejam $C_i$ e $C_j$, $i \neq j$, duas células quaisquer. Sejam $AvSet_i$ e $AvSet_j$ os conjuntos de avatares presentes em $C_i$ e $C_j$, respectivamente, com cardinalidades $m$ e $n$. A interação entre essas células é dada por:
	
		\begin{center}
			$\displaystyle Int_c(C_i,C_j) = \sum_{i=1}^{m} \sum_{j=1}^{n} R(A_i,A_j)$,
			
			onde $A_i \in AvSet_i$ e $A_j \in AvSet_j$.
		\end{center}
	
	\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{images/interactingregions}
	\caption{Interação próxima à fronteira entre regiões}
	\label{fig:interactingregions}
	\end{figure}

	\item \textbf{Overhead} entre duas regiões: se houver apenas um servidor e uma região, compreendendo todo o ambiente virtual do jogo, o uso da banda de envio do servidor será proporcional à carga total do jogo. No entanto, devido à distribuição em diversos servidores, surge o problema de haver jogadores de diferentes regiões interagindo um com o outro muito próximos à fronteira entre as regiões (Figura \ref{fig:interactingregions}). Por causa disso, cada atualização de estado dos avatares desses jogadores será enviada duas vezes. Para exemplificar, seja $A_i$ o avatar do jogador $P_i$, conectado ao servidor $S_i$, e $A_j$ o avatar do jogador $P_j$, conectado ao servidor $S_j$. Para que $P_i$ interaja com $P_j$, é necessário que $S_i$ envie o estado de $A_i$ ao servidor $S_j$, que então encaminha ao computador de $P_j$. O mesmo ocorre no caminho inverso. O overhead entre as regiões $R_i$ e $R_j$ é igual, portanto, à soma das interações entre pares de células onde cada uma está em uma dessas regiões. Se $R_i$ e $R_j$ possuem respectivamente $m$ e $n$ células, temos que a interação -- ou \emph{overhead} -- entre elas é dada por:
	
	  \begin{center}
			$\displaystyle Int_r(R_i,R_j) = \sum_{i=1}^{m} \sum_{j=1}^{n} Int_c(C_i,C_j)$,
			
			onde $C_i \in R_i$ e $C_j \in R_j$.
	  \end{center}
	  
	  O $Int_r(R_i, R_j)$ terá um valor numérico proporcional ao uso de largura de banda de $s(R_j)$ para envio de mensagens para $s(R_i)$.
  	
  \item \textbf{Overhead Total}: o overhead total sobre o sistema servidor é calculado como a soma dos overheads entre cada par de regiões. Sendo assim, temos:

    \begin{center}
      $\displaystyle OverHead = \sum_{i} \sum_{j, j \neq i} Int_r(Ri,Rj)$
    \end{center}

\end{itemize}

Agora que os conceitos necessários para entender o esquema de balanceamento de carga proposto foram definidos, será descrito como será o mapeamento dos mesmos em um grafo com pesos, para posterior particionamento. Seja $GW =(V,E)$ um grafo que reprenta o mundo do jogo, onde $V$ é o conjunto de vértices e $E$ é o conjunto de arestas entre os vértices. A seguir são listados cada componente desse grafo e o que representam:

\begin{itemize}
	\item \textbf{Vértice}: cada vértice do grafo representa uma célula no ambiente virtual;
	\item \textbf{Aresta}: cada aresta do grafo liga dois vértices que representam células adjacentes, ou seja, que compartilham uma fronteira;
	\item \textbf{Partição}: cada partição do grafo $GW$ -- um subconjunto de vértices do grafo $GW$, mais as arestas que ligam pares de vértices nessa mesma partição -- representa uma região;
	\item \textbf{Peso do vértice}: o peso de cada vértice é igual à carga da célula que representa;
	\item \textbf{Peso da aresta}: o peso da aresta que liga dois vértices é igual à interação entre as células que os mesmos representam;
	\item \textbf{Peso da partição}: o peso da partição é igual à soma do peso de seus vértices, ou seja, o peso da região que representa;
	\item \textbf{Corte de aresta}: o corte de aresta em um particionamento é igual à soma dos pesos de todas as arestas que ligam vértices de diferentes partições. Este valor é igual à soma dos overheads entre todos os pares de regiões. Assim sendo, o corte de aresta do grafo $GW$ é igual ao overhead total sobre o sistema servidor, sendo que reduzí-lo é um dos objetivos deste esquema de balanceamento de carga.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{images/mapping}
\caption{Mapeamento do ambiente virtual em um grafo}
\label{fig:mapping}
\end{figure}

A Figura \ref{fig:mapping}(a) ilustra como é feito o mapeamento de células quadradas em um grafo e a figura \ref{fig:mapping}(b) mostra como seria com células hexagonais.

O objetivo do esquema de balanceamento aqui proposto é atribuir a cada servidor uma carga proporcional à sua capacidade, reduzindo tanto quanto possível o corte de aresta do grafo que representa o ambiente virtual e, portanto, o overhead intrínseco à distribuição do jogo em vários servidores. Embora este seja um problema NP-completo \cite{feder1999cgp}, serão utilizadas heurísticas eficientes para reduzir esse problema. Nas seções a seguir serão apresentados alguns algoritmos propostos neste trabalho.



%arestas assimétricas/grafo orientado (acochambrar ou definir de maneira melhor isto?)
%critérios devem ser definidos com cuidado
%calculo do load, baseado em pares de interações
%macrocélula := região;
%definições de: vértice, aresta (o que é comunicação entre servidores, como é feita e o porquê), partição, weight, overhead e load (weight + overhead)
%\subsubsection{Uso de gerenciamento de interesse}
%uso do IM para definir os pesos das arestas
%granularidade grossa+fina (otimizada) no ger. interesse
%definição do formato das células, vantagens e desvantagens (quadrado, hexagono, pentagono, etc...) - tessellation graph degree
%definir/definição de interação



\subsection{Algoritmos propostos}
\label{sec:algprop}

Considera-se que uma divisão inicial do ambiente virtual já foi feita. Cada servidor deverá então verificar periodicamente se está sobrecarregado e disparar o algoritmo. Embora o overhead resultante da distribuição do ambiente virtual faça parte da carga imposta aos servidores, não há como saber qual será esse overhead sem efetuar o reparticionamento primeiro. Por esta razão, a ``carga'' a ser distribuída não incluirá este sobrecusto.

Quando se verifica que uma região está desbalanceada, é selecionado um grupo local de regiões, de maneira parecida com o algoritmo de Lee (capítulo \ref{cap:contexto}, seção \ref{lee:regselect}), porém com algumas mudanças (seção \ref{sec:alg:localselect}). Após essa seleção, será utilizado um algoritmo cujos parâmetros são apenas as cargas das células e suas interações (que são os pesos dos vértices e das arestas), pois estes são os dados de que se dispõe. Por último, com as cargas das regiões já balanceadas, será utilizado o algoritmo de Kernighan e Lin para refinar o particionamento, reduzindo o corte de aresta, porém mantendo o balanceamento.

O esquema proposto se divide então em três fases:

\begin{enumerate}
	\item Seleção do grupo local de regiões;
	\item Balanceamento dessas regiões, atribuindo a cada uma delas uma carga proporcional à capacidade do seu servidor;
	\item Refinamento do particionamento, reduzindo o overhead.
\end{enumerate}

%[TODO: ver se ponho opção de ter ou nao disbal tolerance, tanto aqui quanto no transfer(bfa)/overhead(kl)]
%[    : independente disso, eu posso por no grafico e na implementação "versao sem disbal tolerance X com"]
Uma decisão tomada para esse esquema de balanceamento é que uma região $R$ é considerada sobrecarregada apenas quando o uso de seus recursos é maior que o uso total do sistema, considerando também uma certa tolerância, $tol$, para evitar constantes rebalanceamentos. Assim, o servidor de $R$ inicia o balanceamento sempre que, e somente quando, \mbox{$u(s(R)) > max(1,U_{total}) \times tol$}. Dessa forma, mesmo que o sistema como um todo esteja sobrecarregado, será mantida uma qualidade de jogo semelhante nas diferentes regiões, dividindo o excedente de carga entre todos os servidores de maneira justa. O que pode ser feito quando \mbox{$U_{total} > 1$} é reduzir gradativamente a quantidade de informações enviadas a cada atualização de estado, deixando a aplicação extrapolar as lacunas com base em atualizações anteriores.
%[TODO:por vantagens e desvantagens depois]

Outro aspecto importante é que cada servidor sempre tem uma região associada. O que pode ocorrer é de uma região ser vazia, ou seja, ela não possui células e o seu servidor não participa da execução do jogo. Isso é útil quando a capacidade total do sistema servidor é muito maior que a carga total do jogo, ou seja, $P_{total} \gg W_{total}$. Neste caso, a introdução de mais servidores apenas aumentaria o overhead de comunicação no sistema, sem melhorar sua qualidade -- salvo quando provesse tolerância a falhas.

Os algoritmos foram desenvolvidos orientados a regiões, ao invés de servidores, para que fossem mais legíveis, levando em conta as constantes transferências de células no código. Além disso, torna-se mais fácil no futuro estender o modelo de balanceamento utilizado aqui para que mais de um servidor possa administrar a mesma região. Os algoritmos propostos são descritos a seguir, sendo que o da seção \ref{sec:alg:localselect} é para a fase 1; os algoritmos das seções \ref{sec:alg:ggp} a \ref{sec:alg:bfa} são opções para a fase 2; e o algoritmo da seção \ref{sec:alg:kl} é o refinamento da fase 3.

\subsubsection{Seleção local de regiões}
\label{sec:alg:localselect}

O algoritmo de seleção de regiões (Algoritmo \ref{alg:local}) tem como objetivo formar um conjunto de regiões tal que o uso médio de recursos dos servidores dessas regiões esteja abaixo de um certo limite. Partindo da região do servidor que disparou o balanceamento, as regiões vizinhas com menor uso de recursos vão sendo adicionadas. Quando o uso médio for menor que 1, ou menor que $U_{total}$ (linha \ref{alg:local:condition}), a seleção termina e a fase 2 começa, tendo como entrada o conjunto formado nesta fase. Essas duas condições se justificam porque existem duas possibilidades: $U_{total} \leq 1$ e $U_{total} > 1$.

No caso de $U_{total} \leq 1$, existe capacidade suficiente no sistema para que todos os servidores tenham um uso menor que 100\%. Assim, são adicionadas regiões ao grupo até que todos os servidores envolvidos estejam usando uma quantidade de recursos menor ou igual à que possuem. No entanto, quando $U_{total} > 1$, não há como todos os servidores estarem usando menos que 100\% de seus recursos ao mesmo tempo. Assim, considera-se suficiente que todos os servidores estejam igualmente sobrecarregados, e que algum tipo de adaptação seja feita, o que provavelmente será uma redução nas informações enviadas aos jogadores a cada atualização de estado.

Se mesmo após serem selecionadas todas as regiões vizinhas, as vizinhas das vizinhas e assim por diante, o critério não for cumprido, regiões vazias -- pertencentes a servidores ociosos até então -- serão incluídas no grupo (linha \ref{alg:local:idleserver}), pois o overhead de interação entre regiões introduzido por elas se justifica pela necessidade de mais recursos.

\begin{algorithm}
\caption{Seleção local de regiões}
\label{alg:local}
\begin{algorithmic}[1]
	 \STATE $\locgroup \leftarrow \{R\}$
	 \STATE $\wlocal \leftarrow w_r(R)$
	 \STATE $\caplocal \leftarrow p(s(R))$
	 \STATE $\avguse \leftarrow \frac{\wlocal}{\caplocal}$
	 \WHILE{$\avguse > max(1, U_{total})$} \label{alg:local:condition}
	 		\IF{há alguma região não selecionada vizinha a um dos elementos do $\locgroup$}
	 			 \STATE $R \leftarrow$ região vizinha a um dos elementos do $\locgroup$ que não foi selecionada, com o menor $u(s(R))$
	 		\ELSIF{há alguma região vazia} \label{alg:local:idleserver}
	 			 \STATE $R \leftarrow$ região vazia com o maior $p(s(R))$
	 		\ELSE
	 			 \STATE pare. não há mais regiões a selecionar.
	 		\ENDIF
	 		\STATE $\wlocal \leftarrow \wlocal + w_r(R)$
	 		\STATE $\caplocal \leftarrow \caplocal + p(s(R))$
	 		\STATE $\avguse \leftarrow \frac{\wlocal}{\caplocal}$
	 		\STATE $\locgroup \leftarrow \locgroup \cup \{R\}$
	 \ENDWHILE
	 \STATE executar a fase 2 passando $\locgroup$ como parâmetro
\end{algorithmic}
\end{algorithm}

Após terem sido selecionadas as regiões que serão rebalanceadas, uma lista com as mesmas é passada como parâmetro ao algoritmo da fase 2 que as reparticionará.

\subsubsection{\ggp} %repart
\label{sec:alg:ggp}

%O algoritmo de crescimento proporcional e guloso de região (\textbf{\ggp}, \emph{\ggpmeaning}) busca atribuir as cregiões mais sobrecarregadas aos servidores mais poderosos, embora seja uma heurística e não há garantias de que isso vá acontecer em 100\% dos casos. Para prover um particionamento balanceado, proporcional e com um corte de aresta já reduzido na primeira fase do balanceamento, os servidores são ordenados em ordem decrescente de capacidade. Cada um então toma uma porção do ambiente virtual, que julga-se ser a mais carregada naquele momento, até que seja atingido o limite daquele servidor, e então passa-se para o próximo da lista. Os detalhes do algoritmo estão em [TODO:refEvercomoficaessaref].

Uma opção para a fase 2 é o algoritmo de crescimento proporcional e guloso de região (\textbf{\ggp}, \emph{\ggpmeaning}), que busca atribuir as células mais carregadas às regiões gerenciadas pelos servidores mais poderosos. Os detalhes estão exibidos no Algoritmo \ref{alg:ggp}.

%parametros: lista de regioes, lista de celulas que pertenciam àquelas regiões, capacidade dos servidores

%\begin{algorithm}
%%\renewcommand{\ALG}{Algoritmo}
%\caption{\ggp}
%\label{alg:ggp}
%\begin{algorithmic}
%	 \STATE $\wtodiv \leftarrow 0$
%	 \STATE $\freecap \leftarrow 0$
%	 \FOR{each region $R$ in the $\rlist$}
%	 		\STATE $\wtodiv \leftarrow \wtodiv + w_r(R)$
%	 		\STATE $\freecap \leftarrow \freecap + p(s(R))$
%	 		\STATE free all cells from $R$, temporarily
%	 \ENDFOR
%	 \STATE sort $\rlist$ in decreasing region's server power order
%	 \FOR{each region $R$ in the $\rlist$}
%	 		\STATE $\wshare \leftarrow \wtodiv \times \frac{p(s(R))}{\freecap}$
%	 		\WHILE{$w_r(R) < \wshare$}
%	 		   \IF{$R$ has a cell with a free neighbor cell}
%	 		   		\STATE $R \leftarrow R \cup \{$free neighbor cell with highest edge$\}$
%	 		   \ELSIF{there is any free cell}
%	 		   		\STATE $R \leftarrow R \cup \{$heaviest free cell$\}$
%	 		   \ELSE
%	 		   		\STATE stop. there are no more free cells.
%	 		   \ENDIF
%	 		\ENDWHILE
%	 \ENDFOR
%\end{algorithmic}
%\end{algorithm}

\begin{algorithm}
\caption{\ggp}
\label{alg:ggp}
\begin{algorithmic}[1]
	 \STATE $\wtodiv \leftarrow 0$ \label{alg:ggp:begingetlocalinfo}
	 \STATE $\freecap \leftarrow 0$
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wtodiv \leftarrow \wtodiv + w_r(R)$
	 		\STATE $\freecap \leftarrow \freecap + p(s(R))$
	 		\STATE libere temporariamente todas as células de $R$ \label{alg:ggp:freeallcells}
	 \ENDFOR \label{alg:ggp:endgetlocalinfo}
	 \STATE ordene a $\rlist$ em ordem decrescente de $p(s(R))$ \label{alg:ggp:sortregions}
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wshare \leftarrow \wtodiv \times \frac{p(s(R))}{\freecap}$ \label{alg:ggp:fraction}
	 		\WHILE{$w_r(R) < \wshare$} \label{alg:ggp:whilefraction}
	 		   \IF{existe alguma célula de $R$ vizinha a uma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula vizinha livre ligada pela aresta mais pesada$\}$ \label{alg:ggp:freeneighbor}
	 		   \ELSIF{existe alguma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula livre mais pesada$\}$ \label{alg:ggp:freeheavycell}
	 		   \ELSE
	 		   		\STATE pare. não há mais células livres.
	 		   \ENDIF
	 		\ENDWHILE
	 \ENDFOR
\end{algorithmic}
\end{algorithm}

Como foi dito, é passada como parâmetro uma lista das regiões cuja carga será rebalanceada. Isso torna possível o uso desse algoritmo tanto em âmbito local quanto global, pois a lista pode conter apenas algumas das regiões do mundo do jogo. A distribuição será feita com base nas informações desse conjunto de regiões, cujas carga e capacidade totais são calculas nas linhas \ref{alg:ggp:begingetlocalinfo} a \ref{alg:ggp:endgetlocalinfo}. Para que sejam posteriormente redistribuídas, todas as células associadas a essas regiões são liberadas (linha \ref{alg:ggp:freeallcells}).

Para prover um particionamento balanceado, proporcional e com um corte de aresta já reduzido na primeira fase do balanceamento, as regiões são ordenadas em ordem decrescente de capacidade de seus servidores (linha \ref{alg:ggp:sortregions}). O \ggp\ então percorre essa lista ordenada, buscando atribuir às regiões com mais capacidade as células mais pesadas, enquanto que encarrega as regiões com servidores mais fracos de células menos carregadas.

Na linha \ref{alg:ggp:fraction}, é calculado qual a parcela de carga que cabe a cada região, considerando a carga total que está sendo dividida e a capacidade total daquelas regiões. A fração da capacidade de servidor de cada região, em relação ao conjunto de todas as regiões envolvidas no balanceamento, $\frac{p(s(R))}{\freecap}$, deve ser a mesma fração de carga que deve ser atribuída a ela. Ainda que essa carga seja maior que a capacidade do servidor, resultando em uma sobrecarga, todos os servidores estarão igualmente sobrecarregados, satisfazendo o critério de balanceamento que foi definido. A condição para o término da alocação de novas células a uma região é que a sua carga seja maior ou igual a essa parcela.

A escolha de células para incluir na região busca fazer com que cada uma das arestas mais pesadas do grafo $GW$ ligue vértices da mesma partição, reduzindo o corte de aresta e, assim, o overhead. A cada passo é dado preferência a escolher a célula livre que não apenas seja vizinha de uma célula já presente na região, mas também cuja aresta ligando-as seja a mais pesada possível. A Figura \ref{fig:ggp} mostra um exemplo dos passos do crescimento de uma região até atingir a sua parcela de carga no balanceamento.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{images/ggp}
\caption{Crescimento de uma partição (região) de acordo com o \ggp}
\label{fig:ggp}
\end{figure}



No primeiro passo do ciclo iniciado na linha \ref{alg:ggp:whilefraction}, quando a região ainda não tem célula nenhuma, o \ggp\ lhe atribui a célula livre mais pesada que houver (linha \ref{alg:ggp:freeheavycell}). O mesmo ocorre quando uma região está comprimida entre as fronteiras de outras regiões (Figura \ref{fig:compressed}), e não possui nenhum vizinho livre, precisando buscar células em outros lugares. Isso pode gerar regiões fragmentadas e possivelmente aumentar o corte de aresta do grafo que representa o ambiente virtual. No entanto, isso acontecerá com mais freqüência nos últimos passos da distribuição, quando a maior parte das células já estaria alocada em regiões. Pelo fato do algoritmo ser guloso, quando se chegasse a essa fase de sua execução, as células que ficariam isoladas seriam, provavelmente, células muito mais leves que as outras, causando pouco overhead.

No exemplo da figura \ref{fig:ggp}, há dois servidores, $S_1$ e $S_2$, sendo que $p(S_1) = 30$ e $p(S_2) = 18$. A carga total do ambiente sendo reparticionado é $W_{total} = 32$. Para que a divisão seja proporcional à capacidade dos servidores, as parcelas de carga designadas a $S_1$ e $S_2$ são de 20 e 12, respectivamente. A seleção começa pelo vértice de peso 10 (célula livre com maior carga) e a partir daí, é adicionado a cada passo o vértice ligado pela aresta mais pesada. As arestas selecionadas e os vértices que pertencem à nova partição estão destacados.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{images/compressed}
\caption{Formação de partição desconexa (região fragmentada)}
\label{fig:compressed}
\end{figure}

\subsubsection{\ggpk} %v3

Um possível efeito indesejável do algorito \ggp\ é que, ao liberar todas as células e redistribuí-las, pode ocorrer de uma ou mais regiões mudar completamente de lugar, fazendo com que vários jogadores precisem desconectar-se de um servidor e reconectar-se a outro. Para tentar reduzir a probabilidade disso acontecer, é proposto o \textbf{\ggpk} (\emph{\ggpkmeaning}). Este novo algoritmo (mostrado no Algoritmo \ref{alg:ggpk}) é semelhante ao \ggp, exceto que cada região mantém sua célula mais carregada (linhas \ref{alg:ggpk:saveheaviestcell} e \ref{alg:ggpk:getbackheaviestcell}), a partir da qual pode ser formada uma região semelhante à que se tinha anteriormente, evitando que vários jogadores precisem migrar de servidor. No entanto, ao se manter uma das células de cada região, pode-se estar impedindo que um balanceamento melhor ocorra, ou introduzindo-se overhead, se a presença daquela célula impedir que a região seja completamente contígua.

\begin{algorithm}
%\renewcommand{\ALG}{Algoritmo}
\caption{\ggpk}
\label{alg:ggpk}
\begin{algorithmic}[1]
	 \STATE $\wtodiv \leftarrow 0$
	 \STATE $\freecap \leftarrow 0$
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wtodiv \leftarrow \wtodiv + w_r(R)$
	 		\STATE $\freecap \leftarrow \freecap + p(s(R))$
	 		\STATE $c \leftarrow $ célula mais pesada de $R$ \label{alg:ggpk:saveheaviestcell}
	 		\STATE libere temporariamente todas as células de $R$
	 		\STATE $R \leftarrow R \cup \{c\}$ \label{alg:ggpk:getbackheaviestcell}
	 \ENDFOR
	 \STATE ordene a $\rlist$ em ordem decrescente de $p(s(R))$
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wshare \leftarrow \wtodiv \times \frac{p(s(R))}{\freecap}$
	 		\WHILE{$w_r(R) < \wshare$}
	 		   \IF{existe alguma célula de $R$ vizinha a uma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula vizinha livre ligada pela aresta mais pesada$\}$
	 		   \ELSIF{existe alguma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula livre mais pesada$\}$
	 		   \ELSE
	 		   		\STATE pare. não há mais células livres.
	 		   \ENDIF
	 		\ENDWHILE
	 \ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{\ggpf} %v4
%[TODO: por desvantagens em outra seção posteriores]
Outra maneira de tentar minimizar a migração de jogadores entre servidores por causa do rebalanceamento é com o \textbf{\ggpf}, ou \emph{\ggpfmeaning} (Algoritmo \ref{alg:ggpf}). Neste algoritmo, cada região vai liberando suas células em ordem crescente de carga, até que a fração de carga da região seja menor ou igual à fração de capacidade do seu servidor. Dessa forma, mantêm-se as células mais carregadas no mesmo servidor e, portanto, a maior parte dos jogadores não precisará migrar. Após isso, as células que foram liberadas vão sendo distribuídas entre as regiões com menor uso dos recursos de seu servidor (linha \ref{alg:ggpf:usageorder}). A desvantagem deste algoritmo é, tal como no \ggpk, a possibilidade de fragmentar as regiões em muitas células isoladas por causa da redistribuição das células livres, aumentando o overhead.

%  weight_to_divide = 0;
%  free_capacity = 0;
%  
%  for each region R in regionlist {
%    weight_to_divide += ...
%    free_capacity += ...
%    celllist <- lista de celulas de R em ordem decrescente de peso
%    enquanto (R !empty e frac_r(R) > frac_p(s(R)) {
%      c <- primeiro elemento de celllist;
%      remova c de R
%      remova c de celllist
%    }
%  }
%  
%  sort regionlist in increasing order of region`s server usage;
%
%  for each region R in the regionlist {
%    weight_share = weight_to_divide * p(s(R)) / free_capacity; //proportional
%    while(w_r(R) < weight_share) {
%      if R is neighbor to a free cell {
%        R = R U {highest edge free neighbor cell};
%      }
%      else if there is any free cell {
%        R = R U {heaviest free cell}
%      }
%      else break;
%    }
%  }

\begin{algorithm}
\caption{\ggpf}
\label{alg:ggpf}
\begin{algorithmic}[1]
	 \STATE $\wtodiv \leftarrow 0$
	 \STATE $\freecap \leftarrow 0$
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wtodiv \leftarrow \wtodiv + w_r(R)$
	 		\STATE $\freecap \leftarrow \freecap + p(s(R))$
	 		\STATE $\clist \leftarrow $ lista de celulas de $R$ em ordem crescente de carga
	 		\WHILE{$frac_r(R) > frac_p(s(R))$}
	 			 \STATE $C \leftarrow$ primeiro elemento de $\clist$
	 			 \STATE remova $C$ de $R$
	 			 \STATE remova $C$ de $\clist$
	 		\ENDWHILE
	 \ENDFOR
	 \STATE ordene $\rlist$ em ordem crescente de $u(s(R))$ \label{alg:ggpf:usageorder}
	 \FOR{cada região $R$ na $\rlist$}
	 		\STATE $\wshare \leftarrow \wtodiv \times \frac{p(s(R))}{\freecap}$
	 		\WHILE{$w_r(R) < \wshare$}
	 		   \IF{existe alguma célula de $R$ vizinha a uma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula vizinha livre ligada pela aresta mais pesada$\}$
	 		   \ELSIF{existe alguma célula livre}
	 		   		\STATE $R \leftarrow R \cup \{$célula livre mais pesada$\}$
	 		   \ELSE
	 		   		\STATE pare. não há mais células livres.
	 		   \ENDIF
	 		\ENDWHILE
	 \ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{\bfa} %v2
\label{sec:alg:bfa}

O \textbf{\bfa} (\emph{\bfameaning}) é proposto aqui como uma alternativa ao \ggp\ e suas variantes. O objetivo do algoritmo é verificar qual é a carga excedente em cada região e transferí-la para regiões cuja capacidade livre é a mais próxima desse valor. Isso é feito transferindo células cuja carga se aproxime mais da capacidade livre da região que as receberá, observado duas restrições: primeiro, a carga total transferida não pode ser maior que a capacidade da região de destino e, segundo, não se deve transferir uma carga maior do que o necessário para eliminar a sobrecarga. A segunda restrição se justifica porque uma maior transferência de carga provavelmente implicaria em uma maior quantidade de jogadores migrando. A exceção a essa regra seria quando uma célula está mais carregada que a outra, não por ter mais avatares, mas porque estes estão mais próximos, conferindo crescimento quadrático ao tráfego entre os jogadores. O Algoritmo \ref{alg:bfa} descreve com detalhes o funcionamento do \bfa.


\begin{algorithm}
\caption{\bfa}
\label{alg:bfa}
\begin{algorithmic}[1]

	 \FOR{cada região $R_i$ em $\rlist$}
			\STATE $\wlose \leftarrow w_r(R_i) - W_{total} \times frac_p(s(R_i))$ \label{alg:bfa:wlose}
			\STATE $\destreg \leftarrow \rlist - \{R_i\}$
			\STATE ordene $\destreg$ em ordem decrescente de $u(s(R))$ \label{alg:bfa:sort}
			\FOR{cada região $R_j$ em $\destreg$}
				 \STATE $\regcap \leftarrow frac_p(s(R_j)) \times W_{total} - w_r(R_j)$ \label{alg:bfa:freecap}
				 \STATE $\wtoreg \leftarrow min(\wlose, \regcap)$ \label{alg:bfa:min}
				 \WHILE{$\wtoreg > 0$}
				 		\IF{$R_i$ tem uma célula com carga menor ou igual a $\wtoreg$}
				 			 \STATE $C \leftarrow$ célula de $R_i$ com o peso mais próximo de $\wtoreg$, porém não maior \label{alg:bfa:bestfit}
				 			 \STATE $R_i \leftarrow R_i - \{C\}$
				 			 \STATE $R_j \leftarrow R_j \cup \{C\}$
				 			 \STATE $\wtoreg \leftarrow \wtoreg - w_c(C)$
				 			 \STATE $\wlose \leftarrow \wlose - w_c(C)$
				 		\ELSE
				 			 \STATE continue com o próximo $R_j$. \label{alg:bfa:continue}
				 		\ENDIF
				 \ENDWHILE
			\ENDFOR			
	 \ENDFOR

\end{algorithmic}
\end{algorithm}

%  for (each region R_i in reglist) {
%    weight_to_lose <- w_r(R_i) - W_{total} \times frac_p(s(R_i)) \\explicar
%    destination_regions <- reglist - {R_i}    
%    sort destination_regions in decreasing server resources' usage order \\explicar
%    for each region R_j in destination_regions {
%      region_capacity <- frac_p(s(R_j)) \times W_{total} - w_r(R_j)
%      weight_to_this_reg <- min(weight_to_lose, region_capacity) \\explicar que eh pra nao perder mais peso do que precisa, e pra nao sobrecarregar a outra regiao
%      while (weight_to_this_reg > 0) {
%        if (R_i has a cell with weight lower then weight_to_this_reg) {
%          C <- cell from R_i with weight closest to, but not greater than, weight_to_this_reg   
%          R_i <- R_i - {C}
%          R_j <- R_j U {C}
%          weight_to_this_reg <- weight_to_this_reg - w_c(C)
%          weight_to_lose <- weight_to_lose - w_c(C)
%        }
%        else {
%          no more possible transferences to this region. continue with next R_j.
%        }
%      }
%    }  
%  }

\subsubsection{Refinamento com o algoritmo \kl}
\label{sec:alg:kl}

Depois de balancear a carga entre os diferentes servidores na fase 2, cada servidor terá uma taxa de uso de seus recursos semelhante à dos outros. No entanto, a fase 2 pode ter gerado regiões fragmentadas, implicando em muitos pares de células vizinhas que não são gerenciadas pelo mesmo servidor. Isso aumenta a probabilidade de dois jogadores, cada um em uma dessas células, interagirem entre si, por estarem próximos da mesma fronteira, o que, como foi mostrado em seções anteriores, causa um desperdício de recursos do sistema servidor.

Para reduzir esse problema, é proposto aqui o uso de uma variante do algoritmo de Kernighan e Lin \cite{kernighan1970ehp}. Embora o algoritmo receba como entrada um grafo, os vértices, arestas, pesos e partições podem ser interpretados, respectivamente, como células, interações, cargas e regiões. Dado um par de regiões, o \kl\ busca pares de células que, se trocados entre essas regiões, diminuirão o overhead.

Sejam $R_A$ e $R_B$ duas regiões e $a$ uma célula tal que $a \in R_a$. A interação externa da célula $a$ é definida como $E(a) = \sum_{b \in R_B} Int_c(a,b)$ e a interação interna é definida como $I(a) = \sum_{a' \in R_A} Int_c(a,a')$. A célula $a$ está propensa a trocar de região se sua interação com $R_B$ for maior que sua interação com $R_A$, ou seja $D(a) = E(a) - I(a) > 0$. Supondo que exista uma célula $b \in R_B$, tal que $D(a) + D(b) - 2 \times Int_c(a,b) > 0$, a troca irá reduzir o overhead entre as regiões. A expressão $D(a) + D(b) - 2 \times Int_c(a,b)$ é chamada de $gain(a,b)$, pois representa o ganho (redução do overhead) ao serem trocadas $a$ e $b$ de região.

No caso de um ambiente virtual distribuído entre várias regiões -- geralmente, há mais do que duas regiões -- executa-se o \kl\ para cada par de regiões. Além disso, após cada troca deverá ser mantido o balanceamento -- caso contrário, todas as células poderiam ir para a mesma região, eliminando completamente o overhead. Considera-se que é retornado pelo algoritmo um valor de verdadeiro se foi realizada alguma troca e falso, se não foi. Ele é executado para todos os pares de regiões até que retorne um valor de falso, indicando que não há mais trocas possíveis.

A heurística proposta por Kernighan e Lin é extensamente utilizada na área de sistemas distribuídos. Portanto, o Algoritmo \ref{alg:kl} mostra apenas de que maneira o algoritmo \kl\ é chamado.


\begin{algorithm}
\caption{Uso do \kl}
\label{alg:kl}
\begin{algorithmic}[1]

	\STATE $swapped \leftarrow$ \textbf{true}
	\WHILE{$swapped =$ \textbf{true}}
		\STATE $swapped \leftarrow$ \textbf{false}
		\FOR{cada região $R_i$ em $\rlist$}
			\FOR{cada região $R_j$ em $\rlist$}
				\IF{$Kernighan$--$Lin(R_i, R_j) =$ \textbf{true}}
					\STATE $swapped \leftarrow$ \textbf{true}
				\ENDIF
			\ENDFOR
		\ENDFOR
	\ENDWHILE

\end{algorithmic}
\end{algorithm}

%[TODO:explicar o algoritmo, que se repete cada vez que troca, e que elimina cada célula que já foi trocada de região]

%[TODO:poe o conceito de DESIRE de mudar de regiao aqui, na secao anterior (kl) ou na dos ->**algoritmos**?)

%Quando é iniciado o jogo, não qualquer particionamento 

%falar do GGP. explicar o GGP
%heterogeneidade dos servidores
%ggp/spectral/etc. -> k-l/f-m

%os servidores já dispõem da informação de arestas, pois precisam disto para ajustar a frequencia de updates? mas nao sabem dos vizinhos... mas cada vizinho envia para o outro esses dados. por isso no algoritmo.

%antes dos algoritmos, falar da redução de overhead, dos hotspots, e de todos os princípios utilizados para desenvolver a solução proposta para balanceamento

%algoritmos propostos: v1, v2, v3, v4... etc.
%kwise-kl
%kwise-repart...
%otimização com redução de overhead e de load
%tolerância a desbalanceamentos (para evitar balanceamentos sucessivos que não parem...), ou algo que resolva este problema, ou não falar deste problema
%falar de cada um dos algoritmos definidos e implementados
%balanceamento global X local
%detecção de hotspots

\section{Implementação}
%detalhes da implementação: classes, métodos, otimização do IM com células vizinhas e uso de long ao invés de float (pode não ter influenciado, mas é melhor prevenir. float causa SIM erros de precisão, especialmente na soma) e adaptação do valor de relevancia para uma escala de 0 a 100 (antes eram 0 ou 1 ...). uso de float para as frações de load e de power.
%implementação: falar TUDO que foi feito como implementação, todos os algoritmos criados

Nesta seção será descrito como foi implementado o protótipo com objetivo de validar o esquema proposto, utilizando a linguagem de programação C++. Avatares, células, regiões e servidores foram modelados como classes, que se relacionavam para formar o ambiente do jogo. Além disso, foi criada uma interface gráfica para visualizar o funcionamento do protótipo, corrigir erros e interferir disparando diferentes algoritmos para verificar como funcionava cada um. As classes implementadas foram: \code{Server}, \code{Region}, \code{Cell} e \code{Avatar}, representando os servidores, regiões, células e avatares.

\subsection{A classe \codetitle{Avatar}}

A classe \code{Avatar} é a mais importante de todas, pois reproduz as ações dos jogadores, é a responsável pela carga imposta ao servidores, além de ser a base de todo o esquema de balanceamento de carga proposto. Cada objeto desta classe possui uma referência para um objeto da classe \code{Cell}, representando a célula onde ele está localizado. Além disso, ele possui duas coordenadas (\code{int posx, posy}), que representam sua posição exata no ambiente virtual. Além deste, a classe \code{Avatar} possui outros dois pares ordenandos, \code{int dirx, diry} e \code{int destx, desty}, que representam sua direção e destino atuais, inicializados com valores aleatórios quando o objeto é criado.

Em um jogo real, cada ação de um jogador é executa pelo seu avatar, permitindo-lhe interagir com o ambiente virtual e com avatares de outros jogadores. No entanto, aqui todos os avatares foram simulados utilizando o modelo de \emph{random waypoint} \cite{bettstetter2004spr}. A cada passo -- \code{void step(unsigned long delay)} --, o avatar verifica se já chegou ao destino que foi definido anteriormente (\code{distance(posx, posy, destx, desty) < MAX\_TARGET\_DIST}). Se já chegou, é definido um tempo para espera aleatória e depois é calculado o próximo destino, com uma probabilidade de escolher um dos pontos de interesse pré-definidos. Se ainda não chegou, ele incrementa sua posição, com uma velocidade variável, em direção à posição de destino:

		\code{//(...)}

    \code{int speed = rand() \% MAX\_SPEED + 1;}

    \code{incr\_y =  (desty - posy) / distance(posx, posy, destx, desty);}

    \code{incr\_x =  (destx - posx) / distance(posx, posy, destx, desty);}

    \code{posy += incr\_y * speed;}
    
    \code{posx += incr\_x * speed;}
    
    \code{//(...)}

Além de mover-se de posição (ou permanecer na mesma, se estiver em espera), o avatar verifica se ele atravessou alguma fronteira entre células. Isso é possível porque as células têm posição estática, bastando verificar se a nova posição do avatar pertence a uma célula diferente. Caso isso tenha ocorrido, ele envia mensagens, através de chamadas de método (\code{my\_cell->unsubscribe(this)} e \code{new\_cell->subscribe(this)}) para os objetos \code{Cell}  que representam sua célula antiga e sua célula nova, notificando a mudança.

Por fim, a classe \code{Avatar} implementa mais dois métodos. Um objeto \code{Avatar} invoca o método \code{int OtherRelevance(Avatar* other)} quando se quer saber o quão relevante para ele é o avatar \code{*other}. Já o método \code{long getInteraction(Cell* c)} retorna a soma das relevâncias de todos os avatares na célula  \code{*c} em relação ao avatar que o invocou. Para calcular a relevância, decidiu-se utilizar um algoritmo semelhante ao que foi proposto em \cite{bezerra2008a3}.

\subsection{A classe \codetitle{Cell}}

Cada célula tem uma posição fixa e todas as células tem o mesmo tamanho, estando dipostas em forma de grade. A classe \code{Cell} tem uma matriz estática de ponteiros do tipo \code{Cell*}, sendo que o número de colunas multiplicado pela largura de cada célula é igual à largura do ambiente virtual. Da mesma forma, o número de linhas multiplicado pelo comprimento de cada célula é igual ao comprimento do ambiente virtual (Figura \ref{fig:cellmatrix}). Dessa forma, pode-se encontrar os índices do objeto do tipo \code{Cell} na matriz \code{cellMatrix[i][j]} a partir da posição ocupada pelo avatar em tempo constante e com apenas informações locais, da seguinte forma:

\begin{center}

	$\text{\code{i}} = \left\lfloor \text{N\_COLUNAS} \times \frac{\text{\code{posx}}}{\text{LARGURA TOTAL}}\right\rfloor$ 

\end{center}
	
\begin{flushleft}
	e
\end{flushleft} 

\begin{center}	

	$\text{\code{j}} = \left\lfloor \text{N\_LINHAS} \times \frac{\text{\code{posy}}}{\text{COMPRIMENTO TOTAL}}\right\rfloor$ 

\end{center}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{images/cellmatrix}
\caption{Objetos do tipo \code{Cell} alocados em uma matriz}
\label{fig:cellmatrix}
\end{figure}

Cada objeto da classe \code{Cell} possui a lista dos avatares (\code{list<Avatar*> avatars}) presentes nela, uma referência à região que contém a célula (\code{Region* parentRegion}) e um vetor com os pesos das arestas (interações) ligando-a com as células vizinhas (\code{long edgeWeight[NUM\_NEIGH]}).

Para calcular a carga da célula, é utilizado o método \code{long getCellWeight()}, que é a soma das cargas dos avatares. Uma otimização importante desta implementação foi a definição de células cujo comprimento e largura são ambos maiores que o alcance máximo de visão dos avatares. Dessa forma, avatares que estejam a mais de uma célula de distância terão sempre relevância nula um para o outro. Assim, para se calcular a carga de um avatar, basta ter a lista de avatares das células vizinhas às daquela onde ele está situado, economizando largura de banda e tempo de processamento (Figura \ref{fig:imopt}).

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{images/imopt}
\caption{Cada avatar com interesse restrito a células vizinhas à sua}
\label{fig:imopt}
\end{figure}

A classe \code{Cell} implementa também outros métodos, que são necessários para os algoritmos descritos na seção \ref{sec:algprop}, tais como: \code{long getDesireToSwap(Region* r)}, \code{static Cell* getHighestEdgeFreeNeighbor(list<Cell*> \&cellList)} e \code{static Cell* getHeaviestFreeCell()}.

\subsection{A classe \codetitle{Region}}

Cada objeto da classe \code{Region} tem uma lista (\code{list<Cell*> cells}) de referências para as células que a compõem, além de uma lista das regiões que fazem fronteira com ela (\code{list<Region*> neighbors}) e uma referência para o objeto \code{Server} que representa seu servidor. É na classe \code{Region} que estão implementados os algoritmos que foram apresentados na seção \ref{sec:algprop}.

Para verificar se uma região está balanceada (i.e. $u(s(R)) \leq 1$ ou $u(s(R)) \leq U_{TOTAL}$), a aplicação invoca o método \code{void checkBalancing()} da classe \code{Region}. Se essa condição de balanceamento não estiver satisfeita, é iniciada a seleção local de servidores com o método \code{void startLocalBalancing()}, correspondente à fase 1 do balanceamento (seção \ref{sec:alg:localselect}). Após este método concluir a formação do grupo local de regiões, ele invoca um dos algoritmos da fase 2, que correspondem aos seguinte métodos de \code{Region}:

\code{rebalance\_progrega(list<Region*> regionsToRebalance)},

\code{rebalance\_progrega\_kh(list<Region*> regionsToRebalance)},

\code{rebalance\_progrega\_kf(list<Region*> regionsToRebalance)} e

\code{rebalance\_bfbct(list<Region*> regionsToRebalance)}, todos \code{static} e \code{void}.

Quando a chamada ao algoritmo de fase 2 termina, é invocado o método \code{static bool refineKL\_kwise(list<Region*> regionsToRefine, int passes)} que por sua vez irá invocar o método \code{static bool refineKL\_pairwise(Region* r1, Region* r2)} para cada par de regiões, tal como foi descrito na seção \ref{sec:alg:kl} a respeito do refinamento da divisão (fase 3).

\subsection{A classe \codetitle{Server}}

Cada objeto da classe \code{Server} tem como atributos principais uma referência para um objeto da classe \code{Region} e um valor inteiro (\code{long}) que representa sua capacidade. No protótipo implementado, sua única função é fornecer o valor de sua capacidade (\code{long getServerPower()}) ao objeto \code{Region} associado a cada servidor, além de fornecer o valor de $frac_p(S)$ e $P_{total}$, através dos métodos \code{double getPowerFraction()} e \code{static long getMultiserverPower()}.

\subsection{Uso de valores inteiros}

Apesar da relevância ter sido definida como um valor real entre $0$ e $1$ \cite{bezerra2008a3}, o uso de variáveis do tipo \code{float} ou \code{double} mostrou-se propício a erros por causa da precisão flutuante. A carga total do sistema é igual à soma das cargas das regiões, onde cada região tem como carga a soma das cargas das células, e a carga de cada célula é igual à soma das cargas dos avatares e, por fim, a carga de cada avatar é igual à soma das relevâncias de todos os outros avatares em relação a ele.

No entanto, ao ser feito um somatório de centenas de parcelas de precisão flutuante, as últimas parcelas do somatório têm uma probabilidade considerável de serem descartadas, pelo fato de seu valor provavelmente estar abaixo da precisão do resultado parcial. Embora existam maneiras de contornar isso, como somatório em árvore, preferiu-se definir a relevância, as cargas, as interações, a capacidade do servidor, o overhead etc. como inteiros do tipo \code{long}.

Dessa forma, evitaram-se os problemas de imprecisão, porém mantendo o código simples. O valor da relevância de um avatar em relação ao outro foi redefinido, portanto, como um valor \textbf{inteiro}, de 0 a 100, inclusive, o que pode ser considerado suficiente se for levado em conta que, tradicionalmente, há apenas dois níveis de relevância.

\section{Simulações e resultados}
%definir cada caso da simulação e o porquê dele, em que influenciam os parametros e o que se quer tirar de conclusão
%mostrar quais parametros foram fixados em cada caso, o seu valor e o porquê destes para destes parâmetros terem sido fixados
%resultados: analisar, falar em ganhos em %, e buscar razões para estes ganhos/perdas.
%gráficos
%   I: migraçãoXinstante, linhas, cada linha é um tipo de balanceamento
%	 II: migraçãoXtipo de balanceamento, barras empilhadas: barra de baixo: walk migrations; barra de cima: still migrations
% III: desvio de u(S)Xinstante
%  IV: (wtotal+overhead)X(servidor(divido em tipos de bal. carga). barras p/ cada servidor: p(s); TB1 (carga + overhead); TB2 (c+oh); ... TBn (c+oh)
%   V: overheadXinstante(linhas, cada uma um tipo de bal.)
% NÃO ENTRA, É DISPENSÁVEL E NÃO É BONITO OU SIMPLES DE FAZER (teria que ser um para cada tipo de balanceamento) -----> VI: weightXinstante (linhas: wtotal, w1, w2, ..., wnservs)


Para realizar a simulação do balanceamento de carga, foi simulado um ambiente virtual com diversos avatares que se movem segundo o modelo de \emph{random waypoint} \cite{bettstetter2004spr}. Porém, a escolha do waypoint ao qual se dirigir não foi completamente aleatória. Foram definidos três pontos de interesse, e havia uma probabilidade de o havatar escolher um desses pontos de interesses como waypoint para seu próximo movimento. O objetivo disso foi tornar a distribuição dos avatares não uniforme no ambiente virtual, pondo à prova os algoritmos da fase 2 propostos. Aqueles que levassem em conta a existência de pontos de interesse formariam as regiões com base nisso, reduzindo o overhead da distribuição.

O ambiente consistia em um espaço bidimensional, divido em 225 células, formando uma matriz de ordem 15. Nele estavam presente 750 avatares. Todas as células sempre pertenciam a alguma região, embora pudessem ser transferidas de uma para outra. Havia oito servidores ($S_1, S_2, ..., S_8$), cada um com uma região associada, sendo que cada uma podia ter de 0 a todas as 225 células. A capacidade de todos os servidores era diferente, sendo que $p(S_i) = i\times20000$. Assim o servidor $S_1$ tinha capacidade de 20000 e $S_8$, de 160000, por exemplo. Dessa forma, pôde-se testar se a distribuição estava atendendo o critério de balanceamento proporcional de carga. Cada seção de jogo simulada foi de 20 minutos. A carga total do jogo foi propositalmente ajustada de maneira que fosse maior que a capacidade total do sistema, forçando à execução do balanceamento de carga, devido à sobrecarga dos servidores.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\linewidth]{images/baloverall}
  \caption{Comparação dos algoritmos de balanceamento de carga propostos}
  \label{gra:baloverall}
\end{figure}

No gráfico da Figura \ref{gra:baloverall}, pode-se ver que todos os algoritmos propostos atendem ao critério de proporcionalidade no balanceamento de carga. No entanto, alguns deles introduzem mais overhead que os outros. A razão disso é a fragmentação que causam nas regiões. Quanto menor o número de fragmentos que têm as regiões, menor será a superfície de contato entre elas e, consequentemente, menor será o overhead total.

Observa-se que o algoritmo \ggp\ é o que menos causa overhead, pois ele foi desenvolvido justamente de forma a criar o máximo possível de regiões contíguas, buscando células ligadas pelas interações mais pesadas. O algoritmo \bfa, no entanto, foi desenvolvido com o intuito de distribuir a carga com base em uma alocação \emph{best-fit}, procurando balanceá-la tanto quanto possível, ignorando, na fase 2, a existência de interações entre células e regiões. Por esta razão, o \bfa\ foi o que mais gerou fragmentação nas regiões e, consequentemente, overhead entre os servidores.

%[TODO: arrumar a parte de grafos etc, pra nao usar mais essa notação. arrumar a seção do k-l pra unificar a terminologia. enxugar as definições]

A Figura \ref{gra:baloverhead} mostra a variação do overhead total sobre o sistema servidor, em função do tempo de jogo. Percebe-se que o overhead gerado por cada esquema de balanceamento varia relativamente pouco com o tempo, sendo o \ggp\ o que apresenta o menor overhead em qualquer instante do jogo, e o \bfa\ é o maior de todos, durante quase toda a simulação. Os algoritmos \ggpk\ e \ggpf\ se revesam com valores intermediários de overhead.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\linewidth]{images/baloverhead}
  \caption{Overhead introduzido por cada algoritmo de balanceamento ao longo da sessão de jogo}
  \label{gra:baloverhead}
\end{figure}

No entanto, a introdução de overhead não é o único critério considerado. Na Figura \ref{gra:balmigxtb} é mostrado o quanto de migrações de usuários ocorreram entre servidores durante toda a sessão de jogo simulada, para cada algoritmo utilizado na fase 2. O número de migrações foi dividido em dois: \emph{em movimento}, que ocorre quando um jogador troca de servidor porque moveu-se de uma região para outra; e \emph{em repouso}, que ocorre quando um jogador troca de servidor sem ter se movido. Isto ocorre porque a célula onde está o avatar do jogador foi transferida para outra região como resultado de um rebalanceamento da carga do jogo. Já a migração em movimento é mais provável de acontecer quando as regiões não são contíguas.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\linewidth]{images/balmigxtb}
  \caption{Migração de jogadores com avatares parados e com avatares em movimento}
  \label{gra:balmigxtb}
\end{figure}

Podemos observar que o \ggp\ é o que tem menor quantidade de migrações em movimento, justamente por suas regiões serem contíguas. No entanto, pelo fato de não tentar minimizar as transferências de células -- o \ggp\ tem como principal objetivo minimizar o overhead -- a quantidade de migrações em repouso é a maior de todos os algoritmos, e o número total de migrações é o segundo maior, sendo melhor apenas que o \bfa, que também foi o pior algoritmo neste critério. A estratégia do \ggpk\ e, mais fortemente, do \ggpf\ de manter o máximo de células possível quando é feito o rebalanceamento tem como resultado os menores números de migrações de jogadores dos algoritmos simulados.

%deviation
Outro detalhe a ser considerado é o da uniformidade de distribuição: todos os servidores devem apresentar uma taxa de uso de seus recursos o mais parecida possível, para que a distribuição seja considerada fair. Para medir essa uniformidade, foi calculado o desvio padrão, $\sigma$, do $u(S)$ de todos os servidores, para cada algoritmo simulado. A Figura \ref{gra:baldeviation} mostra a variação de $\sigma$ em função do tempo.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\linewidth]{images/baldeviation}
  \caption{Desvio padrão do uso de recurso dos servidores}
  \label{gra:baldeviation}
\end{figure}

Mesmo com os servidores apresentando a maior variação da taxa de uso de seus recursos, o \ggp\ foi o que reduziu ao máximo o uso real de recursos ($W_{total} + Overhead$) de todos os algoritmos propostos. Já a sua variante \ggpf\ reduz ao máximo as migrações dos usuários, em troca de um aumento do overhead em 48\%, em média, se comparado à versão original do algoritmo. Qual dos dois seria melhor no geral dependeria muito do jogo sendo utilizado. Em um jogo de tempo-real, usuários migrando constantemente de servidor pode introduzir atraso e prejudicar a interação entre os jogadores, sendo o \ggpf\ o mais indicado, tendo apresentado um número total de migrações 22\% menor que o \ggp. Por outro lado, pode não ser possível o uso de algum tipo de ``degradação graciosa'' para reduzir dinamicamente a qualidade do jogo, precisando economizar ao máximo seus recursos. Neste caso, o \ggp\ seria a melhor opção.

\section{Conclusões e trabalhos futuros}

Foi proposto aqui um esquema de balanceamento de carga para servidores distribuídos de MMOGs, levando em conta o uso de banda de envio dos nodos servidores. Foram considerados aspectos importantes, como o crescimento quadrático do tráfego quando os avatares estão próximos e o overhead inerente à distribuição quando jogadores conectados a servidores diferentes têm de interagir. Para o esquema, que é dividido em três fases, foram propostos diferentes algoritmos para a fase 2 (balanceamento em si), que foram o \ggp, o \ggpk, o \ggpf\ e o \bfa. Com o algoritmo \ggp, foi alcançado com sucesso o objetivo de fazer um balanceamento de carga dinâmico e proporcional, reduzindo o overhead, tendo sido o algoritmo que causou o menor overhead de todos. Com o \ggpf, conseguiu-se uma redução considerável no número de migrações de jogadores, comparado com a sua versão original e com os outros algoritmos.

Como trabalhos futuros, os algoritmos apresentados podem ser ainda mais refinados, se a carga considerada para o balanceamento for uma média da carga em um período -- nos últimos minutos, por exemplo -- ao invés do valor instantâneo. Dessa forma, seriam evitados rebalanceamentos desnecessários que seriam causados por uma carga muito oscilante.

Outro possível trabalho futuro é criar um esquema de balanceamento de carga onde não haverá mais apenas um nodo servidor, mas um grupo de nodos servidores em cada região. Neste caso, podem ser investigadas maneiras de balancear a carga do sistema, considerando essa distribuição em dois níveis. Uma idéia seria a de usar apenas réplicas, com o intuito de prover tolerância a falhas na região. A carga dentro de uma região seria redistribuída apenas quando a mesma estivesse sobrecarregada e não fosse viável reparticioná-la.

%tirar alguma coisa do plano de doutorado!!!
%o que fazer quando, mesmo pondo apenas uma célula para o servidor mais poderoso, este fica sobrecarregado -> graceful degradation (trabalhos futuros?)
%comentar a respeito do uso de uma média (ou dizer que usei, tanto faz) de load, ao invés de usar o load instantâneo para o bal. de carga.

%refs: Optimal Subset Mapping And Convergence Evaluation of Mapping Algorithms for Distributing Task Graphs on Multiprocessor SoC
%    : Mesh Partitioning for Efficient Use of Distributed Systems, 2002
%    : A survey on solution methods for task graph models, 2004
