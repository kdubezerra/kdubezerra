
\documentclass[conference]{IEEEtran}

\usepackage{graphicx}
%\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
%\usepackage{algorithmicx}
\usepackage{amsmath}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}

%\DeclareGraphicsExtensions{eps}

%\newcommand{\malg}{A$^3$}
\newcommand{\malg}{A$^3$}
\newcommand{\cridis}{critical\_distance}
\newcommand{\viewdis}{view\_distance}
\newcommand{\circleaoi}{C}
\newcommand{\circleat}{C \& A}
\newcommand{\fov}{FoV}
\newcommand{\noaoi}{None}


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{A novell interest management algorithm for distributed simulations of MMGs}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
% \author{\IEEEauthorblockN{Carlos Eduardo Benevides Bezerra}
% \IEEEauthorblockA{Federal University of Rio Grande do Sul\\
% Bento Gonçalves, 9500, Porto Alegre, RS, Brazil\\
% E-mail: carlos.bezerra@inf.ufrgs.br}
% \and
% \IEEEauthorblockN{Fábio Reis Cecin}
% \IEEEauthorblockA{Federal University of Rio Grande do Sul\\
% Bento Gonçalves, 9500, Porto Alegre, RS, Brazil\\
% E-mail: frcecin@inf.ufrgs.br}
% \and
% \IEEEauthorblockN{Cláudio Fernando Resin Geyer}
% \IEEEauthorblockA{Federal University of Rio Grande do Sul\\
% Bento Gonçalves, 9500, Porto Alegre, RS, Brazil\\
% E-mail: geyer@inf.ufrgs.br}
% }

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
\author{\IEEEauthorblockN{Carlos Eduardo B. Bezerra,
	Fábio R. Cecin,
	Cláudio F. R. Geyer}
\IEEEauthorblockA{Federal University of Rio Grande do Sul\\
	Bento Gonçalves, 9500, Porto Alegre, RS, Brazil,\\
	Email: \{carlos.bezerra, fcecin, geyer\}@inf.ufrgs.br}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}
%\boldmath
Traditionally, a central server is utilized to provide support to MMGs (massively multiplayer games), where the number of participants is in the order of tens of thousands. Much work has been done trying to create a fully peer-to-peer model to support this kind of application, in order to minimize the maintenance cost of its infrastructure, but critical questions remain. Examples of the problems relative to peer-to-peer MMG support systems are: vulnerability to cheating, overload of the upload links of the peers and difficulty to maintain consistency of the simulation among the participants. In this work, it is proposed the utilization of geographically distributed lower-cost nodes, working as a distributed server to the game. The distribution model and some related works are also presented. To address the communication cost imposed to the servers, we specify a novell refinement to the area of interest technique, significantly reducing the necessary bandwidth. Simulations have been made with ns-2, comparing different area of interest algorithms. The results show that our approach achieves the least bandwidth utilization, with a 33.10\% maximum traffic reduction and 33.58\% average traffic reduction, when compared to other area of interest algorithms.

\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
% no \IEEEPARstart
In the last years, electronic games have become very popular, specially massively multiplayer games, where the number of simultaneous players is in the order tens of thousands \cite{cecin2004fsa}. Worlf of Warcraft \cite{worldofwarcraft}, Lineage II \cite{lineage2} and Guild Wars \cite{guildwars} are successful examples.

Usually, the network support for this kind of application consists in a central server with plenty of resources (processing power and available bandwidth), which accepts connections from the clients. Each player interacts through one of these clients, which sends his actions to the server, that processes them, calculating their influence over the game, and broadcasts the action's result to every client. Due to the number of simultaneous participants that this kind of game usually has, these tasks demand a significant amount of resources from the server, which receives and processes the actions from all the players and broadcast state updates to all of them.

Recently, some alternatives to the central server approach have been researched. One of them is to distribute among the own participants the game simulation and the task to broadcast the state updates when they perform actions. Communication between them is in a peer-to-peer manner, forming a decentralized network \cite{schiele2007rpp}. This approach would be the ideal if it did not have not some critical inherent drawbacks. For example, as the player computers participate on the simulation, they need to agree on the resulting state of the game match. If this agreement does not happen, some inconsistency on the game state among the players may occur.

There is another question, concerning the number of trasmissions that each peer needs to execute. In the client-server model, each client only needs to send his actions to the server, which processes them and broadcasts the resulting game state to every player. In the peer-to-peer model, each peer becomes responsible for processing its own player's actions and send the resulting state to everyone else to whom that state change might be relevant. The problem is that we cannot assume that every client has enough bandwidth to do this. Besides, without a central server, the game becomes dependant of the peers' simulation, which can be corrupted in order to result in an invalid state which benefits a player, or even invalidate the whole game session.

Besides the peer-to-peer model, another alternative is to use a distributed server, in which nodes connected between them divide the game simulation and the state update broadcasts \cite{assiotis2006dam}. Such approach allows for the use of lower-cost computers to form the distributed server system, reducing the cost of the support infrastructure. Also, consistency maintenance becomes easier than with the peer-to-peer model, because a single server decides the simulation for its assigned portion of the world, and problems related to malicious players may be abstracted, since the servers are able to verify the simulation and detect cheating. Finally, with less bandwidth and processing power requirements for the clients, the game becomes accessible for a wider public.

%Alguns trabalhos [citações] têm proposto técnicas para reduzir a carga de processamento e comunicação associada a servidores de jogos maciçamente multijogador, sendo uma alternativa a distribuição desta carga entre diversos servidores, cada um com custo de aquisição e manutenção menor do que o de um grande servidor central. Ainda assim, com as atuais técnicas de distribuição e modelo de comunicação entre os servidores e os clientes, têm-se um alto custo para manter o sistema servidor distribuído como um todo.
However, to avoid the distributed server system maintenance cost to be the same as the central server's, it is necessary to perform some optimizations, in order to reduce the necessary bandwidth for each server node. The present work proposes an algorithm to reduce the bandwidth usage caused by the game traffic between servers and clients, through a refinement of the players' interest management technique \cite{boulanger2006cim}. The basic principle of this technique is that each participant of the game receives only state updates that are relevant to them. Simulations have been made, comparing our proposed algorithm with conventional ones, obtaining significant results.

This paper is organized as follows: in section \ref{relatedwork}, some related works with proposed distribution models are presented; in section \ref{def}, some necessary definitions are made; in section \ref{model}, we propose a distribution model to be used as basis of our approach; in section \ref{aoi}, we review some existing interest management algorithms; in section \ref{gaoi}, we present our approach in detail; in sections \ref{sim} and \ref{results}, the simulation and its results, respectively, are described and in section \ref{conclusion}, we present our final considerations.

\section{Related Work}
\label{relatedwork}
%talvez deva reduzir esta seção.

In the past few years, many works have been done trying to distribute the massively multiplayer games support. One approach is the peer-to-peer model, which has some issues concerning game state consistency among the the participating peers, vulnerability to cheating, and increased bandwidth usage by each peer. There are some proposals that try to minimize these problems. One of then is presented in \cite{schiele2007rpp}, where is suggested the division of the virtal simulated game environment in regions, and inside each region, a peer is chosen to be the region coordinator. Its function will be manage the players' interest, checking to what peers each update really needs to be sent. In this way, the peers' upload bandwidth usage is reduced. However, this usage will be still greater than with a server to perform the broadcasts. In the peer-to-peer model, each player usually must send updates to more than one other player. Besides, the chosen peer must be trustable to be the peer coordinator.

%figura

Another work focused on the peer-to-peer model \cite{iimura2004zfg} uses an approach similar to the one presented in \cite{schiele2007rpp}, but suggests, for each region of the virtual environment, the creation a ``zoned federation'' formed by peers chosen among the participants in that region. Since different nodes manage that region, and will need to agree in order to proceed the game, the simulation becomes more trustable. However, the risk of the chosen peers commit collusion cheating \cite{yan2005scc} is not eliminated. Besides, the agreement itself between the peers - that provides increased reliability - creates a fair amount of extra traffic between the participants of the federation, possibly delaying each simulation step.

%figura

A key problem in the peer-to-peer architectures, in what concerns the use of interest management, is that some peers are responsible for part of the simulation and for decide to whom each state update would interest. Assuming that there are only trustable players, the interest management technique may be useful. However, supposing that a player is malicious, he could hack his client software and avoid sending state updates to certain players, who would be in disadvantage. Consequently, the distributed server model is considered more suitable to use the interest management technique.

An example of this kind of model is described in \cite{assiotis2006dam}, where a distributed architecture for MMGs is proposed. It is also based on the division of the virtual environment in regions, each one with a server node assigned to it. The player whose avatar is situated in a region of the game world should connect to the server responsible for that region. This way, each server would group different players, based on their locality on the virtual space. To achieve consistency between the different server nodes performing the simulation, it is used the concept of locks. When a server node needs to alter the state of some entity of the game, it first needs to obtain exclusive access to that entity. To do that, it negociates with the other server nodes which might also need to make some change in the same object, and then obtains the lock. When it finishes changing the state, it releases the lock and notifies the other servers

%figura

The first major restriction in the proposal of \cite{assiotis2006dam}, however, is the assumption that all server nodes are connected with one another through a high velocity and low latency network, what cannot be assured when using lower-cost geographically distributed nodes. Another problem is that the scalability question is addressed simply via the expansion of the virtual environment area, supposing that the players will spread over it. Finally, they suggest to solve the hotspot problem through successive recursive environment partitioning, until the number of players per server is below a certain threshold. However, there is a practical limit to the repartitioning of the virtual environment, and they do not suggest what to do when this limit is reached. 

%falo de ng?

\section{Definitions}
\label{def}

%Será utilizado o termo cliente para referir-se ao computador utilizado por cada jogador para conectar-se a um dos servidores do jogo, assim como o termo servidor fará referência a cada nodo integrante do sistema distribuído que estará servindo o jogo.
It is necessary to describe the network support model on which the proposed interest management algorithm is intended to be utilized. Throughout the text, some terms will be used, and their definitions are given here:

%É necessário descrever o modelo de suporte a jogos maciçamente jogador sobre o qual pretende-se utilizar o algoritmo de gerenciamente de interesse proposto. Ao longo do texto, serão utilizados alguns termos que precisam antes ser definidos: %Define-se avatar como sendo a representação no ambiente virtual do jogador, que, através dele, interage com o mundo do jogo e com outros jogadores. Regiões são divisões do ambiente virtual, cada uma podendo conter jogadores presentes. Assumindo regiões contíguas, define-se fronteira como sendo a divisa entre duas regiões adjacentes.


\textbf{Avatar} is the player representation in the virtual environment. Through his avatar, the player interacts with the game world and with the other players. Examples of avatars are the characters in MMORPG (massively multiplayer online role-playing games) games like World of Warcraft.

\textbf{Entities} are the constituent parts of the virtual world. Examples of entities are the avatars of the players as well as avatars controlled by artificial intelligence of the server - monsters of MMORPGs, for example - and objects in the environment, such as doors, weapons and items with which avatars can interact.

\textbf{State} is the set of properties that can be observed in the various entities of the game. The overall state of the simulated world is composed of individual states of the different entities present in it.
	
The players interact with the game world through \textbf{actions}. An action is a command of the player as, for example, move your avatar for particular location in the virtual world, attacking another player, take some object available in the environment and so on. In general, actions change the state of one or more entities in the game.
 	
A \textbf{region} is a partition of the virtual environment, under the responsibility of a single server. Thus, players whose avatars are located in the same region will have its interaction improved, since their clients are connected to the same server.

The \textbf{border} between two regions is the line that divides the areas that these regions occupy. When an avatar is located near a border, the server responsible for the region beyond this border is notified about the presence of that avatar by the server where it is.

\section{Distribution Model}
\label{model}

	
This work is based on a virtual environment partitioned into regions, each managed by a server. The regions are contiguous, exploring the locality of the players' avatars. Thus, avatars next to each other will probably be located in the same region and, therefore, their clients will tend to be connected to the same server, so that their interaction is faster (Fig. \ref{partitions}). Situations in which two players interacting with each other are connected to different servers imply a higher bandwidth usage, as it is required some sort of negotiation between the servers to which the different players are connected, in order to maintain the states of simulation in both servers identical. Also, the hop count of each message between the clients of these players is increased, since there is one more intermediary.

\begin{figure}[!t]
	\centering
	%\includegraphics[width=2.5in]{max}
	\includegraphics[width=0.9\linewidth]{part}
	\caption{Distribution model}
	\label{partitions}
\end{figure}

One issue that relates to that type of partitioning of the virtual environment concerns the borders between regions. If an avatar of a client connected to a server is close to the border of a region with another, which is managed by another server, it will be necessary to have an exchange of information between these servers. This information consists of state updates of the entities that are interacting with each other despite being located in different regions. For example, let $S_A$ be the server responsible for the region $R_A$ where is located the avatar of the client $C_A$ and let be $S_B$ the server responsible for another region, $R_B$, where is located the avatar of the client $C_B$. When the avatar of $C_A$ gets close the border with $R_B$, $S_A$ sends to $S_B$ a message notifying it about the presence of that avatar near its region's border. If the avatar of $C_B$ also gets close to the border with $R_A$ and to the avatar of $C_A$, $S_B$ sends another message, notifying $S_A$. Then, the avatars of $C_A$ and $C_B$ start exchanging state updates through their servers.

Regarding the simulation of the actions performed by players whose avatars are located in different regions, it must be decided how it will be performed. As the focus of this work is not the simulation itself, but the bandwidth usage optimization through a new interest management algorithm, it was decided that the simulation will be performed by the server to which the client of that player is connected. Thus, if the player whose avatar is in region $R_i$ performs an action near the border involving entities in $R_j$, it is the server $S_i$ who will decide the outcome of these actions, forwarding only the already calculated new state to $S_j$.

This way, the details of this mechanism will not result in relevant changes to the interest management. When a player $J$, whose avatar is near the border of a region, performs actions whose results must be broadcasted to players with their avatars in other regions, the server $S$, responsible for $J$, simulates his actions, calculates the resulting state and simply sends it to the neighbor server, as if it was sending to its own clients. Similarly, when $S$ receives the resulting state of the action of a player who is connected to a neighbor server, it broadcasts the state to the clientes connected to it as if a player in its own region had executed that action.

%figura

%Cada servidor terá uma lista dos endereços e portas dos outros servidores, assim como a região a que cada um está associado. Quando um jogador deseja participar do jogo, deve conectar-se a um servidor qualquer. Se o jogador entrar com um avatar novo, é escolhida alguma região para ele começar a jogar, e o servidor a que ele se conectou irá redirecioná-lo para o servidor correto. O critério de escolha pode ser o número de jogadores em cada região, como também pode ser feita simplesmente uma seleção aleatória da região. Se já tiver jogado antes, será redirecionado para o servidor responsável pela área na qual ele parou de jogar da última vez. Desta forma, aumenta-se a probabilidade do jogador recomeçar a partida com as informações mais recentes a respeito de seu estado.

\section{Interest Management Algorithms}
\label{aoi}

%como há vários servidores, o processamento das áreas de interesse é paralelizado, também, então não é tãaao ruim calcular a distância entre cada par de avatares..
%explicar uma por uma, como funciona e o porquê.

In order to provide an identical sense of the environment among the players, each one of them must maintain a copy of the entities' states, which must be the same for everyone. The simplest way to do this is to broadcast the states of all entities to all clients. The problem of this approach is that it generates a heavy traffic between the servers and clients, preventing the game to well, as the number of participants increase. To save bandwidth, both of the players, as the servers that intermediate them, a technique known as interest management is employed. This technique reduces the number of updates that the players will receive - and send, in the case of a peer-to-peer architecture.

	
In short, the interest management technique works as follows: for every state change of each entity, it is calculated for whom it will be important. For example, if an avatar is miles away from another in the virtual environment, it is most likely that their state changes is irrelevant to each other. Thus, it is not necessary for them to exchange information on their state. This principle - locality - is used as the main criterion in the interest management algorithms.

The algorithms described in the following sections are mainly based on the euclidian distance between each avatar and all other entities in the virtual environment. This could create a scalability problem due to the processing of the distances, but a distributed architecture is assumed, where the processing can and should be parallelized. In the distribution model defined previously, each server controls a region of the map. Therefore, each one of them manages only a subset of the entities of the game, checking only the distances between each pair of them, in addition to the entities that are in a neighbouring region, close to its border.
	
In the next sections, some versions of this technique, such as circular area based and avatar's field of view based interest management, will be presented. In the section \ref{gaoi}, it is introduced the approach of attenuating the frequency of updates, and a proposed algorithm will be described in detail.

\subsection{Circular area of interest}
\label{circle}

The simplest way to execute interest management is to define a circular area, whose center is determined by the coordinates of the avatar's location in the virtual environment. After that, the euclidian distance between the avatar and every other other entity in the game world is calculated. Let $A$ be an avatar, whose area of interest is a circle of radius $rad$. If an entity $E$ is at a distance less than $rad$ from $A$, then its state updates will be relevant to $A$. $A$ will not receive state updates from entities which are at a distance greater than $rad$. Figure \ref{fcirc} illustrates this type of area of interest.

\begin{figure}[!t]
	\centering
	%\includegraphics[width=2.5in]{max}
	\includegraphics[width=0.9\linewidth]{circle}
	\caption{Circular area of interest}
	\label{fcirc}
\end{figure}

\subsection{Field of view}
\label{angle}
 	
A more refined method to manage the interests of the avatars is to take into account what each player can see. The area within which the player perceives state changes can be defined as a circular sector. This is similar to the circular area of interest described in the previous section, but takes into account that the player can only see objects that are located in front of his avatar.

%pegar isso pra mim!?... CLARO! fui eu que fiz!
	
One issue to be considered, however, is that the player will not receive state updates from entities entities which are close to his avatar, but behind it. This could cause some problems. For example, if the avatar turns 180 degrees, the player might not be able to see a particular entity that should be there, needing some time to receive its state information. This happens because, despite this entity have been near the avatar, the player did not receive its information yet because it was behind him, outside his field of view. In Figure \ref{fangle} it is illustrated an area of interest that takes into account the player's view angle.

\begin{figure}[!t]
	\centering
	%\includegraphics[width=2.5in]{max}
	\includegraphics[width=0.9\linewidth]{fov}
	\caption{Field of view based area of interest}
	\label{fangle}
\end{figure}

%algoritmo

\section{Graded Area of Interest}
%\subsection{Círculo com atenuação}
\label{gaoi}

 	
The principle behind the approach proposed here is based on the fact that the more distant an entity is from the avatar in the virtual environment, the lower its update frequency for that avatar may be. Therefore, the state updates from entities which are more distant may be received with a longer interval between them. On the other hand, if an entity is very close, it is desirable that the player receives its most recent state change information as soon as possible, to view any alterations quickly.

To achieve this objective, it is necessary to define some parameters:

\textbf{Relevance} - real value ranging from 0 to 1 inclusive, which determines how much an entity's state is relevant to an avatar.

\textbf{Update frequency} - number of state updates, received by a player from each one of the entities in the virtual environment, divided by time.

\textbf{Normal update interval} - lowest time interval between the arrival of two consecutive state updates of the same entity to a client. The normal update interval is used when the state has a relevance value of 1. Thus, it determines the maximum update frequency.

\textbf{View distance} - determines the maximum distance from which an avatar may be from the entities so its player may see them.

\textbf{Critical distance} - it is the radius of the circle around the avatar, inside which all entities have a relevance value of 1.

Before sending the state of an entity to a client, the last transmission time is checked. The next transmission is then scheduled to occur after a certain interval. If the relevance of that state is 1, the normal update interval will be used. If it is less than 1, the normal interval is divided by the relevance. For example, let the normal update interval of a game be 200 ms. If the avatar $A_i$, which just sent a state update packet to $A_j$, is at a distance from $A_i$ such that its relevance is 0.5, the next transmission will only happen after an interval of 200/0.5. So, the player controlling $A_j$ will only receive an update of $A_i$ within 400 ms. Despite this interval is still less than a half second, it represents a reduction of the state update frequecy of $A_i$ in 50\%. As they are at a greater distance from one another, and the interval was increased only by 200 ms, this variation will probably be imperceptible by the player who controls $A_j$.
  
It is important to note that the reduction of the entities' update frequency may be combined with other interest management techniques. In \cite{boulanger2006cim}, various interest management algorithms are described, and they can be further improved if the idea of different transmission intervals based on the relevance of the updates is used. 
Generally the state of each entity is classified into one of only two extremes: it is relevant or it is not relevant, ignoring the fact that there is a wide range of intermediate values. The question is how to define the relevance value for each state update. In the next sections, it will be presented two examples of algorithms which define a method to determine this value, as well as the area of interest used by each one. In section \ref{csmooth}, it is specified the proposed \malg\ algorithm, which employs, besides other principles, the update frequency attenuation. The simulations and their results are shown in sections \ref{sim} and \ref{results}, respectively.

\subsection{Circle with attenuation}
  
A simple form of using various update intervals based on the relevance value would be utilizing the circular area of interest. To obtain the relevance of an entity relative to an avatar, the value may be set to 1 when the entity is in the same position of the avatar and gradually reduce as it gets more distant, until it reaches 0 and stops decreasing no matter how more distant it gets. This is a way that, although simple, has shown a significant reduction in traffic between clients and servers. In Figure \ref{graded_circle}, it is illustrated how the area of interest would be, with entities' state update frequency attenuation for a given avatar.

\begin{figure}[!t]
	\centering
	%\includegraphics[width=2.5in]{max}
	\includegraphics[width=0.9\linewidth]{gcircle}
	\caption{Circular area of interest with update frequency attenuation}
	\label{graded_circle}
\end{figure}

%           A                   A              A 
%\subsection{Ângulo de visão com área próxima e atenuação da freqüência de atualização}
\subsection{\malg\ algorithm}
%View Angle with close area and update frequency attenuation
%V    A          C     A         U      F         A
\label{csmooth}

The interest management algorithm proposed in this article, \malg\ (view angle with close area and update frequency attenuation), takes into account three main factors:

\begin{itemize}
 \item Avatar's view angle, to determine which entities the player must be able to see because they are in front of his avatar and within the maximum view distance; 
 
 \item Close area, whose purpose is %evitar que ocorram problemas caso o jogador faça seu avatar girar ao redor do próprio eixo muito rapidamente, além de 
 improve the game quality in the space near the avatar. Its radius is the critical distance, defined previously;
 \item Update frequency attenuation.
\end{itemize}

The resulting area of interest takes then the shape of a circular sector, which represents the player's field of view. The origin of this circular sector is also the center of a smaller circle, which defines the close area of the avatar. In the close area, all entities have a relevance value of 1, so their update frequency to that avatar is set to the maximum value. This way, the most updated game state becomes available to the player in the area around his avatar, improving the interaction with entities next to it. Even if some of them are outside the player's field of view, he will be able to see them if his avatar turns rapidly to their direction. Figure \ref{fcsmooth} illustrates the area of interest which has just been defined.

As for entities that are outside the area nearby, but still within the avatar's field of view, their relevance must be calculated. It is proposed that the relevance of each entity decline gradually in accordance with the distance between it and the avatar in question. The further they are, the less frequent will be their state updates. This is possible because even if the interval update is doubled, it will most likely still be a fraction of a second, which is hardly noticeable for a player whose avatar is located at a great distance from the entity in question. Moreover, short delays between the arrival of updates of state can easily be masked by techniques of interpolation, such as dead-reckoning \cite{smed2002rna}. The algorithm \ref{smalg} defines the operation of our interest management technique.

\begin{algorithm}
\caption{Calculate relevance of entity E to avatar A}
\label{smalg}
\begin{algorithmic}
 \STATE $dist \leftarrow distance(A, E)$
 \IF{$dist \le \cridis$}
 \STATE $relevance \leftarrow 1$
 \ELSE
 \IF{A can see E in its field of view}
 \STATE $relevance \leftarrow 1 - \frac{dist - \cridis}{\viewdis - \cridis}$
 \IF{$relevance < 0$}
 \STATE $relevance \leftarrow 0$
 \ENDIF
 \ELSE
 \STATE $relevance \leftarrow 0$
 \ENDIF
 \ENDIF
\end{algorithmic}
\end{algorithm}

\begin{figure}[!t]
	\centering
	%\includegraphics[width=2.5in]{max}
	\includegraphics[width=0.9\linewidth]{a3}
	\caption{\malg\ area of interest}
	\label{fcsmooth}
\end{figure}

\section{Simulation}
\label{sim}

In order to perform the simulation of the proposed algorithm, it was first necessary to create a simulated virtual environment, with avatars present on it, because the algorithm is based on locality and view angle information. The environment consists of a two-dimensional space, which corresponds to the region managed by one of the servers. There are various avatars present, whose number varies from one simulation to another. Each one of them randomly chooses a destination point in the environment and then goes there. When it reaches its destination, it stays for a random time value, which may be zero, and then chooses a new destination to go to.

Ns-2 simulator \cite{mccanne:nsn} was used to simulate and compare the interest management algorithms described in this paper. This simulator allows the user to create code of the specific application which will be simulated. In our case, it was simulated a server which should send state updates to the client responsible for one of the avatars in the region managed by that server. Based on the location of the other avatars and on the chosen interest management algorithm, the server decided which other avatars had a relevant state to the client in question.

Through the simulations, it was obtained the server upload bandwidth usage with one client. It was not considered necessary to simulate every client connected to the server simultaneously because every one of them had the same behavior. To find the total upload bandwidth usage, we just multiply the value found in the simulation by the number of clients connected to that server. Another question is that the upload bandwidth usage by the server is much higher than download. If it receives $n$ actions, each from one of the $n$ clients connected to it, it must send, in the worst case, $O(n^2)$ state updates, because each player needs the state of the others. Therefore, it was only necessary to measure the upload traffic from the server.

%falar do svoboda e do kim??...

Some works, as \cite{yu2007nas}, \cite{kim2005tcm} and \cite{svoboda2007taa}, analyse the network traffic generated by large scale games. Based on these analysis, and adopting a conservative posture, the following parameters have been decided to be used in the simulations:

\begin{itemize}
 \item Normal update interval: 250 ms;
 \item State update packet size for one entity: 100 bytes;
 \item Duration of each simulated game session: 20 min;
 \item Virtual environment area: 750 x 750;
 \item View distance: 120;
 \item Critical distance: 40;
 \item View angle: 180°.
\end{itemize}

Several simulations were executed, in order to compare the described interest management algorithms. The number of avatars in the environment was one of the variables analyzed, to verify the scalability. The algorithms compared were the ones with circle, circle with attenuation and field of view based area of interest and the proposed algorithm, \malg. To demonstrate how each one of these reduces traffic, simulations in which no type of interest management was used - and the server sent to the client state updates of all entities in the environment - were also performed.

\section{Results}
\label{results}

The results were collected as follows: to measure the average upload bandwidth usage by the server, the sizes of all packets sent in the session were summed up and then divided by the session duration; to determine the maximum bandwidth usage by the server, it was measured, second by second, how many bytes had been sent and the highest value was selected.

In tables \ref{tab_max} and \ref{tab_avg}, the collected maximum and average upload bandwidth usage data are presented for each number of simulated avatars and interest management algorithm - circular area based (\circleaoi), circular area based with attenuated update frequency (\circleat), field of view based (\fov) and \malg\ algorithm - and it is also show how much would be the upload bandwidth usage if no technique at all was employed (\noaoi). The values presented are in bytes per second. In Figure \ref{fig_max} and Figure \ref{fig_avg}, the corresponding graphics are given.

\begin{table}[ht]
\caption{Largura de banda máxima utilizada}
\centering
  \begin{tabular}{ c | c c c c c }  
    \hline
   	Avatars & \noaoi & \circleaoi & \circleat & \fov & \malg{} \\ \hline
		25	&	9400	&	8500	&	5700	&	7100	&	4700 \\
		50	&	19300	&	17000	&	10300	&	12300	&	8100 \\
		75	&	29100	&	23600	&	16600	&	17800	&	11300 \\
		100	&	38800	&	32500	&	20500	&	23000	&	15500 \\
		125	&	48600	&	37400	&	24300	&	29500	&	19700 \\
		150	&	58300	&	47400	&	29900	&	32900	&	22700 \\
		175	&	67700	&	56100	&	34300	&	32400	&	21500 \\
		200	&	77600	&	62300	&	37500	&	41200	&	28900 \\
	\hline
  \end{tabular}
\label{tab_max}
\end{table}

\begin{table}[ht]
\caption{Largura de banda utilizada em média}
\centering
  \begin{tabular}{ c | c c c c c }  
    \hline
   	Avatars & \noaoi & \circleaoi & \circleat & \fov & \malg{} \\ \hline
		25	&	9221	&	4715	&	2759	&	2534	&	1700 \\
		50	&	18826	&	9350	&	5442	&	4949	&	3303 \\
		75	&	28432	&	13963	&	8315	&	7619	&	5137 \\
		100	&	38037	&	19324	&	11029	&	9928	&	6739 \\
		125	&	47642	&	23138	&	13871	&	12434	&	8290 \\
		150	&	57247	&	29031	&	16432	&	15085	&	10062 \\
		175	&	66853	&	34697	&	19661	&	23060	&	14250 \\
		200	&	76458	& 	38600	&	23450	&	21491	&	14413 \\
	\hline
  \end{tabular}
\label{tab_avg}
\end{table}

\begin{figure}[!t]
	\centering
	%\includegraphics[width=2.5in]{max}
	\includegraphics[width=0.9\linewidth]{max}
	\caption{Simulation Results: maximum bandwidth usage}
	\label{fig_max}
\end{figure}

\begin{figure}[!t]
	\centering
  %\includegraphics[width=2.5in]{avg}
	\includegraphics[width=0.9\linewidth]{avg}
	\caption{Simulation Results: average bandwidth usage}
	\label{fig_avg}
\end{figure}

Just by using different update frequencies with circular area based interest management, the average upload bandwidth usage by the server decreased 41.59\%. The maximum upload bandwidth usage was also reduced, decreasing 36.19\%. These values represent the average usage reduction among all different numbers of avatars, compared to the circular area of interest algorithm with no frequency update attenuation.
  
Regarding the proposed algorithm, \malg, it has been obtained an upload bandwidth usage reduction of 63.51\% and 33.58\%, compared to the circular area of interest and the field of view based algorithms, respectively. The maximum upload bandwidth usage was also reduced, decreasing 52.03\% and 33.10\%, compared to the same algorithms. Table \ref{tab_summary} shows the maximum and average bandwidth saving percentage of the \malg\ algorithm compared to the other techniques. For example, the maximum bandwidth utilization with \malg\ is 24.81\% less than with a circular area of interest based algorithm with update frequency attenuation.

\begin{table}[ht]
\caption{Bandwidth saving with \malg\ algorithm}
\centering
  \begin{tabular}{ c | c c c c }  
    \hline
   	Usage & \noaoi & \circleaoi & \circleat & \fov \\ \hline
		Maximum	&	60.10\%	&	52.03\%	&	24.81\%	&	33.10\%	\\
		Average	&	81.64\%	&	63.51\%	&	37.48\%	&	33.58\%	\\
	\hline
  \end{tabular}
\label{tab_summary}
\end{table}

Observou-se também que os valores médio e máximo observados diferem, mesmo quando não é utilizado nenhum algoritmo de gerenciamento de interesse, ou seja, o cliente recebe atualizações de estado de todas as entidades presentes no jogo, com a freqüência normal. Além disso, com 200 avatares no ambiente, com estado de 100 bytes, cuja atualização é enviada a cada 250 ms, o servidor deveria alocar 199$\times$100$\times$4 bytes/s para cada cliente, ou seja, 79600 bytes/s. No entanto, observou-se que a utilização máxima e média, com 200 avatares presentes e nenhum gerenciamento de interesse, foi de 77600 e 76458, respectivamente. Isso acontece porque o ns-2 é um simulador de eventos discreto, e o servidor simulado foi programado para checar o schedule de envios a cada 10 ms. Em conseqüência disto, cada atualização de estado pode ter tido seu intervalo aumentado em até 10 ms, o que explica os valores encontrados.

\section{Conclusion}
\label{conclusion}
Foi apresentado um algoritmo de gerenciamento de interesse, o \malg, cuja idéia principal é adaptar a freqüência de atualização de estado das entidades do jogo de acordo com sua relevância para o cliente que receberá as atualizações. O formato da área de interesse utilizada pelo algoritmo \malg{} consiste em um setor de círculo, correspondente ao campo de visão do jogador, mais um círculo de raio menor, que corresponde à área próxima ao avatar daquele jogador. O objetivo deste círculo menor é o de manter o estado naquela região, que é considerada crítica, o mais atualizado possível. Somando-se essas características, chegamos a um algoritmo que obteve redução da utilização máxima da banda de envio do servidor de 52.03\% e 33.10\%, comparados com o gerenciamento de interesse baseado em círculo e em campo de visão, respectivamente, e de 63.51\% e 33.58\% de utilização média, comparados com os mesmos algoritmos.


% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation Results}
%\label{fig_sim}
%\end{figure}

% Note that IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command, the
% \label for the overall figure must come after \caption.
% \hfil must be used as a separator to get equal spacing.
% The subfigure.sty package works much the same way, except \subfigure is
% used instead of \subfloat.
%
%\begin{figure*}[!t]
%\centerline{\subfloat[Case I]\includegraphics[width=2.5in]{subfigcase1}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{subfigcase2}%
%\label{fig_second_case}}}
%\caption{Simulation results}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.


% An example of a floating table. Note that, for IEEE style tables, the 
% \caption command should come BEFORE the table. Table text will default to
% \footnotesize as IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that IEEE does not put floats in the very first column - or typically
% anywhere on the first page for that matter. Also, in-text middle ("here")
% positioning is not used. Most IEEE journals/conferences use top floats
% exclusively. Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the \fnbelowfloat
% command of the stfloats package.


% conference papers do not normally have an appendix


% use section* for acknowledgement
%\section*{Acknowledgment}

%The authors would like to thank...





% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{dsrt}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
% \begin{thebibliography}{1}
% 
% \bibitem{IEEEhowto:kopka}
% H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
%   0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.
% 
% \end{thebibliography}




% that's all folks
\end{document}


