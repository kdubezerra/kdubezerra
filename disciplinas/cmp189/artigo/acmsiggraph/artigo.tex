\documentclass{acmsiggraph}                     % final
%\documentclass[annualconference]{acmsiggraph}  % final (annual conference)
%\documentclass[review]{acmsiggraph}            % review
%\documentclass[widereview]{acmsiggraph}        % wide-spaced review
%\documentclass[preprint]{acmsiggraph}          % preprint

%% Uncomment one of the five lines above depending on where your paper is
%% in the conference process. ``review'' and ``widereview'' are for review
%% submission, ``preprint'' is for pre-publication, and ``final'' is for
%% the version to be printed. The ``final'' variant will accept the 
%% ``annualconference'' parameter, which changes the height of the space
%% left clear for the ACM copyright information.

%% The 'helvet' and 'times' packages define the typefaces used for
%% serif and sans serif type in this document. Computer Modern Roman 
%% is used for mathematics typesetting. The scale factor is set to .92
%% to bring the sans-serif type in line with the serif type.

\usepackage[scaled=.92]{helvet}
\usepackage{times}
\usepackage{textcomp}
\usepackage[brazil]{babel}

%% The 'graphicx' package allows for the inclusion of EPS figures.

\usepackage{graphicx}
\usepackage{algorithmic}
\usepackage{algorithm}

\floatname{algorithm}{Algoritmo}
\renewcommand{\algorithmicrequire}{\textbf{Pr\'e-requisito:}}
\renewcommand{\algorithmicensure}{\textbf{Garante:}}
\renewcommand{\algorithmicend}{\textbf{fim}}
\renewcommand{\algorithmicif}{\textbf{se}}
\renewcommand{\algorithmicthen}{\textbf{ent\~ao}}
\renewcommand{\algorithmicelse}{\textbf{sen\~ao}}
\renewcommand{\algorithmicelsif}{\algorithmicelse\ \algorithmicif}
\renewcommand{\algorithmicendif}{\algorithmicend\ \algorithmicif}
\renewcommand{\algorithmicfor}{\textbf{para}}
\renewcommand{\algorithmicforall}{\textbf{para todo}}
\renewcommand{\algorithmicdo}{\textbf{fa\'ca}}
\renewcommand{\algorithmicendfor}{\algorithmicend\ \algorithmicfor}
\renewcommand{\algorithmicwhile}{\textbf{enquanto}}

%% use this for zero \parindent and non-zero \parskip, intelligently.

\usepackage{parskip}

%% Optional: the 'caption' package provides a nicer-looking replacement
%% for the standard caption environment. With 'labelfont=bf,'textfont=it',
%% caption labels are bold and caption text is italic.

\usepackage[labelfont=bf,textfont=it]{caption}
\usepackage[latin1]{inputenc}

\newcommand{\misccite}[2]{#1. Disponível em: \textless#2\textgreater. Acesso em: 26 jun. 2009}
\newcommand{\gamecite}[2]{\misccite{#1}{#2}}

%\input{comms_and_hyphs.tex}
%% If you are submitting a paper to the annual conference, please replace 
%% the value ``0'' below with the numeric value of your OnlineID. 
%% If you are not submitting this paper to the annual conference, 
%% you may safely leave it at ``0'' -- it will not be included in the output.

%\onlineid{0}

%% Paper title.

\title{Balanceamento de carga utilizando kd-trees para\\ particionar dinamicamente o ambiente virtual de MMOGs}

%% Author and Affiliation (single author).

%%\author{Roy G. Biv\thanks{e-mail: roy.g.biv@aol.com}\\Allied Widgets Research}

%% Author and Affiliation (multiple authors).

\author{Carlos Eduardo B. Bezerra\thanks{e-mail: carlos.bezerra@inf.ufrgs.br}\\
Grupo de Processamento Paralelo e Distribuído\\
Instituto de Informática - UFRGS\\
Av. Bento Gonçalves, 9500, Porto Alegre %
%\and Ed Grimley\thanks{e-mail:ed.grimley@aol.com}\\Nigel Mansell\thanks{nigelf1@msn.com}\\ Grimley Widgets, Inc. %
%\and Martha Stewart\thanks{e-mail:martha.stewart@marthastewart.com}\\ Martha Stewart Enterprises \\ Microsoft Research
}

%% Keywords that describe your work.

\keywords{MMOGs, balanceamento de carga, servidor distribuído, kd-trees}

%%%%%% START OF THE PAPER %%%%%%

 \begin{document}
 
% \teaser{
%   \includegraphics[width=1.5in]{sample}
%   \caption{Lookit! Lookit!}
% }

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

\maketitle

%% Abstract section.

\begin{abstract}

MMOGs (\emph{massively multiplayer online games}, ou jogos online maciçamente multijogador), são aplicações que requerem conexões com grande largura de banda para funcionarem adequadamente. Essa demanda por largura de banda é maior principalmente nos servidores que hospedam o jogo. Como nesse tipo de jogo costuma haver milhares a dezenas de milhares de jogadores simultâneos, sendo que a interação entre cada par de jogadores é intermediada pelo servidor, é sobre este que recai o maior custo no que se refere a uso de largura de banda para realizar o envio de atualizações de estado do ambiente do jogo para os jogadores. Para contornar este problema, são propostas arquiteturas com vários servidores, onde cada um deles gerencia uma região do ambiente virtual, e cada jogador conecta-se somente ao servidor que gerencia a área onde ele está jogando. No entanto, para distribuir a carga entre os servidores, é necessário um algoritmo de particionamento do ambiente virtual. Para que se possa reajustar a distribuição de carga durante o jogo, esse algoritmo deve ser dinâmico. Alguns trabalhos já foram feitos nesse sentido, mas, utilizando um algoritmo geométrico mais adequado do que os encontrados na literatura, deve ser possível alcançar um nível melhor de granularidade da distribuição, sem comprometer o tempo de rebalanceamento, ou mesmo reduzindo-o. Neste trabalho, é proposta a utilização de uma KD-Tree para dividir o ambiente virtual do jogo em regiões, cada uma das quais sendo designada a um dos servidores. As coordenadas de divisão das regiões são ajustadas dinamicamente de acordo com a distribuição dos avatares no ambiente virtual.

\end{abstract}

%% ACM Computing Review (CR) categories. 
%% See <http://www.acm.org/class/1998/> for details.
%% The ``\CRcat'' command takes four arguments.

% \begin{CRcatlist}
%   \CRcat{K.6.1}{Management of Computing and Information Systems}%
% {Project and People Management}{Life Cycle};
%   \CRcat{K.7.m}{The Computing Profession}{Miscellaneous}{Ethics}
% \end{CRcatlist}

%% The ``\keywordlist'' command prints out the keywords.
\keywordlist

\section{Introdução}

%% The ``\copyrightspace'' command must be the first command after the 
%% start of the first section of the body of your paper. It ensures the
%% copyright space is left at the bottom of the first column on the first
%% page of your paper.

%% \copyrightspace

Os MMOGs têm como principal característica a grande quantidade de jogadores interagindo simultaneamente, chegando a ter dezenas até centenas de milhares de participantes simultâneos \cite{schiele2007rpp}. Ao se usar uma arquitetura cliente-servidor para que os jogadores se comuniquem entre si, é necessário que esse servidor intermedie a comunicação entre cada par de jogadores.

Para permitir que os jogadores interajam, o servidor recebe os comandos de cada jogador, calcula o estado resultante do jogo e envia o novo estado para todos os jogadores que estiverem interagindo com o primeiro. É fácil perceber que o número de mensagens de atualização de estado enviadas pelo servidor será proporcional ao quadrado no número de jogadores, se todos estiverem interagindo com todos. Obviamente, dependendo desse número de jogadores, o custo de manutenção de uma infra-estrutura centralizada como essa se torna muito alto, restringindo esse mercado de jogos MMOG a grandes empresas, que disponham de recursos suficientes para tal.

Buscando reduzir esse custo, tem-se buscado soluções descentralizadas. Algumas destas utilizam redes par-a-par: \cite{schiele2007rpp,rieche2007ppb,hampel2006ppa,elrhalibi2005abm,iimura2004zfg,knutsson2004pps}. Outras propõem a utilização de um sistema distribuído composto por nodos servidores de baixo custo, conectados através da Internet, como é proposto em \cite{ng2002msa,chertov:olb,lee2003sdl,assiotis2006dam}. De qualquer forma, em todas essas abordagens, o ``mundo'', ou ambiente virtual do jogo, é dividido em regiões e, para cada região, é designado um servidor -- ou um grupo de pares para administrarem-no em conjunto, no caso das redes par-a-par. Cada uma dessas regiões deve possuir um conteúdo tal que a carga imposta sobre o servidor correspondente não seja maior que a sua capacidade.

Quando um \emph{avatar} (representação do jogador no ambiente virtual) é posicionado em uma determinada região, o jogador daquele avatar conecta-se ao servidor a ela associado e é dele que o jogador receberá as mensagens de atualização para que o ambiente virtual seja visualizado no seu computador com o estado mais recente do jogo. Quando um servidor se torna sobrecarregado, devido a uma maior concentração de avatares em sua região e, consequentemente, mais jogadores a serem atualizados, a divisão do ambiente virtual deve ser recalculada de maneira a aliviar aquele servidor.

Geralmente, é feita uma divisão do ambiente virtual em grades de células, com posterior agrupamento das mesmas, formando regiões que são distribuídas entre os servidores. No entanto, tal abordagem tem uma limitação severa em sua granularidade, já que as células têm tamanho e posição fixos. Utilizando um algoritmo geométrico mais adequado, deve ser possível conseguir uma melhor distribuição dos jogadores entre os diferentes servidores, fazendo uso de técnicas tradicionais que geralmente são utilizadas na área de computação gráfica.

Neste trabalho, é proposto o uso de uma kd-tree para realizar o particionamento do ambiente virtual. Quando um servidor fica sobrecarregado, ele dispara dispara o balanceamento de carga, reajustando os limites de sua região com a ajuda da estrutura de dados kd-tree. Foi feita a implementação de um protótipo, que foi utilizado para realizar simulações. Os resultados encontrados através das simulações serão comparados com resultados anteriores obtidos ao se utilizar a técnica de divisão do ambiente virtual do jogo em células estáticas.

O texto está organizado da seguinte forma: na seção \ref{sec:context}, são apresentados alguns trabalhos relacionados; na seção \ref{sec:proposal}, é apresentado em detalhes o algoritmo proposto aqui; nas seções \ref{sec:simul} e \ref{sec:result} são apresentadas as simulações e os resultados alcançados e, na seção \ref{sec:conc}, são apresentadas as conclusões a que se chegou com este trabalho.

\section{Trabalhos relacionados}
\label{sec:context}

Diferentes autores já atacaram o problema de particionamento do ambiente virtual em MMOGs para distribuição entre vários servidores \cite{ahmed2008mol,bezerra2009lbs}. Geralmente, é feita uma divisão em células estáticas, de posição e tamanho fixos. As células são então agrupadas em regiões (Figura \ref{fig:cells}, e cada região é delegada a um dos servidores. Quando um deles está sobrecarregado, ele busca outros servidores, que possam absorver seu excesso carga. Isso é feito distribuindo uma ou mais células do servidor sobrecarregado a outros servidores.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.85\linewidth]{images/macromicro}
	\caption{Divisão em células e agrupamento em regiões}
	\label{fig:cells}
\end{figure}

\cite{ahmed2008mol} propõem um modelo de balanceamento de carga orientado a células. Para balancear a carga, seu algoritmo encontra, primeiro, todos os agrupamentos de células que são gerenciadas pelo servidor sobrecarregado. Seleciona-se o agrupamento que contiver o menor número de células e, deste agrupamento, é escolhida a célula que tiver menor interação com outras -- considerando apenas células gerenciadas pelo servidor sobrecarregado que disparou o balanceamento e que a interação entre duas células A e B é definida como o número de pares de avatares interagindo um com outro, estando um em A e o outro em B. A célula escolhida é, então, transferida para o servidor menos carregado, sendo que a ``carga'' é definida como o uso de largura de banda para enviar atualizações de estado aos avatares posicionados em células gerenciadas por aquele servidor. Esse processo se repete até que o servidor não esteja mais sobrecarregado ou que não haja mais servidores capazes de absorver a carga excedente -- neste caso, uma opção seria diminuir a freqüência de envio das atualizações de estado \cite{bezerra2008a3}.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.5\linewidth]{images/grafo}
	\caption{Representação do ambiente em um grafo}
	\label{fig:grafo}
\end{figure}

Em \cite{bezerra2009lbs}, também é proposta a divisão em células. Para realizar a divisão, o ambiente é representado por um grafo (Figura \ref{fig:grafo}), onde cada vértice representa uma célula. Cada aresta no grafo liga dois vértices que representam células vizinhas. O peso de um vértice equivale ao uso de largura de banda do servidor para enviar atualizações de estado aos jogadores cujos avatares estão na célula representada por aquele vértice. A interação entre cada duas células definirá o peso da aresta que liga os vértices correspondentes, sendo o valor da interação entre células está relacionado ao número de pares de avatares interagindo, cada um deles em uma célula diferente. Para formar as regiões, o grafo é particionado, utilizando um algoritmo guloso: começando do vértice mais pesado, a cada passo adiciona-se o vértice ligado pelas aresta mais pesada a algum dos vértices já selecionados, até que o peso total da partição do grafo (soma dos pesos dos vértices) atinja um determinado limite relacionado à capacidade total do servidor que receberá a região representada por aquela partição do grafo.

Embora essa abordagem funcione, há uma séria limitação na granularidade da distribuição que pode ser feita. Se for desejada uma granularidade fina, é necessário definir as células como sendo muito pequenas, aumentando o número de vértices no grafo que representa o ambiente virtual e, conseqüentemente, o tempo necessário para executar o balanceamento. Sendo assim, pode ser melhor utilizar uma outra abordagem para o particionamento do ambiente virtual que utilize uma estrutura de dados mais adequada, tal como a kd-tree \cite{bentley1975mbs}.

%falar do que é a kd-tree? muita enrolação.

Esse tipo de estrutura de dados costuma ser usado na computação gráfica. No entanto, como em MMOGs também há informação geométrica -- como a posição de cada avatar no espaço do ambiente virtual --, árvores de particionamento do espaço podem ser utilizadas. Além disso, já existem técnicas de distribuição de objetos no espaço, buscando manter o balanceamento entre as diferentes regiões definidas pela árvore. Em \cite{luque2005bpc}, por exemplo, busca-se reduzir o tempo necessário para calcular as colisões entre pares de objetos se movendo no espaço. Para isso, é utilizada uma árvore BSP (\emph{binary space partitioning}, ou particionamento binário do espaço) para distribuir os objetos da cena (Figura \ref{fig:bsp}). Obviamente, se cada objeto de um par está completamente contido em uma partição diferente, eles não colidem e não é necessário fazer um teste mais demorado para esse par. Partindo de uma divisão inicial, é proposto pelos autores que a árvore se ajuste dinamicamente à medida que os objetos se deslocam, balanceando a distribuição dos mesmos na árvore, evitando que o tempo necessário para o cálculo das colisões se eleve muito. Algumas das idéias propostas pelos autores podem ser utilizadas para o contexto de balanceamento de carga entre servidores de um MMOG.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.5\linewidth]{images/bsp}
	\caption{Particionamento do espaço com uma árvore BSP}
	\label{fig:bsp}
\end{figure}

\section{Proposta}
\label{sec:proposal} 

balanceamento automatico ($2^{lallaa}$)
divisão dinâmica
recursao para balanceamento (irmaos, primos, pri-primos etc.)
ajuste dos limites
entidade central para balanceamento (necessario calculo dos pesos dos avatares)



A proposta para balanceamento de carga dinâmico para MMOGs apresentada aqui tem como base dois critérios: primeiramente, deve-se considerar a possibilidade do sistema ser heterogêneo, ou seja, de que cada servidor tenha uma quantidade diferente de recursos. Aqui se define como ``recursos'' a largura de banda de envio que aquele servidor tem disponível para enviar atualizações de estado para os jogadores a ele conectados.

Essa escolha se deve ao fato de que cada jogador envia comandos para o servidor a uma taxa constante, logo o número de mensagens recebidas pelo servidor por unidade de tempo cresce linearmente em relação ao número de jogadores, enquanto que, como foi discutido, o número de atualizações de estado enviadas pelo servidor pode ser quadrático, no pior caso.

Como foi dito na introdução, para dividir o ambiente do jogo em regiões propõe-se utilizar uma estrutura de dados conhecida, que é a kd-tree. A grande maioria dos MMOGs, como World of Warcraft \cite{worldofwarcraft}, Ragnarök \cite{ragnarok} e Lineage II \cite{lineage2}, apesar de possuir gráficos em três dimensões, o mundo simulado -- cidades, florestas, pântanos e pontos de interesse em geral -- nestes jogos é mapeado em duas dimensões. Por esse motivo, propõe-se o uso de uma kd-tree com \mbox{k = 2}.

A cada nodo da árvore corresponde uma região do espaço e, além disso, neste nodo é armazenada um valor correspondente a uma coordenada de divisão. Cada um dos dois filhos daquele nodo representarão uma subdivisão da região representada pelo nodo pai, sendo que um deles representa a sub-região com coordenada menor do que a coordenada de divisão, e o outro, a região com coordenada maior ou igual à coordenada de divisão. A cada nível da árvore, alterna-se o eixo da coordenada de divisão (no caso de duas dimensões, os eixos $x$ e $y$). Cada nó folha também representa uma região do espaço, porém não armazena nenhuma coordenada de divisão, além de apontar para uma lista de avatares presentes naquela região. Por fim, cada nó folha é associado a um dos servidores do jogo. Quando um servidor fica sobrecarregado, ele dispara o balanceamento de carga, que utiliza a estrutura de dados kd-tree, reajustando as coordenadas de divisão que definem as regiões e, assim, diminuindo a quantidade de conteúdo gerenciada por ele.

A cada nó da árvore estão também associados dois valores: capacidade e carga da sub-árvore. A carga de um nó da árvore é igual à soma da carga de seus filhos. Da mesma forma, a capacidade de um nó intermediário é igual à soma da capacidade de seus nós filhos. No caso do nó folha, esses valores são os mesmos do servidor associado a ele. A raiz da árvore, por outro lado, tem como carga o tráfego total de mensagens de atualização de estado do jogo e, como capacidade, a soma das capacidades individuais dos servidores.

Nas seções a seguir, serão descritos a construção da árvore, o cálculo da carga associada a cada servidor e o algoritmo de balanceamento proposto.

\subsection{Construção da kd-tree}

%TODO:BEGIN: deixar esse algoritmo aqui? nao foge do escopo?
Para fazer uma divisão inicial do espaço, é construída uma kd-tree balanceada (tanto quanto possível, pois depende do número de servidores -- ou nós folha -- ser igual uma potência de 2). Para isto, foi utilizada a seguinte função recursiva para criação da árvore:

\begin{algorithm}
\caption{nodo::constrói\_árvore(id, nível, num\_servidores)}
\label{alg:buildtree}
\begin{algorithmic}
	\IF{id + $2^{n\acute{\imath}vel} \ge num\_servidores$ }
		\STATE $filho\_menor \leftarrow filho\_maior \leftarrow NIL$
		\STATE retorne
	\ELSE
		\STATE $filho\_menor \leftarrow$ novo\_nodo()
		\STATE $filho\_menor.pai \leftarrow$ \textbf{this}
		\STATE $filho\_maior \leftarrow$ novo\_nodo()
		\STATE $filho\_maior.pai \leftarrow$ \textbf{this}
		\STATE $filho\_menor$.constr\'oi\_árvore\\$(id, n\'ivel + 1, num\_servidores)$
		\STATE $filho\_maior$.constrói\_\'arvore\\$(id + 2^{n\acute{\imath}vel},$ $n\'ivel + 1,$ $num\_servidores)$
	\ENDIF
\end{algorithmic}
\end{algorithm}

FIGURA DE UMA KD-TREE COM OS IDS ASSOCIADOS

No algoritmo acima, o nodeId serve para calcular quantos filhos cada nodo deve ter e, nos nodos folha, pode ser usado para determinar qual o servidor associado à região representada por aquela folha da árvore. O objetivo com isso é tentar criar uma árvore balanceada, onde cada nodo tem duas sub-árvores com pesos semelhantes.
%TODO:END: deixar esse algoritmo aqui? nao foge do escopo?

\subsection{FIXME: Distribuindo os avatares nas regiões}

Uma idéia inicial poderia ser a de distribuir os jogadores entre servidores, de maneira que o número de jogadores em cada servidor fosse proporcional à largura de banda daquele servidor. Para calcular a coordenada de divisão da nodo da kd-tree, bastaria ordenar em um vetor os avatares de acordo com o eixo usado para divisão ($x$ ou $y$) pelo nodo da árvore e, então, calcular o índice, no vetor, tal que o número de elementos até esse índice fosse proporcional à capacidade de um dos servidores e o número de elementos a partir desse índice fosse proporcional à capacida do outro servidor (Figura \ref{fig:vector}). A complexidade dessa operação seria $O(nlogn)$, por causa da ordenação.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{images/vector}
  \caption{Cálculo simples da coordenada de divisão}
  \label{fig:vector}
\end{figure}

 Contudo, essa distribuição não funcionaria, pelo fato de que a carga imposta pelos jogadores depende também do quanto eles estão interagindo entre si. Por exemplo, se os avatares de dois jogadores estiverem muito distantes um do outro, provavelmente não haverá interação entre eles e, portanto, o servidor precisará apenas atualizar cada um a respeito de suas próprias ações -- para estes, o crescimento do número de mensagens será linear em relação ao número de jogadores. No entanto, se estes avatares estiverem próximos, cada jogador deverá ser atualizado não apenas a respeito do resultado de suas próprias ações, como também das ações do outro jogador -- neste caso, o crescimento do número de mensagens pode ser quadrático (Figura \ref{fig:carga}). Por esta razão, não é suficiente apenas dividir os jogadores entre os servidores, mesmo que proporcionalmente aos recursos de cada um destes.

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{images/carga}
  \caption{Relação entre avatares e carga}
  \label{fig:carga}
\end{figure}

Uma maneira mais adequada de se dividir o conjunto de avatares é de acordo com a carga que cada um gera sobre o servidor. O método força-bruta para fazer essa verificação seria utilizar dois laços aninhados para calcular a distância de cada avatar para cada um dos outros avatares e, baseado na interação entre cada par de avatares, chegar ao número de mensagens que cada jogador deve receber por unidade de tempo. Essa abordagem tem complexidade $O(n^2)$. Porém, se os avatares forem ordenados de acordo com a sua coordenada no eixo usado para divisão do espaço na kd-tree, pode-se realizar esse cálculo em um tempo menor.

Para isso, são também utilizados dois laços para varredura do vetor de avatares, cada um destes com uma carga inicializada com o valor de zero. Como o vetor está ordenado, o laço interno pode começar de um índice antes do qual sabe-se que nenhum avatar $a_j$ terá relevância para aquele que está sendo indicado no laço externo, $a_i$. É utilizada uma variável $begin$, com valor inicial de zero: quando a coordenada de $a_j$ é menor que a de $a_i$, com uma diferença maior que o alcance máximo de visão dos avatares, a variável $begin$ é incrementada. Para cada $a_j$ que está a uma distância menor que o alcance máximo de visão, a carga de $a_i$ é incrementada segundo a relevância de $a_j$ para $a_i$. Ao se chegar a um avatar $a_j$, tal que a sua coordenada é maior que a de $a_i$, com uma diferença maior que o alcance de visão, o laço externo avança imediatamente para o próximo passo, incrementando $a_i$ e atribuindo a $a_j$ o valor armazenado em $begin$ (Figura \ref{fig:sweep}).

Sejam $width$ a extensão do ambiente virtual no eixo usado para divisão; $radius$, o alcance máximo de visão dos avatares e $n$, o número de avatares. O número de vezes em que é calculada a relevância de um avatar para o outro, considerando que eles estejam distribuídos uniformemente no ambiente virtual é de \mbox{$O(m \times n)$}, onde $m$ é o número de avatares comparados no laço interno, ou seja, \mbox{$m = \frac{2 \times radius \times n}{width}$}. A complexidade da ordenação dos avatares em um dos eixos é de $O(nlogn)$. Embora ainda seja quadrático, o tempo de execução é reduzido significativamente, a depender do tamanho do ambiente virtual e do alcance da visão dos avatares. O algoritmo poderia seguir adiante e ordenar cada conjunto de avatares $a_j$ que estão próximos (em um dos eixos de coordenadas) de $a_i$ de acordo com o outro eixo de coordenadas e, novamente, fazer uma varredura eliminando os que estivessem distantes, agora nas duas dimensões. O número de cálculos de relevância seria de \mbox{$O(p \times n)$}, com $p$ sendo o número de avatares próximos a $a_i$, considerando os dois eixos de coordenadas, ou seja, \mbox{$p = \frac{(2 \times radius \times n)^2}{width \times height}$}. Nesse caso, $height$ é a extensão do ambiente no segundo eixo tomado como referência. Porém, embora haja uma redução considerável do número de cálculos de relevância, isso não compensa o tempo que se gasta ordenando o subvetor de avatares selelecionados para cada $a_i$. Somando-se todo o tempo gasto com ordenações, seria obtida uma complexidade de: \mbox{$O(nlogn + n \times mlogm)$}.

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{images/sweep}
  \caption{Varredura do vetor ordenado de avatares}
   \label{fig:sweep}
\end{figure}

\subsection{Balanceamento dinâmico}

Uma vez criada a árvore, cada servidor é associado a um nó folha, que determina um subespaço. Todas as atualizações de estado que devem ser enviadas a jogadores cujos avatares estejam naquela região deverão ser enviadas pelo servidor correspondente. Quando um servidor fica sobrecarregado, ele tem a possibilidade de transferir parte da carga designada a ele para algum outro servidor. Para fazer isso, é utilizada a kd-tree, através do reajuste das coordenadas de divisão dos nodos das regiões.








\section{Simulações}
\label{sec:simul}

\section{Resultados}
\label{sec:result}

\section{Conclusões}
\label{sec:conc}


\section*{Acknowledgements}

To Robert, for all the bagels.

\bibliographystyle{acmsiggraph}
%\nocite{*}
\bibliography{artigo}
\end{document}
