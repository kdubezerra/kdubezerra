/*
		ZIG game-oriented networking engine
		Project Home: http://zige.sourceforge.net

		Copyright (c) 2002-2005, Fábio Reis Cecin.
		All rights reserved.
    
		This free software is licensed under a BSD-style license. Read the 
		LICENSE.TXT file for the full license.
*/
/*

	zig.h

	main header file for ziglib - apps should include this

*/

#ifndef _ZIG_HEADER_ZIG_H_
#define _ZIG_HEADER_ZIG_H_

//stoopid #include <map> warningz
#if (defined _MSC_VER)
#pragma warning (disable: 4786)
#endif

#include <assert.h>
#include "console.h"

#include "zigdefs.h"  //for compatability

/*! \file zig.h
    \brief Provides zig_init(), zig_shutdown() and some useful enums and definitions.
*/

/*! \brief Initializes the ZIG library. <B>IMPORTANT!</B>

		You <B>MUST</B> call this function before using any classes or functions that do networking!

		IMPLEMENTATION NOTE: As of ZIG 2.0, this function just initializes the HawkNL library, by calling nlInit() 
		and nlSelectNetwork(NL_IP), allowing its TCP/IP socket communication primitives to work.

		\param con Pointer (optional) to a console_c instance which should receive debug or error messages 
		generated by the initialization procedure.

		\return Whether ZIG was successfully initialized or not:
		- \c true when ZIG was initialized OK;
		- \c false when ZIG was not initialized OK (e.g. no network) and therefore cannot work.
*/ 
bool zig_init(console_c *con = 0);

/*! \brief Shuts down the ZIG library.

		You should call this function when exiting your application/game.

		IMPLEMENTATION NOTE: As of ZIG 2.0, this function just shuts down the HawkNL library, by calling 
		nlShutdown().

		\param con Pointer (optional) to a console_c instance which should receive debug or error messages 
		generated by the shut-down procedure.
*/ 
void zig_shutdown(console_c *con = 0);

/*! \brief Default UDP broadcast port value used by serverinfo_c, zigclient_c and zigserver_c for server 
		discovery in the local area network (LAN). 
*/
#define    ZIG_DEFAULT_BROADCAST_PORT    54876

/*! \brief Enumerates the built-in types of streams that ZIG connections supports.

		A single ZIG point-to-point connection, which is defined by a 
		single flow of UDP packets, can carry multiple independent logical streams of data which are 
		encoded (usually) on the same packets. Each stream guarantees (or not) ordered messages and 
		guarantees (or not) reliable delivery of messages independently of other streams. 
 
		STREAM TYPES: Currently, two supported types of "creatable" streams (STREAM_CUMULATIVE_ACK 
		and STREAM_INDIVIDUAL_ACK) guarantee that messages will arrive in the same sequence/order 
		that they were sent, if they arrive at all. STREAM_INDIVIDUAL_ACK always guarantees the 
		reliable delivery of all its messages. STREAM_CUMULATIVE_ACK supports the sending of both 
		"reliable messages" (guaranteed delivery) and "unreliable messages" (one-shot, 
		non-guaranteed delivery) on the same ordering stream. In this regard, STREAM_CUMULATIVE_ACK 
		is intended to be a replacement for the "Critical message flag" (RSP_CRITICAL) that was 
		supported by the "reliable messaging" mechanism of ZIG 1.x and ZIGLITE 1.x. If you were using 
		"critical messages", now you can create a stream of STREAM_CUMULATIVE_ACK type and send 
		the "critical" reliable messages through it, along with any unreliable chunks of data that 
		need to be ordered together with those critical messages, when and if they arrive at all. 
		The third type of stream is called STREAM_NO_ACK, that does not support guaranteed delivery
		of data and does not support delivery of messages in guaranteed order.

		STREAM IDS AND THE STREAM ZERO ("0"): ZIG streams in a connection are identified by 
		integers. Stream 0 is the nickname of a special "hard-coded" and "unreliable" stream that
		like the STREAM_NO_ACK streams, does not support guaranteed delivery and order of data. It is
		the same as the mechanism for sending "unreliable" data in  ZIG 1.x and ZIGLITE 1.x. The API
		for sending this kind of data are the packet sending methods of both client and server:
		zigclient_c::send_packet() and zigserver_c::send_packet(). The first parameter of those methods
		are the "Stream 0" contents of the outgoing packet (also called the "unreliable data block").
		The difference between this approach to send unreliable data and a STREAM_NO_ACK stream is that
		the data of stream 0 is sent (potentially) in all outgoing packets (it's discarded only when a
		packet reaches the max_outgoing_flow size), but a STREAM_NO_ACK stream has a policy associated,
		that control the time between its insertion in the outgoing packet. Also, STREAM_NO_ACK streams
		provide a better logic separation between two or more different unreliable flows.
*/
enum zig_stream_types_t {
	
	/// Guarantees ordered delivery of all messages (if they arrive at all), and supports mixed 
	/// sending of "realiable" and "unreliable" messages on the same stream. The "reliable" 
	/// messages, when sent through this stream, will have guaranteed delivery, but "unreliable" 
	/// messages sent through this stream won't. However, independently of the type of each 
	/// message, the receiving end of the stream will receive all messages in the same order that 
	/// they were sent, with the exception of unreliable messages that were lost in transit, 
	/// which won't be received at all and thus won't cause out-of-order message reading. 
	/// Internally, message IDs are ACKed in a "cumulative" fashion, that is, the receiving end 
	/// sends, as an ACK, only the last greatest message ID of value "GID" that it has received, 
	/// signaling that the sender can stop re-sending messages that have an ID of up to, and 
	/// including, "GID". The re-sending of messages is rather aggressive, matching the behavior of 
	/// the "reliable messaging" feature of ZIG 1.x and ZIGLITE 1.x. The same message will be 
	/// re-sent over and over, on each outgoing UDP packet, unless the stream has a configuration 
	/// "policy" that restricts this. However, the "stream policy" can only dictate that a stream 
	/// omits ALL resending of its messages on the next UDP packet: it cannot omit messages with 
	/// lower IDs and send or re-send messages with greater IDs on the same packet. These features 
	/// makes this stream more appropriate for sending urgent and small data blocks (e.g. important 
	/// game updates that can't be neither missed or delayed too much)
	STREAM_CUMULATIVE_ACK,

	/// Guarantees delivery of all messages (doesn't support sending of "unreliable" data). 
	/// Guarantees ordered delivery of all messages. Internally, message IDs are ACKed individually 
	/// by the receiving side. The sender re-sends messages by iterating through a "window", similar 
	/// to what e.g. TCP does. This means that the sender will send a message X, and on a next 
	/// "opportunity" (maybe on the same UDP packet, maybe on the next), it will send message X+1, 
	/// and will only re-send message X when it reaches the end of the window of size S (when 
	/// sending message X+S-1). This makes this stream type ideal for sending data that is not 
	/// urgent in order to reduce overhead of re-sending (ideal for e.g. file transfers, chat). 
	STREAM_INDIVIDUAL_ACK,

	/// Doesn't guarante delivery of messages (doesn't support sending of "reliable" data).
	/// Doesn't guarante ordered delivery of messages. This stream type is similar to the
	/// "implicit" unreliable stream sent in all UDP packets, the advantages in this approach
	/// to send "unreliable" data instead the old fashion is that it permits a better logic
	/// separation between different unreliable flows, and it permits associating a policy to
	/// the stream control the send interval between packets.
	STREAM_NO_ACK,

	/// Maximum number (count) of defined stream types.
	STREAM_MAX_TYPES
};

/*! \brief Enumeration of int C++ exceptions that can be thrown by ZIG methods.
*/
enum zig_int_exceptions_t {

	/*! No exception (never used). */
	EX_NONE = 0,

	/*! Something is NULL (0) but shouldn't be. */
	EX_NULL,

	/*! End of bytes: no more data to read. Thrown by buffer_c buffer reading methods. */
	EX_EOB,

	/*! Invalid data when reading a C++ object from a buffer_c instance. */
	EX_INVALID_DATA,
	
	/*! Maximum number (count) of defined int exceptions. */
	EX_MAX_EXCEPTIONS
};

#ifndef NO_DOXYGEN // take this ugly hack out of the docs

#ifndef NULL
#define NULL 0
#endif

#endif // #ifndef NO_DOXYGEN // take this ugly hack out of the docs

#endif

