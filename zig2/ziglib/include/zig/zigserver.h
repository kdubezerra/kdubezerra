/*
		ZIG game-oriented networking engine
		Project Home: http://zige.sourceforge.net

		Copyright (c) 2002-2005, Fábio Reis Cecin.
		All rights reserved.
    
		This free software is licensed under a BSD-style license. Read the 
		LICENSE.TXT file for the full license.
*/
/*

	zigserver

	ZIG Game Engine Skeleton 
	server class

*/

#ifndef _ZIG_HEADER_ZIGSERVER_H_
#define _ZIG_HEADER_ZIGSERVER_H_

//some internal #define switches to control the implementation
#include "zigdefs.h"


#include "server.h"
#include "console.h"
#include "zig.h"
#include "address.h"

/*! \file zigserver.h
    \brief zigserver.h exposes some useful enums that are sent as arguments to or received as return values from zigserver_c methods.
*/

/*! \brief Possible values for the \c zig_reason argument of a zigserver_c::client_disconnected() callback. */
enum zig_server_client_disconnection_reasons_t {

	/*! \brief The disconnection was requested by the client, or there is not enough information. <B>This value is and 
			will always be 0 (zero).</B> */
	ZIGSERVER_DISCONNECTED          = 0,

	/*! \brief Client was disconnected because its connection has timed out. This happens when the server doesn't 
			receive any packets from a client for a specified amount of time which is configured by 
			zigserver_c::set_client_timeout(). */
	ZIGSERVER_DISCONNECTED_TIMEOUT,

	/*! \brief Client was disconnected due to receipt of a packet from that client which did not conform to the ZIG 
			protocol. */
	ZIGSERVER_DISCONNECTED_PROTOCOL_VIOLATION,

	/*! \brief Client was disconnected because an internal socket-related error has occurred (example: socket closed 
			due to loss of network connectivity). */
	ZIGSERVER_DISCONNECTED_SOCKET_ERROR, 

	/*! \brief Client was disconnected because the server is stopping. */
	ZIGSERVER_DISCONNECTED_SHUTDOWN
};

//auxiliary class for a <client-id --- > client> class -- defined in the .cpp
class zig_remote_client_c;

/*! \brief The server class. Extend this class and override its virtual methods to implement the server 
		part of your client-server game/application.

		HOW TO USE:
		The zigserver_c and zigclient_c classes work together as an unit. You develop your client-server game with 
		the ZIG library by extending the zigserver_c class to write the server-side code of your game, and you 
		extend the zigclient_c class to write the client-side code of your game. You also have to write the 
		communication protocol that will flow between the two.
		
    The zigserver_c class provides the basic functionality needed for implementing the server process of 
		a client-server real-time multiplayer game on the Internet. Those are:
		- Accepting and managing connections from remote clients (implemented by class zigclient_c);
		- Sending and receiving data to/from the clients that are currently connected;
		- Disconnecting clients from the game server;

		Usually, you would call the zigserver_c methods in the following order:
		- Call one or more of the "set_xxx()" methods to configure the ZIG server engine;
		- Call start() to open the server socket and initialize the server;
		- While connected, call process_nonblocking() frequently so packets incoming from the network can be processed;
		- While connected, call send_message(), receive_message() and the other methods that allows sending and 
		receiving data to/from clients. Also, deal with the callbacks such as accept_client(), client_connected(), 
		client_disconnected(), client_incoming_data(), etc.
		- Call stop() to finish the server and close the server socket.
    
		MESSAGES VS. PACKETS: 
		Please see the documentation of zigclient_c for a discussion of this.

		UDP PACKET SEND RATE:
		To configure the frequency of client-to-server packets, you must call both set_server_tick() and set_net_ratio(). 
		This will be sufficient to estabilish the client-to-server packet rate. This will also determine frequency of 
		broadcast_frame() callbacks, which is a zigserver_c method that the application/game should override in the game 
		server class. This allows the game server code to easily comply with the packet rate: just write a loop at the 
		broadcast_frame() call which sends one packet to every connected client (through a send_packet() call for each).

		STREAMS API:
		Please see the documentation of zigclient_c for a discussion of connection streams.
*/
class zigserver_c : public server_behavior_i {
public:

	/*! \brief Empty constructor. Log messages will be sent to the default console.

			This constructor does not set a console_c instance. This means that all messages generated by this 
			zigclient_c instance will be sent to the default console, which can be obtained by the static call 
			console_c::get_default_console().
			
			Call set_console() after using this constructor if you wish to log to a specific console.
	*/
	zigserver_c();

	/*! \brief Constructor that provides a console where the instance can log its messages to. 
	*/
	zigserver_c(console_c *conio);

	/*! \brief Destructor.
	*/
	virtual ~zigserver_c();

	/*! \brief Set the console instance where this zigserver_c instance will send its messages to.
	*/
	void set_console(console_c *conio);

	// ----------------------------------------------------------------------------------------
	//    BASIC CONFIGURATION AND START/STOP METHODS:
	// ----------------------------------------------------------------------------------------

	/*! \brief Configures the frequency at which the server-side copy of the simulated game world should be 
			updated.

			<b>IMPORTANT:</b> This method can only be called before start(). If it is called after the server is started, 
			it does nothing.

			HISTORY: Since their inception, the ZIG client-server classes were designed to do most of the repetitive 
			work in client-server game coding, while at the same time leaving the game protocol design entirely up to the 
			application. Although many features have been removed since then, the 'server tick' clock has remained.

			This method configures the interval, in seconds, between update_frame() callbacks. For instance, the default 
			value of 0.1 second configures the zigserver_c implementation to call back the application 10 times per second 
			through the update_frame() virtual method, with a uniform interval of 100ms between each call.

			The update_frame() method is intended for updating the state of the game simulation. That is, if it's 
			set to 0.1 second, then every time this method is called, it should run whatever 'physics' module your 
			game engine executes in order to advance the physics of the game world by 0.1 second of logical time. One may 
			consider 0.1 second (10Hz) as too coarse-grained, but it was enough for Quake back in 1996 :-) You can however 
			change it to 0.05 second (20Hz) or whatever value is best for your game.
			
			You can also completely ignore the update_frame() callback and not override it at all. You should then do your 
			own thing for updating the physics of your game world at the server-side.

			This method also affects the frequency of broadcast_frame() callbacks. Please see set_net_ratio() for more 
			information.

			\param tick Time, in seconds, which the ZIG server implementation should wait before performing the next call 
			to the game/application code at update_frame().
	*/
	void set_server_tick(double tick = 0.1);

	/*! \brief Configures the frequency at which 'server ticks' should also generate 'net ticks'.

			<b>IMPORTANT:</b> This method can only be called before start(). If it is called after the server is started, 
			it does nothing.

			The method set_server_tick() determines the interval, in seconds, between two game world updates ('server 
			ticks'). This method, on the other hand, determines the frequency of network updates ('net ticks') 
			<b>relative to</b> server ticks. Each net tick causes one broadcast_frame() call to be made, which is a 
			callback that was created so that the game/application can dispatch ZIG packets (through send_packet() calls) 
			to every connected client.
			
			EXAMPLES - All examples below assume a 'server tick' of 0.1 second (100ms):
			- A net ratio of \c 1 means that every server tick generates one net tick. In our example, at every 100ms 
			a call to update_frame() will be made (to update the game world), followed by a call to broadcast_frame()
			(to send game update packets to all connected clients);
			- A net ratio of \c 2 means that every two server ticks generates one net tick. In our example, at every 200ms, 
			once the first half 100ms elapses, one call to update_frame() will be made and nothing else. But once the second 
			half 100ms elapses, another call to update_frame() will be made but at this time followed by a broadcast_frame() 
			call;
			- A net ratio of \c 20 means that update_frame() is called 10 times per second and that broadcast_frame() is 
			called 0.5 times per second (once every 2 seconds).

      The separation between 'server ticks' and 'net ticks' was made because although finer granularity in the 
			server-side simulation may lead to a smoother game, the clients can extrapolate or interpolate most of those 
			calculations at client-side and thus save server bandwidth by requiring less network updates.

			The forcing of the 'net tick' to be a multiple of the 'server tick' was done on purpose, because it does 
			not make sense, in terms of consistency, to delay a network update after it has been decided that it will 
			carry a given physics update that has just been computed.

			\param ratio The amount of 'server ticks' needed to elapse so that one 'net tick' is generated.
	*/
	void set_net_ratio(int ratio = 1);



	///////////////// DEPRECATED
	/*! \brief Sets the amount of time that the server, while stopping, should wait for graceful client disconnections.

			When stop() is called (directly, or indirectly through the destructor), the server will try to perform a 
			graceful disconnection of its clients. This is done to try to save the player from seeing ugly freezing 
			screens for 30 seconds or so until a "server timed out" message appears to them. Which is lame.

      The server will wait at most the amount of time specified. If all connected clients are able to acknowledge 
			the server's disconnection request before the shutdown timeout elapses, then the server stopping will finish 
			quicker.

      \param timeout The amount of time, in seconds, that the server will wait for graceful client disconnections before 
			killing its network socket and thus forgetting about the remaining clients.
	*/ 
	//void set_shutdown_timeout(int timeout = 5) { shutdown_timeout = timeout; }
	///////////////// DEPRECATED

	/*! \brief Sets the timeout, in seconds, for estabilished client connections. Default is 30 seconds.

			A ZIG client-server connection is a bi-directional and constant flow of UDP packets. If either end stops 
			receiving UDP packets for a "long" time, then the other end will assume that the other end died and kill 
			the connection.

      This method configures the client-to-server UDP timeout, that is, the maximum amount of time that this 
			zigserver_c waits for the next UDP packet before assuming that any of the connected zigclient_c on the 
			other end died or has become unreachable.

			\param timeout Maximum amount of time, in seconds, that the server will wait for the next UDP packet from 
			any client before disconnecting it.
	*/
	void set_client_timeout(int timeout = 30) { 
		client_timeout = timeout; 
		if (server) server->set_client_timeout(timeout);
	}

	/*! \brief Sets the maximum desired size of outgoing UDP packets for all connected clients and for any clients 
			that should connect in the future.

			This parameter is a 'maximum recommended' value and can be ignored sometimes if the ZIG implementation feels 
			that it will do more good than harm. However, it is a hint value that is followed whenever possible. 

			<b>IMPORTANT:</b> This method changes the maximum outgoing packet size of all currently connected clients, and 
			also sets the default value which will be applied to any clients that happen to connect to this server from 
			now on. To change this parameter for a specific client that is currently connected, call 
			set_max_outgoing_packet_size_for_client() instead.

			\param max_packet_size Maximum size, in bytes, of outgoing UDP packets. Default value is 65536 bytes (64 Kb).
	*/
	void set_max_outgoing_packet_size(int max_packet_size) {
		cfg_max_packet_size = max_packet_size;
		if (server)	server->set_max_outgoing_packet_size(max_packet_size);
	}

	/*! \brief Sets the maximum desired size of outgoing UDP packets for a specific connected client.

			This parameter is a 'maximum recommended' value and can be ignored sometimes if the ZIG implementation feels 
			that it will do more good than harm. However, it is a hint value that is followed whenever possible. 

			<b>IMPORTANT:</b> This method sets the maximum outgoing packet size for a specific connected client! To 
			change the value for all currently connected clients and for any clients that will connect in the future, 
			call set_max_outgoing_packet_size() instead.

			\param client_id The ID of the client whose connection is being cofigured;
			\param max_packet_size Maximum size, in bytes, of outgoing UDP packets to \c client_id. Default value is 
			65536 bytes (64 Kb).
	*/
	void set_max_outgoing_packet_size_for_client(int client_id, int max_packet_size) {
		if (server) server->set_max_outgoing_packet_size_for_client(client_id, max_packet_size);
	}

	/*! \brief Enables or disables packet compression, and also sets the minimum size that packets must have before 
			being compressed. 
      
			To turn on the sending of compressed packets at any time, call set_compression() with positive or zero 
			parameter value. In this case, the \c minimum_packet_size argument specifies the minimum size, in bytes, of 
			packets that are to be compressed. 

			To turn off packet compression, call set_compression() without arguments or with a negative argument value.

			Examples:
			- If \c minimum_packet_size is 0 (zero), then all outgoing packets are compressed;
			- If \c minimum_packet_size is 250, then a packet with 249 bytes or less is sent un-compressed, but a packet 
			with 250 bytes or more is sent in compressed form;
			- If \c minimum_packet_size is -1, then packet compression is disabled altogether.

			NOTE: this call resets the compression stats.

			\param minimum_packet_size Configuration for the packet compression of this zigclient (see above). 
	*/
	void set_compression(int minimum_packet_size = -1) {
		server_compression_config = minimum_packet_size;
		if (server) server->set_compression(server_compression_config);
	}

	/*! \brief Starts the server by opening its UDP socket and initializing the application. <b>IMPORTANT</b>
			
			This method opens the UDP socket that the server will use to accept connections and to communicate with 
			any zigclient_c instances that connect to it. It also calls zigserver_c::init() so that the application 
			server can initialize itself.

			<b>IMPORTANT</b>: 
			
			- You <b>must</b> call this method before client connections can be accepted by this server!
			- You <b>must</b> call process_nonblocking() frequently after calling this method! (see the documentation 
			on process_nonblocking() for more details)

			\param port The local UDP port that the clients will have to connect() to;
      \param maxplayers The hard maximum number of simultaneous clients (players) that the server will support;
			\param broadcast_port The local UDP broadcast port that the server will open to listen for 
			zigclient_c::get_all_server_info() requests.
			
			\return 
			- \c true if socket is opened successfully and the client is ready to connect();
			- \c false if socket could not be opened or some other (very bad) error occurred.
	*/
	bool start(int port, int maxplayers, int broadcast_port = ZIG_DEFAULT_BROADCAST_PORT);

	/*! \brief Stops the server, closing its UDP socket and finishing the application. <b>IMPORTANT</b>

			You should call this method before deleting your zigserver_c instance or killing the process/application. 
			If the server still has clients connected to it, it will try to gracefully disconnect them for a few seconds 
			before it closes its socket (see set_shutdown_timeout() for details on how to configure this behavior). 
			This is good for the players that will disconnect almost immediately instead of having to wait their 
			connections to time out.

			In other words, this method ensures that the server shuts down tidily. It also ensures that 
			zigserver_c::finish() is called, so that the application server can clean up after itself.
	*/
	bool stop();

	/*! \brief Processes any pending tasks on the servers's network engine. <b>IMPORTANT</b>

			<b>IMPORTANT</b>: This method <b>must</b> be called periodically after a call to start() is made! 
			While this method is not being called, incoming packets will just pile up. This call reads from the 
			local socket and processes the incoming packets, sending the incoming data through callbacks - 
			see incoming_data() -, or placing them on message queues - see receive_message(). This method also 
			checks for some time-related events such as connection timeouts, and also performs the update_frame() 
			and broadcast_frame() callbacks if the time for their next call has already elapsed.

			<b>HINT</b>: Just place a call to this method on the 'main loop' of your game-server code. Calling this 
			method between 20 and 100 times per second should be enough for most real-time games.

			\return 
			- \c false if some failure occurs (server is not running/connected, or update_frame() or broadcast_frame() 
			have been called and either one returned \c false);
			- \c true if everything is OK.
	*/
  bool process_nonblocking();

	// ----------------------------------------------------------------------------------------
	//    METHODS THAT SHOULD BE OVERRIDEN: 
	// ----------------------------------------------------------------------------------------

	/*! \brief <B>SHOULD BE OVERRIDEN</B>. Callback that the application server should use to perform initializations.

  		This method is called by start() if the ZIG client networking engine is started successfully so that the 
			server application may initialize itself -- e.g.: load resources, initialize data structures, etc.

			The default implementation of this method does nothing and returns \c true;
			
      \return When overriden in a sub-class (application), it should return a boolean value indicating whether 
			the application has initialized successfully or not:
			- \c true Application init was OK. ZIG server and application are ready for connections;
			- \c false Application init was unsuccessful. ZIG server's engine is halted (the effects of start() are 
			cancelled, local socket is closed, etc).
	*/ 
	virtual bool init() { return true; }

	/*! \brief <B>SHOULD BE OVERRIDEN</B>. Callback that the application server should use to perform clean-ups.

			This method is called by stop(), when the ZIG server is being stopped and/or deleted (destructor of the 
			zigserver_c object calls stop() if it is still started), so that the server application may finish -- 
			e.g.: release memory, save files, etc.

			The default implementation of this method does nothing.
	*/ 
	virtual void finish() { }

	/*! \brief <B>SHOULD BE OVERRIDEN</B>. Callback that the game server should use to run a game world physics step.

			This callback is called by the ZIG server implementation in a fixed frequency configured by set_server_tick(). 
			This virtual method was designed so that, when overriden in a sub-class (the game's server-side code), it should 
			advance the game world's logical time by running whatever module of the game engine does the 'physics', by 
			updating the state (e.g. positions, velocity, ...) of objects and generating events (e.g. collisions). 

			The default implementation of this method does nothing and returns \c true. You can leave it at that if you 
			want to deal with your game's server-side simulation in another way.

			This method is called by process_nonblocking(), which does the actual timing control for the callback.

			\return 
			- \c true if everything is OK.
			- \c false if the server should stop (process_nonblocking() will also return \c false).
	*/
	virtual bool update_frame() { return true; }

	/*! \brief <B>SHOULD BE OVERRIDEN</B>. Callback that the game server should use to send UDP packets to each 
  		connected client.

			This callback is called by the ZIG server implementation in a fixed frequency configured by a combination of 
			set_server_tick() and set_net_ratio(). This virtual method was designed so that, when overriden in a sub-class 
			(the game's server-side code), it should send one ZIG UDP packet to each client (through a send_packet() call 
			to each connected client), containing data that should bring each client's local game simulator up-to-date 
			relative to the state of the server's game simulator. 
			
			For that reason, broadcast_frame() is always called just after an update_frame() callback - a packet, 
			containing updates, is sent to each client just after the server's game world is updated. However, if the 
			'net ticks' to 'server ticks' ratio is different than 1:1 (that is, if set_net_ratio() is called with a 
			parameter greater than 1) then there will be some update_frame() callbacks that won't be followed by 
			broadcast_frame() callbacks. See the documentation of those methods for more details.
			
			The default implementation of this method does nothing and returns \c true. You can leave it at that if you 
			want to deal with your game's server-side simulation in another way.

			This method is called by process_nonblocking(), which does the actual timing control for the callback.

			\return 
			- \c true if everything is OK.
			- \c false if the server should stop (process_nonblocking() will also return \c false).
	*/
	virtual bool broadcast_frame() { return true; }

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback called when a new client tries to connect to this server.

			The game server must implement this pure virtual method to decide whether to accept an incoming client 
			connection or not.

			\param client_addr IP address of the remote client;
			\param custom Client's 'connect data' (see zigclient_c::set_connect_data()) which is sent by the game client 
			in every connection request packet to the game server;
			\param answer Game server's reply to the game client:
			- If the client is being rejected, this will show up at its zigclient_c::connection_refused() callback as the 
			\c reason parameter;
			- If the client is being accepted, this will show up at its zigclient_c::connected() callback as the \c hello 
			parameter.
      
			\return Whether the client connection should be accepted or not:
			- \c true If the client connection is accepted;
			- \c false If the client connection is rejected.
	*/
	virtual bool accept_client(address_c &client_addr, buffer_c &custom, buffer_c &answer) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback called when a new client connects to this server.

			This callback is called after the game server implementation returns \c true from an accept_client() callback.

			\param client_id The ID that uniquely identifies the client's current connection on this server. Every new 
			client (connection) gets its unique 'client ID' value;
			\param custom Client's 'connect data' (see zigclient_c::set_connect_data()) which is sent by the game client 
			in every connection request packet to the game server. It is the same data that was just passed to 
			accept_client().
	*/
	virtual void client_connected(int client_id, buffer_c &custom) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback called when a client disconnects from this server.

			\param client_id The ID of the client that has disconnected;
      \param zig_reason A code which explains the ZIG implementation's reason for the disconnection. The possible 
			values are enumerated by zigserver.h::zig_server_client_disconnection_reasons_t.
	*/
	virtual void client_disconnected(int client_id, int zig_reason) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback called when an UDP packet sent from a connected client is received.

			This method tells the server-side game code that an UDP packet that conforms to the internal ZIG protocol and 
			which was sent by a connected ZIG client, has been received and decoded by the ZIG server.

			READING STREAMS HERE: Since we are receiving a ZIG 2.x packet, the packet could be carrying stream payloads 
			(see zigclient_c for a discussion of 'streams'). This means that any incoming stream messages could have been 
			received. So, when implementing this method, it would be a good idea to poll the streams for any incoming 
			messages that they could have received:
			- To iterate through all stream IDs of this client: call seek_first_stream(int) and get_next_stream(int), passing
			\c client_id as parameter;
			- To read all messages that are waiting to be read from a given stream: receive_message(int,int) or 
			receive_message(int,buffer_c&,int), passing both \c client_id and the desired stream ID.

			The parameter \c in is the 'unreliable' block: the data that is just being sent on this packet, and that ZIG 
			will not retrasmit or order against other incoming messages. It is the data that is out of any of the ordering 
			streams (as such it is said to be on 'Stream zero'). It could be called the 'pure UDP' portion of the ZIG packet.

			This method is called by process_nonblocking(), which does the actual socket polling and reading.

			\param client_id is the ID of the client that sent the packet;
			\param in is the 'unreliable' block of data of the received packet;
			\param packet_id is ZIG's internal ID assigned to the packet.
	*/
	virtual void client_incoming_data(int client_id, buffer_c &in, int packet_id) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback called when the ZIG server has finished measuring the communication 
			Round-Trip Time (RTT) from and to one of the connected clients.

			The ZIG server automatically measures an approximation to the average delay that is being imposed by the 
			network to the packets sent to and received from every connected client. More specifically, ZIG measures 
			and returns the Round-Trip Time (RTT), that is, the amount of time that it takes:
			- To send a query ('ping') message from the server to a client;
			- To the client to receive and read the query, and to construct a reply;
			- To send the reply ('pong') message from the client to the server;
			- To the server to receive and read the reply, and to calculate the total time taken (the RTT).

			You can just provide an empty implementation to this method on the sub-class if you don't need client RTT 
			estimates. An option to turn off RTT measuring was not implemented since it uses very little additional 
			bandwidth.

			\param client_id The ID of the client whose RTT is being reported;
			\param ping_value The RTT, in milliseconds (ms), between the server and the client.

			\see get_client_latency() for the getter/poll version.
	*/
	virtual void client_ping_result(int client_id, int ping_value) = 0;

	/*! \brief <B>MUST BE IMPLEMENTED</B>. Callback called when a remote client wants to get some basic information about 
			this server. 
	
			Tipically, the remote client in question will be a client that is not yet connected to this server, and wants 
			to query the server about game-specific information such as: the map currently being played (to see if it is a 
			map that the player likes), the nicknames or IDs of the players that are currently playing on the server (to see 
			if one of the player's buddies is playing), the server-specific game rules, etc. When received by the client, 
			this information will be displayed on a server-browser for the player so he can choose on which server he will 
			play on.

			\param remote_addr IP address which sent the request;
			\param custom Additional information provided with the request (may be empty);
			\param answer Empty buffer that should be filled by the implementation of this method with the information 
			that was asked by the client. Upon returning from this callback, this buffer will be sent to the client at 
			\c remote_addr.

			\return Whether an answer packet should be sent to the ZIG client that triggered this query:
			- \c true Send the \c answer buffer to the client;
			- \c false Do not send anything; just ignore this server-info request (might be useful if a given IP address 
			is spamming the server with server-info queries, or if your game is not supposed to have a server-info feature).

			\see serverinfo_c
			\see zigclient_c::get_server_info()
			\see zigclient_c::get_local_server_info()
	*/
	virtual bool get_server_info(address_c &remote_addr, buffer_c &custom, buffer_c &answer) = 0;

	// ----------------------------------------------------------------------------------------
	//    METHODS THAT INTERACT WITH A GIVEN CLIENT (MESSAGING, PING & DISCONNECTION):
	// ----------------------------------------------------------------------------------------

	/*! \brief Gets the last measured value of Round-Trip Time (RTT) between the server and a given client.

			\param client_id ID of the client whose RTT you want to know.

			\return The RTT, in milliseconds (ms), between this server and the connected client whose ID is \c client_id;

			\see client_ping_result() for the callback version.
	*/ 
	int get_client_latency(int client_id);

	/*! \brief Disconnects a connected client, using the default (empty) disconnection reason data and the default timeout.

			This method initiates a 'graceful disconnection', that is, a message exchange between server and client that 
			aims to make known to the client that it is being disconnected. However, if the server is unable to finish 
			the 'graceful disconnection' procedure in 2 (two) seconds, then it will give up and just delete the client 
			from the server.

			NOTE: The remote zigclient_c::disconnected() callback will have an empty \c custom data buffer parameter.

			\param client_id The ID of the client to disconnect;
	*/
	void disconnect_client(int client_id) { if (server) server->disconnect_client(client_id); }

	/*! \brief Disconnects a connected client, providing a custom disconnection reason data and using the default timeout.

			This method initiates a 'graceful disconnection', that is, a message exchange between server and client that 
			aims to make known to the client that it is being disconnected. However, if the server is unable to finish 
			the 'graceful disconnection' procedure in 2 (two) seconds, then it will give up and just delete the client 
			from the server.

			\param client_id The ID of the client to disconnect;
			\param reason Custom data block (usually, reason for disconnection) that will show up on the remote 
			zigclient_c::disconnected() callback as its \c reason parameter;
	*/
	void disconnect_client(int client_id, buffer_c reason) { if (server) server->disconnect_client(client_id, reason); }

	/*! \brief Sends a ZIG UDP packet from this server to one of the connected clients.

			THE ZIG PACKET: the UDP packet that is generated by this call follows the ZIG internal protocol. Those 
			ZIG packets may contain each zero or more stream blocks. Each stream block contains zero or more messages 
			which are being sent or re-sent through the stream. The stream block also carries acknowledgements for 
			messages that have been received from the remote end of the stream. Additionally, the ZIG packet contains 
			a block of 'unreliable' data (also called 'Stream 0') whose delivery and ordering with other stream messages 
			or unreliable blocks are not guaranteed by ZIG. The \c udata parameter is the unreliable data block to be 
			included on the outgoing packet.

			OMITTED STREAM BLOCKS: A given stream's block may be ommited from an outgoing packet if there are no messages 
			in this stream's queue to send, or if it is not time to re-send messages yet. This is controlled mostly by 
			a streams' policy (see zigclient_c and policy_c), by set_max_outgoing_packet_sizes() and by the global rate 
			at which ZIG packets are sent from the ZIG server to each ZIG client, which is configured by both 
			zigserver_c::set_server_tick() and zigserver_c::set_net_ratio().
			
			If you call send_packet() frequently enough, then most packets will be generated without any stream blocks. 
			Together with the "mostly fixed" packet generation rates, this is how the ZIG protocol implements its rather 
			crude but somewhat workable flow control.

			The ZIG UDP packet sent by this method is received by the client at zigclient_c::incoming_data().

			\param client_id The ID of the connected client that should receive this packet;
			\param udata The unreliable data block ('Stream 0' block), with no guarantees of delivery nor ordering;
      \param packet_id An optional pointer to an int variable which receives the ZIG packet ID that is assigned to 
			the packet.

			\return Whether the packet was sent successfully or not.
			- \c true Packet sent OK (no errors detected);
			- \c false Packet not sent (invalid Client ID, ZIG server is not started, error sending packet, ...)
	*/ 
	bool send_packet(int client_id, buffer_c &udata, int *packet_id = 0);

	/*! \brief Sends a message through one of this connection's streams.
			
			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			The \c stream_id parameter must be a valid Stream ID returned by a call to create_stream(). Using hard-coded 
			values for the Stream ID is not recommended.

			<B>IMPORTANT:</B> There is a limit of 32767 bytes maximum for the size of messages. If the \c message parameter 
			is longer than 32767 bytes, then send_message() returns \c false and the message is not sent.

			\param client_id The ID of the client to which you want to send a message;
			\param message The message (block of bytes) to send through the stream of the specified client's connection;
			\param stream_id The ID of the stream (of the specified client's connection) through which the message is 
			to be sent;
			\param reliable Informs whether you want reliable delivery of the message or not:
			- \c true Is the default value and regular behavior, which means that ZIG should re-send the message until it 
			is acknowledged;
			- \c false Means that ZIG should try to deliver the message just once (on the next outgoing packet) and should
			not wait for any acknowledgements of the message. Using this value parameter allows for messages with guaranteed 
			ordering (since it is being sent through a stream) but not guaranteed delivery, resulting in a 'sequencing' kind 
			of channel.

			\return If the message has been successfully queued for delivery through this stream:
			- \c true Message will be sent on the next outgoing packet(s) to the client;
			- \c false Message will not be sent on the next outgoing packet(s) to the client, because the Stream ID is 
			invalid or the message is larger than 32767 bytes.
	*/ 
	bool send_message(int client_id, buffer_c &message, int stream_id, bool reliable = true) {
		if (server) return (server->send_message(client_id, message, stream_id, reliable) != 0);
		else return false;
	}

	// **** REMOVED: this is dangerous because stream creation/definition is per connection endpoint 
	// **** (station) and the server doesn't enforce the same streams available on all connections.
	// **** So the "default" stream on each connection can be completely different. Dangerous.
	//
	// broadcast a message. returns true on success;
	// NOTE: there is a limit of 32767 bytes maximum for reliable messages. if the message is longer 
	// than 32767 bytes, this method returns false and the message is not sent.
	// 
	// VERY IMPORTANT!!
	// Broadcast messages in default stream of every client.
	// If none stream created, sends in unreliable stream 0  
	//bool broadcast_message(buffer_c &message) {
	//	if (server) return (server->broadcast_message(message) != 0);
	//	else return false;
	//}

	/*! \brief Returns the next message received through a given stream of a given client's connection.

			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			The \c stream_id parameter must be a valid Stream ID returned by a call to create_stream(). Using hard-coded 
			values for the Stream ID is not recommended. If the \c stream_id parameter is not specified, then the client's 
			default stream is assumed, which is set by a call to set_default_stream_id().

			\param client_id The ID of the client whose stream messages we want to read;
			\param stream_id For the specified client, the ID of its stream that is to be read, or -1 to use the client's 
			default stream.

			\return Either:
			- A buffer_c containing a nonzero value in its \c code member variable, which means that the next message 
			that was received through the given stream of the given client connection is being returned as the contents 
			of the returned buffer_c;
			- A buffer_c containing the zero (0) value in its \c code member variable, which means that there were no 
			more messages to be read through the given stream of the given client connection, and so the contents of 
			the returned buffer_c are garbage.

			<B>EXAMPLE</B> - Process all messages from the default stream of a given client:

      <pre>
			int client_id = ...; // The ID of one of the connected clients
			buffer_c mes;
			do {
			   mes = receive_message(client_id); // Receive next message of the client's default stream
			   if (mes.code) {                   // Message received! Parse contents of 'mes' here...
			   }
			} while (mes.code);
			</pre>      

			\see receive_message(int,buffer_c&,int)
	*/
	buffer_c receive_message(int client_id, int stream_id = -1) {
		if (server) return server->receive_message(client_id, stream_id);
		else {
			buffer_c b;
			b.code = -1;
			return b;
		}
	}

	/*! \brief Returns the next message received through a given stream of a given client's connection.

			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			The \c stream_id parameter must be a valid Stream ID returned by a call to create_stream(). Using hard-coded 
			values for the Stream ID is not recommended. If the \c stream_id parameter is not specified, then the client's 
			default stream is assumed, which is set by a call to set_default_stream_id().

			\param client_id The ID of the client whose stream messages we want to read;
			\param stream_id For the specified client, the ID of its stream that is to be read, or -1 to use the client's 
			default stream;
			\param msgbuf Buffer supplied by the caller that should receive the contents of the message being read.

			\return An int code which reports what happened:
			- \c 1 means that the next message that was received through the given stream of the given client is being 
			returned through \c msgbuf;
			- \c 0 means that there were no more messages to be read through the given stream of the given client, and 
			so the contents of \c msgbuf are garbage;
			- \c -1 means that an error occurred (the client ID is invalid, the ZIG client isn't started/connected, or 
			something equally bad).

			\see receive_message(int)
	*/
	int receive_message(int client_id, buffer_c &msgbuf, int stream_id = -1) {
		if (server) return server->receive_message(client_id, msgbuf, stream_id);
		else return -1;
	}

	/*! \brief Creates a new stream endpoint for the current connection with a given client.
			
			Please see the general documentation of zigclient_c for an explanation of what 'streams' are.

			<B>IMPORTANT:</B> Both zigserver_c::create_stream() (server-side) and zigclient_c::create_stream() 
			(client-side) create a stream END-POINT. Suppose that you create a stream endpoint on the client-side 
			and that you don't create a stream endpoint on the server-side. In that case, the server won't be able to 
			receive messages sent through the client stream endpoint. So, you must call create_stream() twice,
			once on the server, and once on the client, to actually create a working stream.
			
			The create_stream() methods (server and client) return an int value which is the ID of the stream 
			endpoint that was just created. Once a ZIG connection is estabilished, the stream endpoint ID 
			generator of both client and server is set to 1 (one), and every subsequent call to create_stream() 
			on the same side of the connection will return the current ID generator's value and increase the ID 
			generator. 

			<B>This means that create_stream() calls will always return the same sequence of values: 1, 2, 3 ... etc. 
			after a connection is estabilished.</B> Thus, it would be wise to perform stream endpoint creation on the 
			'connected' callbacks of both zigserver_c and zigclient_c. <B>It is imperative that both ends of the 
			connection create the same amount of streams, and that the streams are created with a matching \c type 
			parameter</B>.

			\param client_id ID of the client connection, where the stream endpoint is to be created;
			\param type The type of the stream. See zig_stream_types_t for an explanation of each type;
			\param policy The stream's 'policy' for sending/re-sending messages (affects performance). See policy_c for 
			an explanation of each parameter.

			\return The ID of the created stream end-point. The remote host must create a stream endpoint with the same ID 
			and type in order to receive messages sent through this stream endpoint.

			<B>EXAMPLE</B> - Creating streams at client and server:

  	  <pre>
  	  GameClient::connected(buffer_c &buf) { // at the game client class (extends zigclient_c)
  	    &nbsp;// using three streams per client-server connection - create the CLIENT endpoints of those:
  	     game_stream = create_stream(STREAM_CUMULATIVE_ACK); // for game updates (stream 1)
  	     chat_stream = create_stream(STREAM_INDIVIDUAL_ACK); // for chatting (stream 2)
  	     file_stream = create_stream(STREAM_INDIVIDUAL_ACK); // for file transfer (stream 3)
  	     ...
  	  }
	
  	  GameServer::client_connected(int client_id, buffer_c &buf) { // at the game server class (extends zigserver_c)
  	    &nbsp;// using three streams per client-server connection - create the SERVER endpoints of those:
  	     player[client_id].game_stream = create_stream(client_id, STREAM_CUMULATIVE_ACK); // for game updates (stream 1)
  	     player[client_id].chat_stream = create_stream(client_id, STREAM_INDIVIDUAL_ACK); // for chatting (stream 2)
  	     player[client_id].file_stream = create_stream(client_id, STREAM_INDIVIDUAL_ACK); // for file transfer (stream 3)
  	     ...
  	  }
			</pre>
	*/
	int  create_stream(int client_id, int type = STREAM_CUMULATIVE_ACK, policy_c policy = DefaultPolicy) {
		if (server) return server->create_stream(client_id, type, policy);
		else return -1;
	}

	
	/*! \brief Deletes a stream endpoint from a given client's connection.

			You will probably never need to use this method. If you want to get rid of streams (I can't think why), you should 
			disconnect the client from this server and make it connect again.

			\param client_id ID of the client whose connection is losing a server-side stream endpoint;
			\param stream_id The ID of the stream endpoint you want to delete from the specified client's connection.

			\returns Returns \c true if the client ID and stream ID were found and the stream endpoint was found and deleted 
			successfully, \c false otherwise.
	*/
	bool delete_stream(int client_id, int stream_id) {
		if (server) return delete_stream(client_id, stream_id);
		else return false;
	}

	/*! \brief For a given client connection, sets its default stream ID.

			This method makes it easier to perform multiple operations over the same stream ID of a given client connection, 
			without needing to pass the actual stream ID as arguments to the method calls.

			\param client_id The ID of the client whose connection we are configuring;
			\param stream_id The new default stream ID of the client's connection.

			<B>EXAMPLE</B> - Using the default stream with send_message():

			<pre>
			int client_id = ... // The ID of some specific client the server is working with
      int chat_stream = create_stream(client_id); // stream for chatting
      int game_stream = create_stream(client_id); // stream for game object update messages
      <b>set_default_stream_id( client_id, game_stream ); // default is the game object stream</b>
      buffer_c msg;
      msg.putString("<startgame>"); // creates some game message
      <b>send_message(client_id, msg); // send the message through the current default stream (game_stream)</b>
      msg.clear(); 
      msg.putString("Game has started! Good luck!!\n"); // a chat message
      send_message(client_id, msg, chat_stream); // NOT through default stream - must specify
			</pre>
	*/
	void set_default_stream_id(int client_id, int stream_id) {
		if (server) server->set_default_stream_id(client_id, stream_id);
	}

	/*! \brief For a given client connection, gets the current value of its default stream ID.

			Returns the last value passed as parameter to set_default_stream_id(), for the same client ID. See the 
			documentation of set_default_stream_id() for more details.

			\param client_id The ID of the client whose default stream ID you want to know.

			\return The current 'default stream ID' of the specified client.
	*/
	int  get_default_stream_id(int client_id) {
		if (server) return server->get_default_stream_id(client_id);
		else return -1;
	}

	/*! \brief For a given client connection, seeks its first stream so that the next call to get_next_stream() (with 
			the same \c client_id parameter value) will return the ID of its first stream.
			
			This call starts a new iteration through the streams of the connection of the specified client. To actually 
			iterate over the streams of the specified client's connection (and to get the first element) you must call 
			get_next_stream(), using the same \c client_id parameter value that you have provided to this method.

			\param client_id The ID of the client whose stream iteration is being reset.
	*/
	bool seek_first_stream(int client_id) {
		if (server) return server->seek_first_stream(client_id);
		else return false;
	}

	/*! \brief For a given client connection, gets the ID of the next stream in the current stream iteration of that 
			client.

			After calling seek_first_stream() (with the same \c client_id parameter value) to start a new stream iteration, 
			each subsequent call to this method (with the same \c client_id parameter value) will return the ID of one of 
			the existing streams of the specified client's connection. When all valid stream IDs are returned (all positive 
			values), this method returns -1 until a new iteration is started.

			If this method is called without any preceding calls to seek_first_stream() (with the same \c client_id parameter 
			value!), the behavior is undefined.

			\param client_id The ID of the client whose streams you are iterating over.

			\return A valid int stream ID (positive value) or -1 (negative value) if there are no more streams in this 
			client's connection.
	*/
	int  get_next_stream(int client_id) {
		if (server) return server->get_next_stream(client_id);
		else return -1;
	}

protected: // ZIG 2.0: keep console protected:

	/*! \brief Console that the server application can use to log text and to get textual input from the user. */
	console_c *con;

private: // ZIG 2.0: leet_ interfaces shouldn't be documented and never need to be reached by the app 

	// ----------------------------------------------------------------------------------------
	//    below from this point are a lot of implementation details you shouldn't care
	//    about. do not call or override any of the following members...:
	// ----------------------------------------------------------------------------------------

	//leetserver calls to know if it accepts or denies a connection.
	virtual bool leet_accept_client(NLaddress &client_addr, const buffer_c &custom, buffer_c &answer);

	//leetserver callback: a client has just been accepted by (connected to) the leetserver
	// v1.3.4: "custom" is the same "custom" parameter that was passed to leet_accept_client()
	virtual void leet_client_connected(int client_id, buffer_c &custom);

	//leetserver callback: a client has just disconnected or been disconnected by the leetserver
	virtual void leet_client_disconnected(int client_id, int code_reason);

	//leetserver callback: incoming game packet from client
	virtual void leet_client_incoming_data(int client_id, buffer_c &in, int packet_id);

	// leetserver callback: somebody wants to get some server information... (see server.h for details)
	virtual bool leet_get_server_info(NLaddress &remote_addr, buffer_c &custom, buffer_c &answer);

private: // ZIG 2.0: moved from protected -- take out of docs and out of sight of the user

	//(attempts to) start the server. returns false on error.
	bool start_impl(int port, int maxplayers, int broadcast_port);

	//shuts down the server. this sends messages to clients, closes stuff... and then returns.
	//returns false if server not started.
	bool shutdown();

	//common constructor code (helper)
	void common_inits();

	//find client
	zig_remote_client_c *get_client(int client_id);

	//a map for client_id --> some client state
	std::map<int, zig_remote_client_c*> clients;

	//shutdown timeout, client timeout
	int shutdown_timeout;
	int client_timeout;

	//patch
	int conf_port, conf_maxplayers;

	//stop called?
	bool stop_called;

	//server net tick rate
	double server_tick;

	//server's updates-to-broadcasts net ratio
	int net_ratio;
	int net_ratio_skipcount;		//current skip count, when ==0, send and set to net_ratio

	//ping request stuff
	int implicit_ping_modulus;

  // Indicates if the server is full non-blocking (not only asynchronous, but also it doesn´t create
  // have an execution loop.
	bool running_nonblocking;

	//my local compression config flag. it is applied to all the new clients. -999 is a magic value that
	//specifies that the flag is not initialized yet (so let the default from station.h be used)
	int server_compression_config; // = -999; this value set at the constructor

	//nonblocking mode fix: replacement for the "static double nbLastSend(0);" inside process_nonblocking()
	double process_nonblocking_last_tick_time;

	//flag to signal stop() code that it is being called inside the ~zigserver_c destructor
	//this is used to prevent zigserver_c from calling the gameserver (derived class) which
	//has already been destroyed;
	bool running_this_destructor;

	// NEW v1.5.0: saves the last/greatest packet_id reported in an client_incoming_data() callback 
	// in order to be able to report late packets. a negative value means "no packet received/reported yet"
	int greatest_incoming_packet_id;

	// ZIGLITE 1.1: max outgoing packet size config. these is the default, applied to all the 
	// fresh clients that just connect.
	int cfg_max_packet_size;

private:
	
	//internal leetnet server
	server_c *server;

	// used by set_server_tick & set_net_ratio
	void timing_vars_changed_event();
};

#endif

